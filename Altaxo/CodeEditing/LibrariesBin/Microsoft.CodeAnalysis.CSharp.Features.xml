<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp.Features</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Check if there are interleaved directives on the statement.
            Handles special case with if/else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.IsConsideredMultiLine(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            <para>In general, statements are considered multiline if any of the following span more than one line:</para>
            <list type="bullet">
            <item><description>The part of the statement preceding the embedded statement</description></item>
            <item><description>The embedded statement itself</description></item>
            <item><description>The part of the statement following the embedded statement, for example the
            <c>while (...);</c> portion of a <c>do ... while (...);</c> statement</description></item>
            </list>
            <para>The third condition is not checked for <c>else</c> clauses because they are only considered multiline
            when their embedded statement is multiline.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.RequiresBracesToMatchContext(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Determines whether <paramref name="embeddedStatement"/> should use braces under a
            <see cref="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.WhenMultiline"/> preference due to the presence of braces on one or more
            sibling statements (the "context").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.GetOutermostIfStatementOfSequence(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the top-most <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax"/> for which <paramref name="ifStatementOrElseClause"/> is
            part of the <c>if</c>/<c>else if</c>/<c>else</c> sequence.
            </summary>
            <remarks>
            <para>For the purpose of brace usage analysis, the embedded statments of an <c>if</c>/<c>else if</c>/<c>else</c>
            sequence are considered sibling statements, even though they don't appear as immediate siblings in the
            syntax tree. This method walks up the syntax tree to find the <c>if</c> statement that starts the
            sequence.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.AnyPartOfIfSequenceUsesBraces(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>
            Determines if any embedded statement of an <c>if</c>/<c>else if</c>/<c>else</c> sequence uses braces. Only
            the embedded statements falling <em>immediately</em> under one of these nodes are checked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.Analyzers.CSharpPreferFrameworkTypeDiagnosticAnalyzer.IsPredefinedTypeReplaceableWithFrameworkType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <remarks>
             every predefined type keyword except <c>void</c> can be replaced by its framework type in code.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1061">
            <summary>
            type does not contain a definition of method or extension method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1935">
            <summary>
            cannot find implementation of query pattern
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0122">
            <summary>
            'A' is inaccessible due to its protection level
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0307">
            <summary>
            The using alias 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0616">
            <summary>
            'A' is not an attribute class
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1501">
            <summary>
             No overload for method 'X' takes 'N' arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1503">
            <summary>
            cannot convert from 'int' to 'string'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1574">
            <summary>
            XML comment on 'construct' has syntactically incorrect cref attribute 'name'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1580">
            <summary>
            Invalid type for parameter 'parameter number' in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1581">
            <summary>
            Invalid return type in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1584">
            <summary>
            XML comment has syntactically incorrect cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1929">
            <summary>
            Type 'X' does not contain a valid extension method accepting 'Y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1955">
            <summary>
            Property cannot be used like a method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0428">
            <summary>
            Cannot convert method group 'X' to non-delegate type 'Y'. Did you intend to invoke the method?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS7036">
            <summary>
             There is no argument given that corresponds to the required formal parameter 'X' of 'Y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS8129">
            <summary>
            o Deconstruct instance or extension method was found for type 'X', with N out parameters
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0281">
            <summary>
            Internal symbol inaccessible because public key is wrong
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>For testing purposes only (so that tests can pass in mock values)</summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AddMissingReference.CSharpAddMissingReferenceCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>For testing purposes only (so that tests can pass in mock values)</summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AliasAmbiguousType.CSharpAliasAmbiguousTypeCodeFixProvider.CS0104">
            <summary>
            'reference' is an ambiguous reference between 'identifier' and 'identifier'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanupService.s_diagnosticSets">
            <summary>
            Maps format document code cleanup options to DiagnosticId[]
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS4014">
            <summary>
            Because this call is not awaited, execution of the current method continues before the call is completed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS4016">
            <summary>
            Since this is an async method, the return expression must be of type 'blah' rather than 'baz'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS0029">
            <summary>
            cannot implicitly convert from 'X' to 'Y'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpConvertToAsyncMethodCodeFixProvider.CS4008">
            <summary>
            Cannot await void.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider">
            <summary>
            Helps fix void-returning methods or local functions to return a correct type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0029">
            <summary>
            CS0029: Cannot implicitly convert from type 'x' to 'y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0266">
            <summary>
            CS0266: Cannot implicitly convert from type 'x' to 'y'. An explicit conversion exists (are you missing a cast?)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider.CS1624">
            <summary>
            CS1624: The body of 'x' cannot be an iterator block because 'y' is not an iterator interface type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0104">
            <summary>
            'reference' is an ambiguous reference between 'identifier' and 'identifier'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider">
            <summary>
            Converts a verbatim interpolated string @$"" to an interpolated verbatim string $@""
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService.GetDisplayNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the node that should be displayed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService.GetDisplayName(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the DisplayName for the given node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddAwait.CSharpAddAwaitCodeRefactoringProvider">
            <summary>
            This refactoring complements the AddAwait fixer. It allows adding `await` and `await ... .ConfigureAwait(false)` even there is no compiler error to trigger the fixer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider.InitializerRewriter">
            <summary>
            This class handles rewriting initializer expressions that refer to the variable
            being initialized into a simpler form.  For example, in "int x = x = 1", we want to
            get just "1" back as the initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.PullMemberUp.CSharpPullMemberUpCodeRefactoringProvider.#ctor(Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.Dialog.IPullMemberUpOptionsService)">
            <summary>
            Test purpose only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.TryGetReplacementReferenceSyntax(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the namespce to be changed.
            If this reference is the right side of a qualified name, the new node returned would be the entire qualified name. Depends on 
            whether <paramref name="newNamespaceParts"/> is provided, the name in the new node might be qualified with this new namespace instead.
            </summary>
            <param name="reference">A reference to a type declared inside the namespce to be changed, which is calculated based on results from 
            `SymbolFinder.FindReferencesAsync`.</param>
            <param name="newNamespaceParts">If specified, and the reference is qualified with namespace, the namespace part of original reference 
            will be replaced with given namespace in the new node.</param>
            <param name="old">The node to be replaced. This might be an ancestor of original reference.</param>
            <param name="new">The replacement node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.ChangeNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Try to change the namespace declaration based on the following rules:
                - if neither declared nor target namespace are "" (i.e. global namespace),
                then we try to change the name of the namespace.
                - if declared namespace is "", then we try to move all types declared 
                in global namespace in the document into a new namespace declaration.
                - if target namespace is "", then we try to move all members in declared 
                namespace to global namespace (i.e. remove the namespace declaration).    
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.TryGetApplicableContainerFromSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
             <summary>
             For the node specified by <paramref name="span"/> to be applicable container, it must be a namespace 
             declaration or a compilation unit, contain no partial declarations and meet the following additional
             requirements:
             
             - If a namespace declaration:
                1. It doesn't contain or is nested in other namespace declarations
                2. The name of the namespace is valid (i.e. no errors)
            
             - If a compilation unit (i.e. <paramref name="span"/> is empty), there must be no namespace declaration
               inside (i.e. all members are declared in global namespace)
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.GetOpeningAndClosingTriviaOfNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax)">
            <summary>
            return trivia attached to namespace declaration. 
            Leading trivia of the node and trivia around opening brace, as well as
            trivia around closing brace are concatenated together respectively.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider.IsRelevantSymbolKind(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Check if the symbol is a relevant kind.
            Only relevant if symbol could cause a conflict with a local variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender.RefMemberModifiers">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet.AllMemberModifiers"/> with ref specific exclusions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender.RefGlobalMemberModifiers">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet.AllGlobalMemberModifiers"/> with ref specific exclusions
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateQueryExpressionOrLinqInvocation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Boolean)">
            <summary>
            Creates a query expression or a linq invocation expression.
            </summary>
            <param name="selectExpression">expression to be used into the last Select in the query expression or linq invocation.</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
            <param name="convertToQuery">Flag indicating if a query expression should be generated</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a query expression.
            </summary>
            <param name="selectExpression">expression to be used into the last 'select ...' in the query expression</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateLinqInvocation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a linq invocation expression.
            </summary>
            <param name="selectExpression">expression to be used in the last 'Select' invocation</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateLinqInvocationForExtendedNode(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Int32@,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@,System.Boolean@)">
            <summary>
            Creates a linq invocation expression for the <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> node at the given index <paramref name="extendedNodeIndex"/>
            or returns the <paramref name="selectExpression"/> if all extended nodes have been processed.
            </summary>
            <param name="selectExpression">Innermost select expression</param>
            <param name="extendedNodeIndex">Index into <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> to be processed and updated.</param>
            <param name="receiver">Receiver for the generated linq invocation. Updated when processing an if statement.</param>
            <param name="hasForEachChild">Flag indicating if any of the processed <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> is a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractToMethodConverter">
            <summary>
            Provides a conversion to query.Method() like query.ToList(), query.Count().
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter">
            <summary>
            Provides a conversion to query.Count().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter.CreateDefaultStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            Input:
            foreach(...)
            {
                ...
                ...
                counter++;
             }
             
             Output:
             counter += queryGenerated.Count();
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter">
            <summary>
            Provides a conversion to query.ToList().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter.CanReplaceInitialization(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            Checks that the expression is "new List();"
            Exclude "new List(a);" and new List() { 1, 2, 3}
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter.CreateDefaultStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            Input:
            foreach(...)
            {
                ...
                ...
                list.Add(item);
             }
             
             Output:
             list.AddRange(queryGenerated);
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider.FindNodeToRefactor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Finds a node for the span and checks that it is either a QueryExpressionSyntax or a QueryExpressionSyntax argument within ArgumentSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider.Converter.CanTryConvertToLocalFunction">
            <summary>
            Checks if the location of the query expression allows to convert it at least to a local function.
            It still does not guarantees that the conversion can be performed. There can be bail outs of later stages.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources._0_does_not_contain_a_constructor_that_takes_that_many_arguments">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a constructor that takes that many arguments..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources._0_is_not_null_here">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not null here..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources._0_may_be_null_here">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; may be null here..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_accessibility_modifiers">
            <summary>
              Looks up a localized string similar to Add accessibility modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_await">
            <summary>
              Looks up a localized string similar to Add await.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_Await_and_ConfigureAwaitFalse">
            <summary>
              Looks up a localized string similar to Add await and ConfigureAwait(false).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_missing_usings">
            <summary>
              Looks up a localized string similar to Add missing usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_Obsolete">
            <summary>
              Looks up a localized string similar to Add [Obsolete].
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_parentheses_around_conditional_expression_in_interpolated_string">
            <summary>
              Looks up a localized string similar to Add parentheses.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_remove_braces_for_single_line_control_statements">
            <summary>
              Looks up a localized string similar to Add/remove braces for single-line control statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_this">
            <summary>
              Looks up a localized string similar to Add &apos;this.&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Allow_unsafe_code_in_this_project">
            <summary>
              Looks up a localized string similar to Allow unsafe code in this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.anonymous_method">
            <summary>
              Looks up a localized string similar to anonymous method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_expression_block_body_preferences">
            <summary>
              Looks up a localized string similar to Apply expression/block body preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_implicit_explicit_type_preferences">
            <summary>
              Looks up a localized string similar to Apply implicit/explicit type preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_inline_out_variable_preferences">
            <summary>
              Looks up a localized string similar to Apply inline &apos;out&apos; variables preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_language_framework_type_preferences">
            <summary>
              Looks up a localized string similar to Apply language/framework type preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_object_collection_initialization_preferences">
            <summary>
              Looks up a localized string similar to Apply object/collection initialization preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_this_qualification_preferences">
            <summary>
              Looks up a localized string similar to Apply &apos;this.&apos; qualification preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.attribute_target">
            <summary>
              Looks up a localized string similar to attribute target.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_member_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to member declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_namespace_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to namespace declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_possible_deconstruction_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to possible deconstruction declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to possible explicitly named anonymous type member creation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_possible_tuple_type_element_creation">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to possible tuple type element creation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_potential_lambda_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to potential lambda declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_potential_range_variable_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to potential range variable declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_type_declaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to type declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.await_expression">
            <summary>
              Looks up a localized string similar to await expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.awaitable">
            <summary>
              Looks up a localized string similar to awaitable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.awaitable_extension">
            <summary>
              Looks up a localized string similar to awaitable, extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Can_t_determine_valid_range_of_statements_to_extract">
            <summary>
              Looks up a localized string similar to Can&apos;t determine valid range of statements to extract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.catch_clause">
            <summary>
              Looks up a localized string similar to catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Change_return_type_from_0_to_1">
            <summary>
              Looks up a localized string similar to Change return type from {0} to {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.checked_statement">
            <summary>
              Looks up a localized string similar to checked statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.class_name">
            <summary>
              Looks up a localized string similar to &lt;class name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Conflict_s_detected">
            <summary>
              Looks up a localized string similar to Conflict(s) detected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Contains_invalid_selection">
            <summary>
              Looks up a localized string similar to Contains invalid selection..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.conversion_operator">
            <summary>
              Looks up a localized string similar to conversion operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_switch_statement_to_expression">
            <summary>
              Looks up a localized string similar to Convert switch statement to expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_for">
            <summary>
              Looks up a localized string similar to Convert to &apos;for&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_foreach">
            <summary>
              Looks up a localized string similar to Convert to &apos;foreach&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_method">
            <summary>
              Looks up a localized string similar to Convert to method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_switch">
            <summary>
              Looks up a localized string similar to Convert to &apos;switch&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Declare_as_nullable">
            <summary>
              Looks up a localized string similar to Declare as nullable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.deconstruction">
            <summary>
              Looks up a localized string similar to deconstruction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Delegate_invocation_can_be_simplified">
            <summary>
              Looks up a localized string similar to Delegate invocation can be simplified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.deprecated">
            <summary>
              Looks up a localized string similar to deprecated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.designation_name">
            <summary>
              Looks up a localized string similar to &lt;designation name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.destructor">
            <summary>
              Looks up a localized string similar to destructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Do_not_change_this_code_Put_cleanup_code_in_Dispose_bool_disposing_above">
            <summary>
              Looks up a localized string similar to Do not change this code. Put cleanup code in Dispose(bool disposing) above..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.element_name">
            <summary>
              Looks up a localized string similar to &lt;element name&gt; : .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.event_field">
            <summary>
              Looks up a localized string similar to event field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.extension">
            <summary>
              Looks up a localized string similar to extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.filter_clause">
            <summary>
              Looks up a localized string similar to filter clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.finally_clause">
            <summary>
              Looks up a localized string similar to finally clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Fix_return_type">
            <summary>
              Looks up a localized string similar to Fix return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.fixed_statement">
            <summary>
              Looks up a localized string similar to fixed statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.foreach_statement">
            <summary>
              Looks up a localized string similar to foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.from_clause">
            <summary>
              Looks up a localized string similar to from clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Generate_explicit_conversion_operator_in_0">
            <summary>
              Looks up a localized string similar to Generate explicit conversion operator in &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Generate_implicit_conversion_operator_in_0">
            <summary>
              Looks up a localized string similar to Generate implicit conversion operator in &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.global_statement">
            <summary>
              Looks up a localized string similar to global statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.groupby_clause">
            <summary>
              Looks up a localized string similar to groupby clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Hide_base_member">
            <summary>
              Looks up a localized string similar to Hide base member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.if_statement_can_be_simplified">
            <summary>
              Looks up a localized string similar to &apos;if&apos; statement can be simplified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer">
            <summary>
              Looks up a localized string similar to indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer_getter">
            <summary>
              Looks up a localized string similar to indexer getter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer_setter">
            <summary>
              Looks up a localized string similar to indexer setter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Inline_temporary_variable">
            <summary>
              Looks up a localized string similar to Inline temporary variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Insert_await">
            <summary>
              Looks up a localized string similar to Insert &apos;await&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.interface_name">
            <summary>
              Looks up a localized string similar to &lt;interface name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.into_clause">
            <summary>
              Looks up a localized string similar to into clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Introduce_using_statement">
            <summary>
              Looks up a localized string similar to Introduce &apos;using&apos; statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Invalid_selection">
            <summary>
              Looks up a localized string similar to Invalid selection..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Invert_if">
            <summary>
              Looks up a localized string similar to Invert if.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.is_pattern">
            <summary>
              Looks up a localized string similar to is pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.join_clause">
            <summary>
              Looks up a localized string similar to join clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lambda">
            <summary>
              Looks up a localized string similar to lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lambda_expression">
            <summary>
              Looks up a localized string similar to &lt;lambda expression&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.let_clause">
            <summary>
              Looks up a localized string similar to let clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.local_function">
            <summary>
              Looks up a localized string similar to local function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lock_statement">
            <summary>
              Looks up a localized string similar to lock statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_0_return_Task_instead_of_void">
            <summary>
              Looks up a localized string similar to Make {0} return Task instead of void..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_method_async">
            <summary>
              Looks up a localized string similar to Make method async.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_method_async_remain_void">
            <summary>
              Looks up a localized string similar to Make method async (stay void).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_private_field_readonly_when_possible">
            <summary>
              Looks up a localized string similar to Make private fields readonly when possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_ref_struct">
            <summary>
              Looks up a localized string similar to Make &apos;ref struct&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.member_name">
            <summary>
              Looks up a localized string similar to &lt;member name&gt; = .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Misplaced_using_directive">
            <summary>
              Looks up a localized string similar to Misplaced using directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Move_misplaced_using_directives">
            <summary>
              Looks up a localized string similar to Move misplaced using directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Name">
            <summary>
              Looks up a localized string similar to &lt;Name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Name_can_be_simplified">
            <summary>
              Looks up a localized string similar to Name can be simplified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.namespace_name">
            <summary>
              Looks up a localized string similar to &lt;namespace name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.No_common_root_node_for_extraction">
            <summary>
              Looks up a localized string similar to No common root node for extraction..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.No_valid_selection_to_perform_extraction">
            <summary>
              Looks up a localized string similar to No valid selection to perform extraction..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.No_valid_statement_range_to_extract">
            <summary>
              Looks up a localized string similar to No valid statement range to extract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Not_all_code_paths_return">
            <summary>
              Looks up a localized string similar to Not all code paths return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.orderby_clause">
            <summary>
              Looks up a localized string similar to orderby clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Organize_Usings">
            <summary>
              Looks up a localized string similar to Organize Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.out_var">
            <summary>
              Looks up a localized string similar to out variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Properties">
            <summary>
              Looks up a localized string similar to Properties.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.property_getter">
            <summary>
              Looks up a localized string similar to property getter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.property_setter">
            <summary>
              Looks up a localized string similar to property setter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.query_body">
            <summary>
              Looks up a localized string similar to query body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.range_variable">
            <summary>
              Looks up a localized string similar to &lt;range variable&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ref_local_or_expression">
            <summary>
              Looks up a localized string similar to ref local or expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_and_Sort_Usings">
            <summary>
              Looks up a localized string similar to R&amp;emove and Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_this_qualification">
            <summary>
              Looks up a localized string similar to Remove &apos;this&apos; qualification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_unnecessary_casts">
            <summary>
              Looks up a localized string similar to Remove unnecessary casts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_Unnecessary_Usings">
            <summary>
              Looks up a localized string similar to Remove Unnecessary Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_unused_function">
            <summary>
              Looks up a localized string similar to Remove unused function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_unused_variables">
            <summary>
              Looks up a localized string similar to Remove unused variables.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Replace_return_with_yield_return">
            <summary>
              Looks up a localized string similar to Replace return with yield return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.select_clause">
            <summary>
              Looks up a localized string similar to select clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_be_part_of_constant_initializer_expression">
            <summary>
              Looks up a localized string similar to Selection can not be part of constant initializer expression..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_a_pattern_expression">
            <summary>
              Looks up a localized string similar to Selection can not contain a pattern expression..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_a_yield_statement">
            <summary>
              Looks up a localized string similar to Selection can not contain a yield statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_throw_statement">
            <summary>
              Looks up a localized string similar to Selection can not contain throw statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_cross_over_preprocessor_directives">
            <summary>
              Looks up a localized string similar to Selection can not cross over preprocessor directives..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_does_not_contain_a_valid_node">
            <summary>
              Looks up a localized string similar to Selection does not contain a valid node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_does_not_contain_a_valid_token">
            <summary>
              Looks up a localized string similar to Selection does not contain a valid token..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Simplify_all_occurrences">
            <summary>
              Looks up a localized string similar to Simplify all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Simplify_lambda_expression">
            <summary>
              Looks up a localized string similar to Simplify lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Simplify_member_access_0">
            <summary>
              Looks up a localized string similar to Simplify member access &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Simplify_name_0">
            <summary>
              Looks up a localized string similar to Simplify name &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Sort_accessibility_modifiers">
            <summary>
              Looks up a localized string similar to Sort accessibility modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Sort_Usings">
            <summary>
              Looks up a localized string similar to &amp;Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.struct_">
            <summary>
              Looks up a localized string similar to struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.struct_name">
            <summary>
              Looks up a localized string similar to &lt;struct name&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Suggested_name">
            <summary>
              Looks up a localized string similar to (Suggested name).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_name_0_does_not_exist_in_the_current_context">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; does not exist in the current context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_selected_code_is_inside_an_unsafe_context">
            <summary>
              Looks up a localized string similar to The selected code is inside an unsafe context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_selection_contains_syntactic_errors">
            <summary>
              Looks up a localized string similar to The selection contains syntactic errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.This_code_added_to_correctly_implement_the_disposable_pattern">
            <summary>
              Looks up a localized string similar to This code added to correctly implement the disposable pattern..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_a_finalizer_below">
            <summary>
              Looks up a localized string similar to TODO: free unmanaged resources (unmanaged objects) and override a finalizer below..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TODO_colon_override_a_finalizer_only_if_Dispose_bool_disposing_above_has_code_to_free_unmanaged_resources">
            <summary>
              Looks up a localized string similar to TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TODO_colon_uncomment_the_following_line_if_the_finalizer_is_overridden_above">
            <summary>
              Looks up a localized string similar to TODO: uncomment the following line if the finalizer is overridden above..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.try_block">
            <summary>
              Looks up a localized string similar to try block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.tuple">
            <summary>
              Looks up a localized string similar to tuple.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.unchecked_statement">
            <summary>
              Looks up a localized string similar to unchecked statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Unseal_class_0">
            <summary>
              Looks up a localized string similar to Unseal class &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Upgrade_all_csharp_projects_to_language_version_0">
            <summary>
              Looks up a localized string similar to Upgrade all C# projects to language version &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Upgrade_this_project_to_csharp_language_version_0">
            <summary>
              Looks up a localized string similar to Upgrade this project to C# language version &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_0">
            <summary>
              Looks up a localized string similar to Use &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_explicit_type">
            <summary>
              Looks up a localized string similar to Use explicit type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_explicit_type_instead_of_var">
            <summary>
              Looks up a localized string similar to Use explicit type instead of &apos;var&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_implicit_type">
            <summary>
              Looks up a localized string similar to Use implicit type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_is_null_check">
            <summary>
              Looks up a localized string similar to Use &apos;is null&apos; check.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_switch_expression">
            <summary>
              Looks up a localized string similar to Use &apos;switch&apos; expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.use_var_instead_of_explicit_type">
            <summary>
              Looks up a localized string similar to use &apos;var&apos; instead of explicit type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_directive">
            <summary>
              Looks up a localized string similar to using directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Using_directive_is_unnecessary">
            <summary>
              Looks up a localized string similar to Using directive is unnecessary..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Using_directives_must_be_placed_inside_of_a_namespace_declaration">
            <summary>
              Looks up a localized string similar to Using directives must be placed inside of a namespace declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Using_directives_must_be_placed_outside_of_a_namespace_declaration">
            <summary>
              Looks up a localized string similar to Using directives must be placed outside of a namespace declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_namespace">
            <summary>
              Looks up a localized string similar to using namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_statement">
            <summary>
              Looks up a localized string similar to using statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.v7_switch">
            <summary>
              Looks up a localized string similar to C# 7 enhanced switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Warning_colon_Moving_using_directives_may_change_code_meaning">
            <summary>
              Looks up a localized string similar to Warning: Moving using directives may change code meaning..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Warning_Extracting_a_local_function_reference_may_produce_invalid_code">
            <summary>
              Looks up a localized string similar to Warning: Extracting a local function reference may produce invalid code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.where_clause">
            <summary>
              Looks up a localized string similar to where clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.yield_statement">
            <summary>
              Looks up a localized string similar to yield statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.TryGetClosestBreakpointSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Given a syntax token determines a text span delimited by the closest applicable sequence points 
            encompassing the token.
            </summary>
            <remarks>
            If the span exists it is possible to place a breakpoint at the given position.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.IsBreakableExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
             <summary>
             There are a few places where we allow breakpoints on expressions. 
            
             1) When the expression is the body of a lambda/method/operator/property/indexer.
             2) The expression is a breakable expression inside a query expression.
             3) The expression is in a for statement initializer, condition or incrementor.
             4) The expression is a foreach initializer.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.FindMemberDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/> for methods, operators, constructors, destructors and accessors.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax"/> for field initializers.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> for property initializers and expression bodies.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/> for indexer expression bodies.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.TryGetDeclarationBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <returns>
            Given a node representing a declaration (<paramref name="isMember"/> = true) or a top-level match node (<paramref name="isMember"/> = false) returns:
            - <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax"/> for method-like member declarations with block bodies (methods, operators, constructors, destructors, accessors).
            - <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> for variable declarators of fields, properties with an initializer expression, or 
              for method-like member declarations with expression bodies (methods, properties, indexers, operators)
            
            A null reference otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.TryGetActiveTokens(Microsoft.CodeAnalysis.SyntaxNode)">
            <returns>
            If <paramref name="node"/> is a method, accessor, operator, destructor, or constructor without an initializer,
            tokens of its block body, or tokens of the expression body.
            
            If <paramref name="node"/> is an indexer declaration the tokens of its expression body.
            
            If <paramref name="node"/> is a property declaration the tokens of its expression body or initializer.
              
            If <paramref name="node"/> is a constructor with an initializer, 
            tokens of the initializer concatenated with tokens of the constructor body.
            
            If <paramref name="node"/> is a variable declarator of a field with an initializer,
            tokens of the field initializer.
            
            Null reference otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.GetExceptionHandlingRegion(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@)">
            <summary>
            An active statement (leaf or not) inside a "catch" makes the catch block read-only.
            An active statement (leaf or not) inside a "finally" makes the whole try/catch/finally block read-only.
            An active statement (non leaf)    inside a "try" makes the catch/finally block read-only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.StatementSyntaxComparer.Classify(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@)">
            <summary>
            <paramref name="nodeOpt"/> is null only when comparing value equality of a tree node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.TryComputeWeightedDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Double@)">
            <summary>
            Calculates distance of two nodes based on their significant parts.
            Returns false if the nodes don't have any significant parts and should be compared as a whole.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetDescendantTokensIgnoringSeparators``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0})">
            <summary>
            Enumerates tokens of all nodes in the list. Doesn't include separators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Calculates the distance between two syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the nodes are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Calculates the distance between two syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the tokens are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the distance between two sequences of syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.TopSyntaxComparer.TiedToAncestor(Microsoft.CodeAnalysis.CSharp.EditAndContinue.TopSyntaxComparer.Label)">
            <summary>
            Return 1 if it is desirable to report two edits (delete and insert) rather than a move edit
            when the node changes its parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor.CSharpCodeGenerator.FixDeclarationExpressionsAndDeclarationPatterns(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            If the statement has an <c>out var</c> declaration expression for a variable which
            needs to be removed, we need to turn it into a plain <c>out</c> parameter, so that
            it doesn't declare a duplicate variable.
            If the statement has a pattern declaration (such as <c>3 is int i</c>) for a variable
            which needs to be removed, we will annotate it as a conflict, since we don't have
            a better refactoring.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorCodeFixProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> gives users a way to generate constructors for an existing
            type when a user tries to 'new' up an instance of that type with a set of parameter that does
            not match any existing constructor.  i.e. it is the equivalent of 'Generate-Method' but for
            constructors.  Parameters for the constructor will be picked in a manner similar to Generate-
            Method.  However, this type will also attempt to hook up those parameters to existing fields
            and properties, or pass them to a this/base constructor if available.
            
            Importantly, this type is not responsible for generating constructors for a type based on 
            the user selecting some fields/properties of that type.  Nor is it responsible for generating
            derived class constructors for all unmatched base class constructors in a type hierarchy.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                int i;
                if (int.TryParse(s, out i)) { }
                
            And offers to convert it to:
            
                if (int.TryParse(s, out var i)) { }   or
                if (int.TryParse(s, out int i)) { }   or
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService.CanIntroduceVariableFor(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Checks for conditions where we should not generate a variable for an expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider">
            <summary>
            Implements a code fix for all misplaced using statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSemanticQuickInfoProvider.GetBindableNodeForTokenIndicatingLambda(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the token is the '=>' in a lambda, or the 'delegate' in an anonymous function,
            return the syntax for the lambda or anonymous function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersCodeFixProvider.AdjustAndAddAppropriateDeclaratorsToRemove(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method adjusts the <paramref name="declarators"/> to remove based on whether or not all variable declarators
            within a field declaration should be removed,
            i.e. if all the fields declared within a field declaration are unused,
            we can remove the entire field declaration instead of individual variable declarators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService.IsValueName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>
            Used by the documentation comment rewriters to identify top-level <c>&lt;value&gt;</c> nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.IncompleteElementAccessExpression">
            Error tolerance case for
                "goo[$$]" or "goo?[$$]"
            which is parsed as an ArrayTypeSyntax variable declaration instead of an ElementAccessExpression  
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.ConditionalAccessExpression">
            Error tolerance case for
                "new String()?[$$]"
            which is parsed as a BracketedArgumentListSyntax parented by an ElementBindingExpressionSyntax parented by a ConditionalAccessExpressionSyntax
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Structure.MetadataAsSource.AbstractMetadataAsSourceStructureProvider`1.GetHintTextEndToken(`0)">
            <summary>
            Returns the last token to be included in the regions hint text.
            </summary>
            <remarks>
            Note that the text of this token is included in the hint text, but not its
            trailing trivia. See also <seealso cref="M:Microsoft.CodeAnalysis.CSharp.Structure.MetadataAsSource.AbstractMetadataAsSourceStructureProvider`1.GetEndToken(`0)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Structure.MetadataAsSource.AbstractMetadataAsSourceStructureProvider`1.GetEndToken(`0)">
            <summary>
            Returns the token that marks the end of the collapsible region for the given node.
            </summary>
            <remarks>
            Note that the text of the returned token is *not* included in the region, but any
            leading trivia will be. This allows us to put the banner text for the collapsed
            region immediately before the type or member.
            See also <seealso cref="M:Microsoft.CodeAnalysis.CSharp.Structure.MetadataAsSource.AbstractMetadataAsSourceStructureProvider`1.GetHintTextEndToken(`0)"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule">
            <summary>
            Special formatting rule that will convert a conditional expression into the following
            form if it has the <see cref="F:Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers.SpecializedFormattingAnnotation"/> on it:
            
            <code>
                var v = expr
                    ? whenTrue
                    : whenFalse
            </code>
            
            i.e. both branches will be on a newline, indented once from the parent indentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaHelpers">
            <summary>
            Helper class that allows us to share lots of logic between the diagnostic analyzer and the
            code refactoring provider.  Those can't share a common base class due to their own inheritance
            requirements with <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> and <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper`1">
            <summary>
            Helper class that allows us to share lots of logic between the diagnostic analyzer and the
            code refactoring provider.  Those can't share a common base class due to their own inheritance
            requirements with <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> and <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer">
             <summary>
             Analyzer that looks for code like: 
             
             1) `s[s.Length - n]` and offers to change that to `s[^n]`. and.
             2) `s.Get(s.Length - n)` and offers to change that to `s.Get(^n)`
            
             In order to do convert between indexers, the type must look 'indexable'.  Meaning, it must
             have an int-returning property called 'Length' or 'Count', and it must have both an
             int-indexer, and a System.Index-indexer.  In order to convert between methods, the type
             must have identical overloads except that one takes an int, and the other a System.Index.
            
             It is assumed that if the type follows this shape that it is well behaved and that this
             transformation will preserve semantics.  If this assumption is not good in practice, we
             could always limit the feature to only work on a whitelist of known safe types.
             
             Note that this feature only works if the code literally has `expr1.Length - expr2`.  If
             code has this, and is calling into a method that takes either an int or a System.Index,
             it feels very safe to assume this is well behaved and switching to `^expr2` is going to
             preserve semantics.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache">
            <summary>
            Helper type to cache information about types while analyzing the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache._indexType">
            <summary>
            The System.Index type.  Needed so that we only fixup code if we see the type
            we're using has an indexer that takes an Index.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache._methodToMemberInfo">
            <summary>
            Mapping from a method like 'MyType.Get(int)' to the Length/Count property for
            'MyType' as well as the optional 'MyType.Get(System.Index)' member if it exists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider.IsFromEnd(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation@)">
            <summary>
            check if its the form: `expr.Length - value`.  If so, update rangeOperation to then
            point to 'value' so that we can generate '^value'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer">
             <summary>
             Analyzer that looks for several variants of code like `s.Slice(start, end - start)` and
             offers to update to `s[start..end]` or `s.Slice(start..end)`.  In order to convert to the
             indexer, the type being called on needs a slice-like method that takes two ints, and returns
             an instance of the same type. It also needs a Length/Count property, as well as an indexer
             that takes a System.Range instance.  In order to convert between methods, there need to be
             two overloads that are equivalent except that one takes two ints, and the other takes a
             System.Range.
            
             It is assumed that if the type follows this shape that it is well behaved and that this
             transformation will preserve semantics.  If this assumption is not good in practice, we
             could always limit the feature to only work on a whitelist of known safe types.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.InfoCache">
            <summary>
            Helper type to cache information about types while analyzing the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.InfoCache._rangeType">
            <summary>
            The System.Range type.  Needed so that we only fixup code if we see the type
            we're using has an indexer that takes a Range.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.TryGetLengthOrCountProperty(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Find an `int MyType.Count` or `int MyType.Length` property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.TryGetNoArgInt32Property(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Tried to find a public, non-static, int-returning property in the given type with the
            specified <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IndexExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Creates an `^expr` index expression from a given `expr`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsInstanceLengthCheck(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Checks if this <paramref name="operation"/> is `expr.Length` where `expr` is equivalent
            to the <paramref name="instance"/> we were originally invoking an accessor/method off
            of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsSubtraction(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.Operations.IBinaryOperation@)">
            <summary>
            Checks if <paramref name="operation"/> is a binary subtraction operator. If so, it
            will be returned through <paramref name="subtraction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsIntIndexingMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Look for methods like "SomeType MyType.Get(int)".  Also matches against the 'getter'
            of an indexer like 'SomeType MyType.this[int]`
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsSliceLikeMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Look for methods like "SomeType MyType.Slice(int start, int length)".  Note that the
            names of the parameters are checked to ensure they are appropriate slice-like.  These
            names were picked by examining the patterns in the BCL for slicing members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.GetIndexer(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Finds a public, non-static indexer in the given type.  The indexer has to accept the
            provided <paramref name="parameterType"/> and must return the provided <paramref
            name="returnType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.GetOverload(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Finds a public, non-static overload of <paramref name="method"/> in the containing type.
            The overload must have the same return type as <paramref name="method"/>.  It must only
            have a single parameter, with the provided <paramref name="parameterType"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo.LengthLikeProperty">
            <summary>
            The Length/Count property on the type.  Must be public, non-static, no-parameter,
            int32 returning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo.OverloadedMethodOpt">
            <summary>
            Optional paired overload that takes a Range/Index parameter instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                Func&lt;int, int&gt; fib = n =>
                {
                    if (n &lt;= 2)
                        return 1
                        
                    return fib(n - 1) + fib(n - 2);
                }
                
            and converts it to:
            
                int fib(int n)
                {
                    if (n &lt;= 2)
                        return 1
                        
                    return fib(n - 1) + fib(n - 2);
                }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer">
            <summary>
            Looks for code of the forms:
            
                var x = o as Type;
                if (x != null) ...
            
            and converts it to:
            
                if (o is Type x) ...
                
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                if (expr is Type)
                {
                    var v = (Type)expr;
                }
                
            and converts it to:
            
                if (expr is Type v)
                {
                }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer that looks for is-tests and cast-expressions, and offers to convert them
            to use patterns.  i.e. if the user has <c>obj is TestFile &amp;&amp; ((TestFile)obj).Name == "Test"</c>
            it will offer to convert that <c>obj is TestFile file &amp;&amp; file.Name == "Test"</c>.
            
            Complements <see cref="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer"/> (which does the same,
            but only for code cases where the user has provided an appropriate variable name in
            code that can be used).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer">
             <summary>
             Looks for code like:
            
                 ```c#
                 using (var a = b)
                 using (var c = d)
                 using (var e = f)
                 {
                 }
                 ```
             
             And offers to convert it to:
            
                 ```c#
                 using var a = b;
                 using var c = d;
                 using var e = f;
                 ```
            
             (this of course works in the case where there is only one using).
             
             A few design decisions:
                 
             1. We only offer this if the entire group of usings in a nested stack can be
                converted.  We don't want to take a nice uniform group and break it into
                a combination of using-statements and using-declarations.  That may feel 
                less pleasant to the user than just staying uniform.
             
             2. We're conservative about converting.  Because `using`s may be critical for
                program correctness, we only convert when we're absolutely *certain* that
                semantics will not change.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node represents a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns a node that represents the lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            See SyntaxNode.GetCorrespondingLambdaBody.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns true if the specified <paramref name="node"/> represents a body of a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsReducedSelectOrGroupByClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When queries are translated into expressions select and group-by expressions such that
            1) select/group-by expression is the same identifier as the "source" identifier and
            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or
               the expression in question is a group-by expression and the body has no clause
            
            do not translate into lambdas.
            By "source" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.
            
            The above condition can be derived from the language specification (chapter 7.16.2) as follows:
            - In order for 7.16.2.5 "Select clauses" to be applicable the following conditions must hold:
              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 "Degenerate query expressions".
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
              
            - In order for 7.16.2.6 "Groupby clauses" to be applicable the following conditions must hold:
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <remarks>
            In C# lambda bodies are expressions or block statements. In both cases it's a single node.
            In VB a lambda body might be a sequence of nodes (statements). 
            We define this function to minimize differences between C# and VB implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compares content of two nodes ignoring lambda bodies and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsQueryPairLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            "Pair lambda" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node is of a kind that could represent a closure scope -- that
            is, a scope of a captured variable.
            Doesn't check whether or not the node actually declares any captured variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpAddDocCommentNodesCodeFixProvider.CS1573">
            <summary>
            Parameter has no matching param tag in XML comment
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpRemoveDocCommentNodeCodeFixProvider.CS1571">
            <summary>
            Duplicate param tag
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpRemoveDocCommentNodeCodeFixProvider.CS1572">
            <summary>
            Param tag with no matching parameter
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpRemoveDocCommentNodeCodeFixProvider.CS1710">
            <summary>
            Duplicate typeparam tag
            </summary>
        </member>
    </members>
</doc>
