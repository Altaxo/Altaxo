<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Features</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider.AddConstructorParametersCodeAction._useSubMenuName">
            <summary>
            If there is more than one constructor, the suggested actions will be split into two sub menus,
            one for regular parameters and one for optional. This boolean is used by the Title property
            to determine if the code action should be given the complete title or the sub menu title
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider.State.GetConstructorCandidatesInfoAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Threading.CancellationToken)">
            <summary>
            Try to find all constructors in <paramref name="containingType"/> whose parameters
            are a subset of the selected members by comparing name.
            These constructors will not be considered as potential candidates:
             - if the constructor's parameter list contains 'ref' or 'params'
             - any constructor that has a params[] parameter
             - deserialization constructor
             - implicit default constructor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider.UpdateEmbeddedFileNames(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Looks at <paramref name="banner"/> to see if it contains the name of <paramref name="sourceDocument"/>
            in it.  If so, those names will be replaced with <paramref name="destinationDocument"/>'s name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.GetUnreferencedMetadataReferences(Microsoft.CodeAnalysis.Project,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.PortableExecutableReference})">
            <summary>
            Returns the set of PEReferences in the solution that are not currently being referenced
            by this project.  The set returned will be tuples containing the PEReference, and the project-id
            for the project we found the pe-reference in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.IsInPackagesDirectory(Microsoft.CodeAnalysis.PortableExecutableReference)">
             <summary>
             We ignore references that are in a directory that contains the names
             "Packages", "packs", "NuGetFallbackFolder", or "NuGetPackages"
             These directories are most likely the ones produced by NuGet, and we don't want
             to offer to add .dll reference manually for dlls that are part of NuGet packages.
             
             Note that this is only a heuristic (though a good one), and we should remove this
             when we can get an API from NuGet that tells us if a reference is actually provided
             by a nuget packages.
             Tracking issue: https://github.com/dotnet/project-system/issues/5275
             
             This heuristic will do the right thing in practically all cases for all. It 
             prevents the very unpleasant experience of us offering to add a direct metadata 
             reference to something that should only be referenced as a nuget package.
            
             It does mean that if the following is true:
             You have a project that has a non-nuget metadata reference to something in a "packages"
             directory, and you are in another project that uses a type name that would have matched
             an accessible type from that dll. then we will not offer to add that .dll reference to
             that other project.
             
             However, that would be an exceedingly uncommon case that is degraded.  Whereas we're 
             vastly improved in the common case. This is a totally acceptable and desirable outcome
             for such a heuristic.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.CreateCompilation(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.PortableExecutableReference)">
            <summary>
            Called when we want to search a metadata reference.  We create a dummy compilation
            containing just that reference and we search that.  That way we can get actual symbols
            returned.
            
            We don't want to use the project that the reference is actually associated with as 
            getting the compilation for that project may be extremely expensive.  For example,
            in a large solution it may cause us to build an enormous amount of skeleton assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AddImportCodeAction">
            <summary>
            Code action we use when just adding a using, possibly with a project or
            metadata reference.  We don't use the standard code action types because
            we want to do things like show a glyph if this will do more than just add
            an import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AddImportCodeAction.OriginalDocument">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Document"/> we started the add-import analysis in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AddImportCodeAction._textChanges">
            <summary>
            The changes to make to <see cref="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AddImportCodeAction.OriginalDocument"/> to add the import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.InstallPackageAndAddImportCodeAction._installOperation">
            <summary>
            The operation that will actually install the nuget package.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.InstallPackageAndAddImportCodeAction.ComputePreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            For preview purposes we return all the operations in a list.  This way the 
            preview system stiches things together in the UI to make a suitable display.
            i.e. if we have a SolutionChangedOperation and some other operation with a 
            Title, then the UI will show that nicely to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.InstallPackageAndAddImportCodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            However, for application purposes, we end up returning a single operation
            that will then apply all our sub actions in order, stopping the moment
            one of them fails.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ParentInstallPackageCodeAction">
            <summary>
            This is the top level 'Install Nuget Package' code action we show in 
            the lightbulb.  It will have children to 'Install Latest', 
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ParentInstallPackageCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportFixData,Microsoft.CodeAnalysis.Packaging.IPackageInstallerService)">
            <summary>
            Even though we have child actions, we mark ourselves as explicitly non-inlinable.
            We want to the experience of having the top level item the user has to see and
            navigate through, and we don't want our child items confusingly being added to the
            top level light-bulb where it's not clear what effect they would have if invoked.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReferenceCodeAction">
            <summary>
            Code action for adding an import when we find a symbol in source in either our
            starting project, or some other unreferenced project in the solution.  If we 
            find a source symbol in a different project, we'll also add a p2p reference when
            we apply the code action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceCodeAction">
            <summary>
            Code action we use when just adding a using, possibly with a project or
            metadata reference.  We don't use the standard code action types because
            we want to do things like show a glyph if this will do more than just add
            an import.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.MetadataSymbolReference.ShouldAddWithExistingImport(Microsoft.CodeAnalysis.Document)">
            <summary>
            If we're adding a metadata-reference, then we always offer to do the add,
            even if there's an existing source-import in the file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReference">
            <summary>
            Handles references to source symbols both from the current project the user is invoking
            'add-import' from, as well as symbols from other viable projects.
            
            In the case where the reference is from another project we put a glyph in the add using
            light bulb and we say "(from ProjectXXX)" to make it clear that this will do more than
            just add a using/import.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReference.ShouldAddWithExistingImport(Microsoft.CodeAnalysis.Document)">
            <summary>
            If we're adding a reference to another project, it's ok to still add, even if there
            is an existing source-import in the file.  We won't add the import, but we'll still
            add the project-reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.RemoteSymbolSearchService">
            <summary>
            Used to supply the OOP server a callback that it can use to search for ReferenceAssemblies or
            nuget packages.  We can't necessarily do that search directly in the OOP server as our 
            'SymbolSearchEngine' may actually be running in a *different* process (there is no guarantee
            that all remote work happens in the same process).  
            
            This does mean, currently, that when we call over to OOP to do a search, it will bounce
            back to VS, which will then bounce back out to OOP to perform the Nuget/ReferenceAssembly
            portion of the search.  Ideally we could keep this all OOP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AllSymbolsProjectSearchScope">
            <summary>
            SearchScope used for searching *all* the symbols contained within a project/compilation.
            i.e. the symbols created from source *and* symbols from references (both project and
            metadata).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SearchScope">
            <summary>
            SearchScope is used to control where the <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1"/>
            searches.  We search different scopes in different ways.  For example we use 
            SymbolTreeInfos to search unreferenced projects and metadata dlls.  However,
            for the current project we're editing we defer to the compiler to do the 
            search.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SourceSymbolsProjectSearchScope">
            <summary>
            SearchScope used for searching *only* the source symbols contained within a project/compilation.
            i.e. symbols from metadata will not be searched.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingTypesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for types that match the name the user has written.  Returns <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s
            to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s or <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s those types are
            contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingNamespacesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for namespaces that match the name the user has written.  Returns <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s
            to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s those namespaces are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingFieldsAndPropertiesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Specialized finder for the "Color Color" case.  Used when we have "Color.Black" and "Color"
            bound to a Field/Property, but not a type.  In this case, we want to look for namespaces
            containing 'Color' as if we import them it can resolve this issue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingExtensionMethodsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for extension methods that match the name the user has written.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForCollectionInitializerMethodsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for extension methods exactly called 'Add'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForQueryPatternsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for extension methods exactly called 'Select'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForGetAwaiterAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for extension methods exactly called 'GetAwaiter'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForDeconstructAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope)">
            <summary>
            Searches for extension methods exactly called 'Deconstruct'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.TextChanges">
            <summary>
            Text changes to make to the document.  Usually just the import to add.  May also
            include a change to the name node the feature was invoked on to fix the casing of it.
            May be empty for fixes that don't need to add an import and only do something like
            add a project/metadata reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Title">
            <summary>
            String to display in the lightbulb menu.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Tags">
            <summary>
            Tags that control what glyph is displayed in the lightbulb menu.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Priority">
            <summary>
            The priority this item should have in the lightbulb list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.ProjectReferenceToAdd">
            <summary>
            The optional id for a <see cref="T:Microsoft.CodeAnalysis.Project"/> we'd like to add a reference to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceProjectId">
            <summary>
            If we're adding <see cref="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceFilePathToAdd"/> then this
            is the id for the <see cref="T:Microsoft.CodeAnalysis.Project"/> we can find that <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>
            referenced from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceFilePathToAdd">
            <summary>
            If we want to add a <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> metadata reference, this 
            is the <see cref="P:Microsoft.CodeAnalysis.PortableExecutableReference.FilePath"/> for it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Int32,System.Boolean,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)">
            <summary>
            Gets data for how to fix a particular <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> id within the specified Document.
            Useful when you do not have an instance of the diagnostic, such as when invoked as a remote service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetFixesForDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Int32,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)">
            <summary>
            Gets data for how to fix a set of <see cref="T:Microsoft.CodeAnalysis.Diagnostic" />s within the specified Document.
            The fix data can be used to create code actions that apply the fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetCodeActionsForFixes(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AddImport.AddImportFixData},Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,System.Int32)">
            <summary>
            Gets code actions that, when applied, will fix the missing imports for the document using
            the information from the provided fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeActionOperation">
            <summary>
            Operation responsible purely for installing a nuget package with a specific 
            version, or a the latest version of a nuget package.  Is not responsible
            for adding an import to user code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction">
            <summary>
            This is the top level 'Install Nuget Package' code action we show in 
            the lightbulb.  It will have children to 'Install Latest', 
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,System.String,System.String,System.Boolean,Microsoft.CodeAnalysis.Document)">
            <summary>
            Even though we have child actions, we mark ourselves as explicitly non-inlinable.
            We want to the experience of having the top level item the user has to see and
            navigate through, and we don't want our child items confusingly being added to the
            top level light-bulb where it's not clear what effect they would have if invoked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6.TryGetRelevantArgument(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            If the diagnostic is on a argument, the argument is considered to be the argument to fix.
            There are some exceptions to this rule. Returning null indicates that the fixer needs
            to find the relevant argument by itself.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.Method">
            <summary>
            The overload to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.CreateChangedSolutionNonCascading">
            <summary>
            A mandatory fix for the overload without cascading.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.CreateChangedSolutionCascading">
            <summary>
            An optional fix for the overload with cascading.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.IAddParameterService.HasCascadingDeclarations(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if there are indications that there might be more than one declarations that need to be fixed.
            The check does not look-up if there are other declarations (this is done later in the CodeAction).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.IAddParameterService.AddParameterAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.String,System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds a parameter to a method.
            </summary>
            <param name="newParameterIndex"><see langword="null"/> to add as the final parameter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetInvocationSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Determines the symbol on which we are invoking ReorderParameters
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.FindNodeToUpdate(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a SyntaxNode for which we want to reorder parameters/arguments, find the 
            SyntaxNode of a kind where we know how to reorder parameters/arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetParameterIndex``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Int32)">
            <summary>
            Given the cursor position, find which parameter is selected.
            Returns 0 as the default value. Note that the ChangeSignature dialog adjusts the selection for
            the `this` parameter in extension methods (the selected index won't remain 0).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder">
            <summary>
            For ChangeSignature, FAR on a delegate invoke method must cascade to BeginInvoke, 
            cascade through method group conversions, and discover implicit invocations that do not
            mention the string "Invoke" or the delegate type itself. This implementation finds these
            symbols by binding most identifiers and invocation expressions in the solution. 
            </summary>
            <remarks>
            TODO: Rewrite this to track backward through references instead of binding everything
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.DiagnosticSet">
            <summary>
            Indicates which code fixes are enabled for a Code Cleanup operation. Each code fix in the set is triggered by
            one or more diagnostic IDs, which could be provided by the compiler or an analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.EnabledDiagnosticOptions">
            <summary>
            Indicates which features are enabled for a code cleanup operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.OrganizeUsingsSet">
            <summary>
            Indicates which, if any, Organize Usings features are enabled for code cleanup.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions">
            <summary>
            Represents a configuration code action with nested actions registered by individual <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>s.
            Note that the code fix/light bulb engine groups all such <see cref="T:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions"/> from different providers
            into another top level suggested action to avoid light bulb clutter. This topmost suggested action is *not* represented by this code action.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions.AdditionalPriority">
            <summary>
            Additional priority associated with all configuration and suppression code actions.
            This allows special code actions such as Bulk configuration to to be at the end of
            all suppression and configuration actions by having a lower additional priority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection">
            <summary>
            Represents a collection of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>es supplied by a given fix provider
            (such as <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection.FixAllState">
            <summary>
            Optional fix all context, which is non-null if the given <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection.Provider"/> supports fix all occurrences code fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same supplied <paramref name="diagnostic"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same set of supplied <paramref name="diagnostics"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater">
            <summary>
            Helper class to configure diagnostic severity or code style option value based on .editorconfig file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureSeverityAsync(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the severity of the given <paramref name="diagnostic"/> is configured to be the given
            <paramref name="severity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureSeverityAsync(System.String,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the severity of the given <paramref name="diagnostic"/> is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.BulkConfigureSeverityAsync(System.String,System.String,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the default severity of the diagnostics with the given <paramref name="category"/> is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.BulkConfigureSeverityAsync(System.String,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the default severity of all diagnostics is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureCodeStyleOptionAsync(System.String,System.String,System.String,Microsoft.CodeAnalysis.Diagnostic,System.Boolean,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the given <paramref name="optionName"/> is configured to have the given <paramref name="optionValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IAddSolutionItemService.TrackFilePathAndAddSolutionItemWhenFileCreated(System.String)">
            <summary>
            Tracks the given file path of a non-existent file and whenever a new file with this file path is created,
            it adds it as a solution item.
            NOTE: <paramref name="filePath"/> is expected to be an absolute path of a file that does not yet exist.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IAddSolutionItemService.AddSolutionItemAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Adds a file at the given path as a solution item.
            NOTE: <paramref name="filePath"/> is expected to be an absolute path of an existing file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixSomeCodeAction.TestAccessor.ShowPreviewChangesDialog">
            <summary>
            Gets a reference to <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixSomeCodeAction._showPreviewChangesDialog"/>, which can be read or written by test code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixAllGetFixesService.GetFixAllOperationsAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,System.Boolean)">
            <summary>
            Computes the fix all occurrences code fix, brings up the preview changes dialog for the fix and
            returns the code action operations corresponding to the fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixAllGetFixesService.GetFixAllChangedSolutionAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext)">
            <summary>
            Computes the fix all occurrences code fix and returns the changed solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService.GetFix(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllProvider,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Get the fix multiple occurrences code fix for the given diagnostics with source locations.
            NOTE: This method does not apply the fix to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService.GetFix(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllProvider,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Get the fix multiple occurrences code fix for the given diagnostics with source locations.
            NOTE: This method does not apply the fix to the workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProviderFactory">
            <summary>
            CodeFixProvider factory. if an analyzer reference implements this, we call this to get CodeFixProviders
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.IPragmaBasedCodeAction">
            <summary>
            Suppression code action based on pragma add/remove/edit.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaBatchFixHelpers">
            <summary>
            Helper methods for pragma suppression add/remove batch fixers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaHelpers">
            <summary>
            Helper methods for pragma based suppression code actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaWarningBatchFixAllProvider">
            <summary>
            Batch fixer for pragma suppress code action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction">
            <summary>
            Base type for remove suppression code actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.BatchFixer">
            <summary>
            Batch fixer for pragma suppression removal code action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.AttributeRemoveAction">
            <summary>
            Code action to remove suppress message attributes for remove suppression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.PragmaRemoveAction">
            <summary>
            Code action to edit/remove/add the pragma directives for removing diagnostic suppression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute.Languages">
            <summary>
            The source languages this provider can provide fixes for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress">
            <summary>
            Tracks incremental progress of a find references search, we use this to
            count the number of references up until a certain cap is reached and cancel the search
            or until the search completes, if such a cap is not reached.
            </summary>
            <remarks>
            All public methods of this type could be called from multiple threads.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.SearchCap">
            <remarks>
            If the cap is 0, then there is no cap.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.CancellationToken">
            <summary>
            The cancellation token that aggregates the original cancellation token + this progress
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.FilterReference(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation)">
            <summary>
            Exclude the following kind of symbols:
             1. Implicitly declared symbols (such as implicit fields backing properties)
             2. Symbols that can't be referenced by name (such as property getters and setters).
             3. Metadata only symbols, i.e. symbols with no location in source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService.GetDisplayNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the node used for display info
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService.GetDisplayName(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the DisplayName for the given node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.GetReferenceCountAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns the number of locations where the located node is referenced.
            <para>
                Optionally, the service supports capping the reference count to a value specified by <paramref name="maxSearchResults"/>
                if <paramref name="maxSearchResults"/> is greater than 0.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.FindReferenceLocationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns a collection of locations where the located node is referenced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.FindReferenceMethodsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns a collection of locations of methods that refer to the located node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.GetFullyQualifiedNameAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns the fully qualified name of the located node's declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceCount">
            <summary>
            Represents the result of a FindReferences Count operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceCount.Count">
            <summary>
            Represents the number of references to a given symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceCount.IsCapped">
            <summary>
            Represents if the count is capped by a certain maximum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor">
            <summary>
            Holds information required to display and navigate to individual references
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.FilePath">
            <summary>
            Document's file path
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.SpanStart">
            <summary>
            Reference's span start based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.SpanLength">
            <summary>
            Reference's span length based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.LineNumber">
            <summary>
            Reference's line based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ColumnNumber">
            <summary>
            Reference's character based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.Language">
            <summary>
            Language of the reference location
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.LongDescription">
            <summary>
            Fully qualified name of the symbol containing the reference location
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.Glyph">
            <summary>
            The kind of symbol containing the reference location (such as type, method, property, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceLineText">
            <summary>
            the full line of source that contained the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceStart">
            <summary>
            the beginning of the span within reference text that was the use of the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceLength">
            <summary>
            the length of the span of the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.BeforeReferenceText1">
            <summary>
            Text above the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.BeforeReferenceText2">
            <summary>
            Text above the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.AfterReferenceText1">
            <summary>
            Text below the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.AfterReferenceText2">
            <summary>
            Text below the line with the reference
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor">
            <summary>
            A caller method of a callee
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.#ctor(System.String,System.String,System.String)">
            <summary>
            Describe a caller method of a callee
            </summary>
            <param name="fullName">Method's fully qualified name</param>
            <param name="filePath">Method full path</param>
            <remarks>
             Method full name is expected to be in the .NET full name type convention. That is,
             namespace/type is delimited by '.' and nested type is delimited by '+'
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.FullName">
            <summary>
             Returns method's fully quilified name without parameters
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.FilePath">
            <summary>
            Returns method's file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.OutputFilePath">
            <summary>
            Returns output file path for the project containing the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactoringHelpers.IsNodeUnderselected(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            <para>
            Determines if a <paramref name="node"/> is underselected given <paramref name="selection"/>.
            </para>
            <para>
            Underselection is defined as omitting whole nodes from either the beginning or the end. It can be used e.g. to detect that
            following selection `1 + [|2 + 3|]` is underselecting the whole expression node tree.
            </para>
            <para>
            Returns false if only and precisely one <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is selected. In that case the <paramref name="selection"/> 
            is treated more as a caret location.
            </para>
            <para>
            It's intended to be used in conjunction with <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService.GetRelevantNodesAsync``1(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)"/>
            that, for non-empty selections, returns the smallest encompassing node. A node that can, for certain refactorings, be too large given user-selection even though
            it is the smallest that can be retrieved.
            </para>
            <para>
            When <paramref name="selection"/> doesn't intersect the node in any way it's not considered to be underselected.
            </para>
            <para>
            Null node is always considered underselected.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactoringHelpers.GetTrimmedTextSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Trims leading and trailing whitespace from <paramref name="span"/>.
            </summary>
            <remarks>
            Returns unchanged <paramref name="span"/> in case <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.IsEmpty"/>.
            Returns empty Span with original <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> in case it contains only whitespace.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3.ExtractNodesSimple(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Extractor function that retrieves all nodes that should be considered for extraction of given current node. 
            <para>
            The rationale is that when user selects e.g. entire local declaration statement [|var a = b;|] it is reasonable
            to provide refactoring for `b` node. Similarly for other types of refactorings.
            </para>
            </summary>
            <remark>
            Should also return given node. 
            </remark>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3.ExtractNodesInHeader(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Extractor function that checks and retrieves all nodes current location is in a header.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1">
             <summary>
             Refactor:
                 var x = GetAsync();
            
             Into:
                 var x = await GetAsync();
            
             Or:
                 var x = await GetAsync().ConfigureAwait(false);
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring">
            <summary>
            Represents a set of transformations that can be applied to a piece of code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring.CodeActions">
            <summary>
            List of tuples of possible actions that can be used to transform the code the TextSpan within the original document they're applicable to.
            </summary>
            <remarks>
            applicableToSpan should represent a logical section within the original document that the action is 
            applicable to. It doesn't have to precisely represent the exact <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> that will get changed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions.RegisterRefactorings``1(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Use this helper to register multiple refactorings (<paramref name="actions"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService.GetRelevantNodesAsync``1(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            <para>
            Returns an array of <typeparamref name="TSyntaxNode"/> instances for refactoring given specified selection in document.
            </para>
            <para>
            A <typeparamref name="TSyntaxNode"/> instance is returned if:
            - Selection is zero-width and inside/touching a Token with direct parent of type <typeparamref name="TSyntaxNode"/>.
            - Selection is zero-width and touching a Token whose ancestor of type <typeparamref name="TSyntaxNode"/> ends/starts precisely on current selection.
            - Selection is zero-width and in whitespace that corresponds to a Token whose direct ancestor is of type of type <typeparamref name="TSyntaxNode"/>.
            - Selection is zero-width and in a header (defined by ISyntaxFacts helpers) of an node of type of type <typeparamref name="TSyntaxNode"/>.
            - Token whose direct parent of type <typeparamref name="TSyntaxNode"/> is selected.
            - Selection is zero-width and wanted node is an expression / argument with selection within such syntax node (arbitrarily deep) on its first line.
            - Whole node of a type <typeparamref name="TSyntaxNode"/> is selected.
            </para>
            <para>
            Attempts extracting a Node of type <typeparamref name="TSyntaxNode"/> for each Node it considers (see above).
            E.g. extracts initializer expressions from declarations and assignments, Property declaration from any header node, etc.
            </para>
            <para>
            Note: this function trims all whitespace from both the beginning and the end of given <paramref name="selection"/>.
            The trimmed version is then used to determine relevant <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>. It also handles incomplete selections
            of tokens gracefully. Over-selection containing leading comments is also handled correctly. 
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService.NamespaceScopeMovedAnnotation">
            <summary>
            Annotation to mark the namespace encapsulating the type that has been moved
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MultipleTopLevelTypeDeclarationInSourceDocument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            checks if there is a single top level type declaration in a document
            </summary>
            <remarks>
            optimized for perf, uses Skip(1).Any() instead of Count() > 1
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.TypeMatchesDocumentName(`1,System.String,System.String,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            checks if type name matches its parent document name, per style rules.
            </summary>
            <remarks>
            Note: For a nested type, a matching document name could be just the type name or a
            dotted qualified name of its type hierarchy.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.Editor">
            <summary>
            An abstract class for different edits performed by the Move Type Code Action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.Editor.GetOperationsAsync">
            <summary>
            Operations performed by CodeAction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.Editor.GetModifiedSolutionAsync">
            <summary>
            Incremental solution edits that correlate to code operations
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.GetModifiedSolutionAsync">
            <summary>
            Given a document and a type contained in it, moves the type
            out to its own document. The new document's name typically
            is the type name, or is at least based on the type name.
            </summary>
            <remarks>
            The algorithm for this, is as follows:
            1. Fork the original document that contains the type to be moved.
            2. Keep the type, required namespace containers and using statements.
               remove everything else from the forked document.
            3. Add this forked document to the solution.
            4. Finally, update the original document and remove the type from it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.AddNewDocumentWithSingleTypeDeclarationAndImportsAsync(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Forks the source document, keeps required type, namespace containers
            and adds it the solution.
            </summary>
            <param name="newDocumentId">id for the new document to be added</param>
            <returns>the new solution which contains a new document with the type being moved</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.AddFinalNewLineIfDesiredAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Add a trailing newline if we don't already have one if that's what the user's 
            preference is.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.RemoveTypeFromSourceDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document)">
            <summary>
            update the original document and remove the type that was moved.
            perform other fix ups as necessary.
            </summary>
            <returns>an updated solution with the original document fixed up as appropriate.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.GetMembersToRemove(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Traverses the syntax tree of the forked document and
            collects a list of nodes that are not being moved.
            This list of nodes are then removed from the forked copy.
            </summary>
            <param name="root">root, of the syntax tree of forked document</param>
            <returns>list of syntax nodes, to be removed from the forked copy.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeEditor.AddPartialModifiersToTypeChain(Microsoft.CodeAnalysis.Editing.DocumentEditor,System.Boolean,System.Boolean)">
            <summary>
            if a nested type is being moved, this ensures its containing type is partial.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.MoveTypeNamespaceScopeEditor">
            <summary>
            Editor that takes a type in a scope and creates a scope beside it. For example, if the type is contained within a namespace 
            it will evaluate if the namespace scope needs to be closed and reopened to create a new scope. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.RenameFileEditor.RenameFileToMatchTypeName">
            <summary>
            Renames the file to match the type contained in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5.RenameTypeEditor.GetModifiedSolutionAsync">
            <summary>
            Renames a type to match its containing file name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.MoveType">
            <summary>
            Moves a type to it's own file
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.MoveTypeNamespaceScope">
            <summary>
            Functionally doesn't change the type symbol, but moves it to it's own
            namespace declaration scope. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.RenameType">
            <summary>
            Renames the target type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.RenameFile">
            <summary>
            Renames the file containing the target type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.TryGetApplicableInvocationNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Try to get the node that can be used to trigger the refactoring based on current cursor position. 
            </summary>
            <returns>
            (1) a node of type <typeparamref name="TNamespaceDeclarationSyntax"/> node, if cursor in the name and it's the 
            only namespace declaration in the document.
            (2) a node of type <typeparamref name="TCompilationUnitSyntax"/> node, if the cursor is in the name of first 
            declaration in global namespace and there's no namespace declaration in this document.
            (3) otherwise, null.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.MoveFileCodeAction.FindCandidateFolders(Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider{`0,`1,`2}.MoveFileCodeAction.FolderInfo,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            We try to provide additional "move file" options if we can find existing folders that matches target namespace.
            For example, if the target namespace is 'DefaultNamesapce.A.B.C', and there's a folder 'ProjectRoot\A.B\' already 
            exists, then will provide two actions, "move file to ProjectRoot\A.B\C\" and "move file to ProjectRoot\A\B\C\".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.Document">
            <summary>
            The document in which the refactoring is triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.Container">
            <summary>
            The applicable container node based on cursor location,
            which will be used to change namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.TargetNamespace">
            <summary>
            This is the new name we want to change the namespace to.
            Empty string means global namespace, whereas null means change namespace action is not available.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.RelativeDeclaredNamespace">
            <summary>
            This is the part of the declared namespace that is contained in default namespace.
            We will use this to construct target folder to move the file to.
            For example, if default namespace is `A` and declared namespace is `A.B.C`, 
            this would be `B.C`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.IsDocumentPathRootedInProjectFolder(Microsoft.CodeAnalysis.Document)">
            <summary>
            Determines if the actual file path matches its logical path in project 
            which is constructed as [project_root_path]\Logical\Folders\. The refactoring 
            is triggered only when the two match. The reason of doing this is we don't really know
            the user's intention of keeping the file path out-of-sync with its logical path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.TryBuildNamespaceFromFolders(Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider{`0,`1,`2},System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Create a qualified identifier as the suffix of namespace based on a list of folder names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.GetRelativeNamespace(System.String,System.String,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Try get the relative namespace for <paramref name="namespace"/> based on <paramref name="relativeTo"/>,
            if <paramref name="relativeTo"/> is the containing namespace of <paramref name="namespace"/>. Otherwise,
            Returns null.
            For example:
            - If <paramref name="relativeTo"/> is "A.B" and <paramref name="namespace"/> is "A.B.C.D", then
            the relative namespace is "C.D".
            - If <paramref name="relativeTo"/> is "A.B" and <paramref name="namespace"/> is also "A.B", then
            the relative namespace is "".
            - If <paramref name="relativeTo"/> is "" then the relative namespace us <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider.#ctor(Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.Dialog.IPullMemberUpOptionsService)">
            <summary>
            Test purpose only
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider.PullMemberUpWithDialogCodeAction._selectedMember">
            <summary>
            Member which user initially selects. It will be selected initially when the dialog pops up.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.TryComputeCodeAction(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Return the CodeAction to pull <paramref name="selectedMember"/> up to destinationType. If the pulling will cause error, it will return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.PullMembersUpAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions,System.Threading.CancellationToken)">
            <summary>
            Return the changed solution if all changes in pullMembersUpOptions are applied.
            </summary>
            <param name="pullMembersUpOptions">Contains the members to pull up and all the fix operations</param>>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.IsSelectedMemberDeclarationAlreadyInDestination(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
             This method is used to check whether the selected member overrides the member in destination.
             It just checks the members directly declared in the destination.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService">
            <summary>
            This intermediate class is used to hide method `TryGetReplacementReferenceSyntax` from <see cref="T:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService.TryGetReplacementReferenceSyntax(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the 
            namespace to be changed. If this reference is the right side of a qualified name, the new node returned would
            be the entire qualified name. Depends on whether <paramref name="newNamespaceParts"/> is provided, the name 
            in the new node might be qualified with this new namespace instead.
            </summary>
            <param name="reference">A reference to a type declared inside the namespace to be changed, which is calculated 
            based on results from `SymbolFinder.FindReferencesAsync`.</param>
            <param name="newNamespaceParts">If specified, the namespace of original reference will be replaced with given 
            namespace in the replacement node.</param>
            <param name="old">The node to be replaced. This might be an ancestor of original </param>
            <param name="new">The replacement node.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.ContainerAnnotation">
            <summary>
            The annotation used to track applicable container in each document to be fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.GetValidContainersFromAllLinkedDocumentsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Decide if we can change the namespace for provided <paramref name="container"/> based on the criteria listed for 
            <see cref="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>
            </summary>
            <returns>
            If namespace can be changed, returns a list of documents that linked to the provided document (including itself)
            and the corresponding container nodes in each document, which will later be used for annotation. Otherwise, a 
            default ImmutableArray is returned. Currently we only support linked document in multi-targeting project scenario.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.AnnotateContainersAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Mark container nodes with our annotation so we can keep track of them across syntax modifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.ChangeNamespaceInSingleDocumentAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Try to change the namespace declaration in the document (specified by <paramref name="id"/> in <paramref name="solution"/>).
            Returns a new solution after changing namespace, and a list of IDs for documents that also changed because they reference
            the types declared in the changed namespace (not include the document contains the declaration itself).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.FixReferencesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService,Microsoft.CodeAnalysis.AddImports.IAddImportsService,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService{`0,`1,`2}.LocationForAffectedSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Threading.CancellationToken)">
            <summary>
            Fix each reference and return a collection of proper containers (innermost container
            with imports) that new import should be added to based on reference locations.
            If <paramref name="newNamespaceParts"/> is specified (not default), the fix would be:
                1. qualify the reference with new namespace and mark it for simplification, or
                2. find and mark the qualified reference for simplification.
            Otherwise, there would be no namespace replacement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3.AddImportsInContainersAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImports.IAddImportsService,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Add imports for the namespace specified by <paramref name="names"/>
            to the provided <paramref name="containers"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
             <summary>
             Determine whether we can change the namespace for given <paramref name="container"/> in the document.
             Linked documents are not supported, except for a regular document in a multi-targeting project, 
             where the container node must be consistent among all linked documents.
             Here's the additional requirements on <paramref name="container"/> to use this service:
             
             - If <paramref name="container"/> is a namespace declaration node:
                1. Doesn't contain or is nested in other namespace declarations
                2. The name of the namespace is valid (i.e. no errors)
                3. No partial type declared in the namespace. Otherwise its multiple declarations will
                   end up in different namespace.
            
             - If <paramref name="container"/> is a compilation unit node:
                1. It must contain no namespace declaration
                2. No partial type declared in the document. Otherwise its multiple declarations will
                   end up in different namespace.
                   
             - Otherwise, an <see cref="T:System.ArgumentException"/> will be thrown.
               
             Returns <see langword="true"/> only when all the requirements above are met.
             </summary>
             <remarks>
             While this service might be used by features that change namespace based on some property of the document
             (e.g. Sync namespace refactoring), those logic is implemented by those individual features and isn't part 
             of the IChangeNamespaceService service.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.ChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Threading.CancellationToken)">
            <summary>
            Change namespace for given <paramref name="container"/> to the name specified by <paramref name="targetNamespace"/>.
            Everything declared in the <paramref name="container"/> will be moved to the new namespace. 
            Change will only be made if <see cref="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> returns <see langword="true"/> and <paramref name="targetNamespace"/>
            is a valid name for namespace. Use "" for <paramref name="targetNamespace"/> to specify the global namespace.
            
            An <see cref="T:System.ArgumentException"/> will be thrown if:
            1. <paramref name="container"/> is not a namespace declaration or a compilation unit node.
            2. <paramref name="targetNamespace"/> is null or contains an invalid character.
            </summary>
            <remarks>
            If the declared namespace for <paramref name="container"/> is already identical to <paramref name="targetNamespace"/>, then it will be
            a no-op and original solution will be returned.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.DocumentNavigationOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for navigating to a specific position in a document.
            When <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> is called an implementation
            of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> can return an instance of this operation along with the other 
            operations they want to apply.  For example, an implementation could generate a new <see cref="T:Microsoft.CodeAnalysis.Document"/>
            in one <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> and then have the host editor navigate to that
            <see cref="T:Microsoft.CodeAnalysis.Document"/> using this operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2">
            <summary>
            This is the core class a code-style feature needs to derive from.  All logic related to the
            feature will then be contained in this class.  This class will take care of many bit of
            common logic that all code style providers would have to care about and can thus do that
            logic in a consistent fashion without all providers having to do the same.  For example,
            this class will check the current value of the code style option. If it is 'refactoring
            only', it will not bother running any of the DiagnosticAnalyzer codepaths, and will only run
            the CodeRefactoringProvider codepaths.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.AnalysisContext">
             <summary>
             Critically, we want to consolidate the logic about checking if the analyzer should run
             at all.  i.e. if the user has their option set to 'none' or 'refactoring only' then we
             do not want the analyzer to run at all.
            
             To that end, we don't let the subclass have direct access to the real <see
             cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext"/>. Instead, we pass this type to the subclass for it
             register with.  We then check if the registration should proceed given the <see
             cref="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1"/>
             and the current <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> being processed.  If not, we don't do the
             actual registration.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.GetOptionSeverity(Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2{`0})">
            <summary>
            Helper to get the true ReportDiagnostic severity for a given option.  Importantly, this
            handle ReportDiagnostic.Default and will map that back to the appropriate value in that
            case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.ComputeCodeActionsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)">
            <summary>
            Subclasses must implement this method to provide fixes for any diagnostics that this
            type has registered.  If this subclass wants the same code to run for this single
            diagnostic as well as for when running fix-all, then it should call 
            <see cref="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.FixWithSyntaxEditorAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)"/> from its code action.  This will end up calling
            <see cref="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.FixAllAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)"/>, with that single <paramref name="diagnostic"/> in the 
            <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> passed to that method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.FixAllAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)">
            <summary>
            Subclasses should implement this to support fixing all given diagnostics efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.ComputeAllRefactoringsWhenAnalyzerInactiveAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
             <summary>
             Subclasses should implement this to provide their feature as a refactoring.  This will
             be called when the user has the code style set to 'refactoring only' (or if the
             diagnostic is suppressed).
            
             The implementation of this should offer all refactorings it can that are relevant at the
             provided <paramref name="span"/>.  Specifically, because these are just refactorings,
             they should be offered when they would make the code match the desired user preference,
             or even for allowing the user to quickly switch their code to *not* follow their desired
             preference.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2.ComputeOpposingRefactoringsWhenAnalyzerActiveAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,`0,System.Threading.CancellationToken)">
             <summary>
             Subclasses should implement this to provide the refactoring that works in the opposing
             direction of what the option preference is.  This is only called if the user has the
             code style enabled, and has it set to 'info/warning/error'.  In this case it is the
             *analyzer* responsible for making code compliant with the option.
            
             The refactoring then exists to allow the user to update their code to go against that
             option on an individual case by case basis.
            
             For example, if the user had set that they want expression-bodies for methods (at
             warning level), then this would offer 'use block body' on a method that had an
             expression body already.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.Options.IPerLanguageOption,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption"/> code style option.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="option">
            Per-language option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such unique option.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption,System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption"/> code style option for the given language.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="option">
            Language specific option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such unique option.
            </param>
            <param name="language">Language for the given language-specific <paramref name="option"/>.</param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IPerLanguageOption},Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption"/> code style options.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="options">
            Set of two or more per-language options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption"/> code style options for the given language.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="options">
            Set of two or more language-specific options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="language">Language for the given language-specific <paramref name="options"/>.</param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IPerLanguageOption})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with per-language options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.String)">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with language-specific options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IPerLanguageOption},System.String)">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with a mix of language-specific and per-language options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors such that all the descriptors have no unique code style option to configure the descriptors.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleDiagnosticAnalyzer.UnnecessaryWithSuggestionDescriptor">
            <summary>
            Diagnostic descriptor for code you want to fade out *and* want to have a smart-tag
            appear for.  This is the common descriptor for code that is being faded out
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleDiagnosticAnalyzer.UnnecessaryWithoutSuggestionDescriptor">
            <summary>
            Diagnostic descriptor for code you want to fade out and do *not* want to have a smart-tag
            appear for.  This is uncommon but useful in some cases.  For example, if you are fading
            out pieces of code before/after another piece of code *on the same line*, then you will
            only want one usage of <see cref="F:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleDiagnosticAnalyzer.UnnecessaryWithSuggestionDescriptor"/> and multiple
            usages of <see cref="F:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleDiagnosticAnalyzer.UnnecessaryWithoutSuggestionDescriptor"/>.
            
            That's because if you use <see cref="F:Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleDiagnosticAnalyzer.UnnecessaryWithSuggestionDescriptor"/> for all the
            faded out code then that will mean the user will see multiple code actions to fix the
            same issue when they bring up the code action on that line.  Using these two descriptors
            helps ensure that there will not be useless code-action overload.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaggedText">
            <summary>
            A piece of text with a descriptive tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Tag">
            <summary>
            A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Text">
            <summary>
            The actual text to be displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Style">
            <summary>
            Gets the style(s) to apply to the text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.NavigationTarget">
            <summary>
            Gets the navigation target for the text, or <see langword="null"/> if the text does not have a navigation
            target.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.NavigationHint">
            <summary>
            Gets the navigation hint for the text, or <see langword="null"/> if the text does not have a navigation
            hint.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaggedText.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.TaggedText"/>
            </summary>
            <param name="tag">A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.</param>
            <param name="text">The actual text to be displayed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaggedText.#ctor(System.String,System.String,Microsoft.CodeAnalysis.TaggedTextStyle,System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.TaggedText"/>
            </summary>
            <param name="tag">A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.</param>
            <param name="text">The actual text to be displayed.</param>
            <param name="style">The style(s) to apply to the text.</param>
            <param name="navigationTarget">The navigation target for the text, or <see langword="null"/> if the text does not have a navigation target.</param>
            <param name="navigationHint">The navigation hint for the text, or <see langword="null"/> if the text does not have a navigation hint.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextTags">
            <summary>
            The set of well known text tags used for the <see cref="P:Microsoft.CodeAnalysis.TaggedText.Tag"/> property.
            These tags influence the presentation of text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextTags.ContainerStart">
            <summary>
            Indicates the start of a text container. The elements after <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/> through (but not
            including) the matching <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerEnd"/> are rendered in a rectangular block which is positioned
            as an inline element relative to surrounding elements. The text of the <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/> element
            itself precedes the content of the container, and is typically a bullet or number header for an item in a
            list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextTags.ContainerEnd">
            <summary>
            Indicates the end of a text container. See <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.Id">
            <summary>
            The identity of update group. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.Workspace">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.Workspace"/> this update is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.ProjectId">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.ProjectId"/> this update is associated with, or <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.DocumentId">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.DocumentId"/> this update is associated with, or <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind">
            <summary>
            The kind of character set modification.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Add">
            <summary>
            The rule adds new characters onto the existing set of characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Remove">
            <summary>
            The rule removes characters from the existing set of characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Replace">
            <summary>
            The rule replaces the existing set of characters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule">
            <summary>
            A rule that modifies a set of characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Kind">
            <summary>
            The kind of modification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Characters">
            <summary>
            One or more characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Create(Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind,System.Collections.Immutable.ImmutableArray{System.Char})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule"/> instance.
            </summary>
            <param name="kind">The kind of rule.</param>
            <param name="characters">One or more characters. These are typically punctuation characters.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Create(Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind,System.Char[])">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule"/> instance.
            </summary>
            <param name="kind">The kind of rule.</param>
            <param name="characters">One or more characters. These are typically punctuation characters.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionChange">
            <summary>
            The change to be applied to the document when a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange">
            <summary>
            The text change to be applied to the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.NewPosition">
            <summary>
            The new caret position after the change has been applied.
            If null then the new caret position will be determined by the completion host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.IncludesCommitCharacter">
            <summary>
            True if the changes include the typed character that caused the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>
            to be committed.  If false the completion host will determine if and where the commit 
            character is inserted into the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> instance.
            </summary>
            <param name="textChanges">The text changes to be applied to the document.</param>
            <param name="newPosition">The new caret position after the change has been applied. 
            If null then the caret position is not specified and will be determined by the completion host.</param>
            <param name="includesCommitCharacter">True if the changes include the typed character that caused the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> to be committed.
            If false, the completion host will determine if and where the commit character is inserted into the document.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithTextChanges(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithNewPosition(System.Nullable{System.Int32})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.NewPosition"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithIncludesCommitCharacter(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.IncludesCommitCharacter"/> property changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionContext">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> when providing completions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Document">
            <summary>
            The document that completion was invoked within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Position">
            <summary>
            The caret position when completion was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.DefaultItemSpan">
            <summary>
            The span of the syntax element at the caret position.
            
            This is the most common value used for <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> and will
            be automatically assigned to any <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that has no <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CompletionListSpan">
            <summary>
            The span of the document the completion list corresponds to.  It will be set initially to
            the result of <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDefaultCompletionListSpan(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)"/>, but it can
            be overwritten during <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)"/>.  The purpose
            of the span is to:
                1. Signify where the completions should be presented.
                2. Designate any existing text in the document that should be used for filtering.
                3. Specify, by default, what portion of the text should be replaced when a completion 
                   item is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Trigger">
            <summary>
            The triggering action that caused completion to be started.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Options">
            <summary>
            The options that completion was started with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CancellationToken">
            <summary>
            The cancellation token to use for this operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.IsExclusive">
            <summary>
            Set to true if the items added here should be the only items presented to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.ExpandItemsAvailable">
            <summary>
            Set to true if the corresponding provider can provide extended items with current context,
            regardless of whether those items are actually added. i.e. it might be disabled by default,
            but we still want to show the expander so user can explicitly request them to be added to 
            completion list if we are in the appropriate context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionContext.#ctor(Microsoft.CodeAnalysis.Completion.CompletionProvider,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionContext"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.SuggestionModeItem">
            <summary>
            An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.
            
            Suggestion mode disables auto-selection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.
            
            Specifying a <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionContext.SuggestionModeItem"/> is a request that the completion host operate in suggestion mode.
            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.
            
            No text is ever inserted when this item is completed, leaving the text the user typed instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionDescription">
            <summary>
            The description of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionDescription.Empty">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> used when there is no description.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.TaggedParts">
            <summary>
            The individual tagged parts of the description.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> with the specified <see cref="T:Microsoft.CodeAnalysis.TaggedText"/> parts.
            </summary>
            <param name="taggedParts">The individual tagged parts of the description.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.FromText(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> from untagged text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.WithTaggedParts(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.TaggedParts"/> property changed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.Text">
            <summary>
            The text of the description without tags.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionHelper.MatchesPattern(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns true if the completion item matches the pattern so far.  Returns 'true'
            iff the completion item matches and should be included in the filtered completion
            results, or false if it should not be.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionHelper.CompareItems(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem,System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns true if item1 is a better completion item than item2 given the provided filter
            text, or false if it is not better.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionItem">
            <summary>
            One of many possible completions used to form the completion list presented to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText">
            <summary>
            The text that is displayed to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextPrefix">
            <summary>
            An optional prefix to be displayed prepended to <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>. Can be null.
            Pattern-matching of user input will not be performed against this, but only against <see
            cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextSuffix">
            <summary>
            An optional suffix to be displayed appended to <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>. Can be null.
            Pattern-matching of user input will not be performed against this, but only against <see
            cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText">
            <summary>
            The text used to determine if the item matches the filter and is show in the list.
            This is often the same as <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> but may be different in certain circumstances.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.SortText">
            <summary>
            The text used to determine the order that the item appears in the list.
            This is often the same as the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> but may be different in certain circumstances.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.InlineDescription">
            <summary>
            Descriptive text to place after <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> in the display layer.  Should
            be short as it will show up in the UI.  Display will present this in a way to distinguish
            this from the normal text (for example, by fading out and right-aligning).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span">
            <summary>
            The span of the syntax element associated with this item.
            
            The span identifies the text in the document that is used to filter the initial list presented to the user,
            and typically represents the region of the document that will be changed if this item is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Properties">
            <summary>
            Additional information attached to a completion item by it creator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Rules">
            <summary>
            Rules that declare how this item should behave.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.ProviderName">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> that created this 
            <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>. Not available to clients. Only used by 
            the Completion subsystem itself for things like getting description text
            and making additional change during commit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.AutomationText">
            <summary>
            The automation text to use when narrating the completion item. If set to
            null, narration will use the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.Completion.CompletionItemRules)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>
            </summary>
            <param name="displayText">The text that is displayed to the user.</param>
            <param name="filterText">The text used to determine if the item matches the filter and is show in the list.</param>
            <param name="sortText">The text used to determine the order that the item appears in the list.</param>
            <param name="span">The span of the syntax element in the document associated with this item.</param>
            <param name="properties">Additional information.</param>
            <param name="tags">Descriptive tags that may influence how the item is displayed.</param>
            <param name="rules">The rules that declare how this item should behave.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayTextPrefix(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextPrefix"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayTextSuffix(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextSuffix"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithFilterText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithSortText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.SortText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithProperties(System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Properties"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.AddProperty(System.String,System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with a property added to the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Properties"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithTags(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.AddTag(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with a tag added to the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithRules(Microsoft.CodeAnalysis.Completion.CompletionItemRules)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Rules"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemFlags.Cached">
             <summary>
             Indicates this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> is cached and reused across completion sessions. 
             This might be used by completion system for things like deciding whether it can safely cache and reuse
             other data corresponding to this item.
            
             TODO: Revisit the approach we used for caching VS items.
                   https://github.com/dotnet/roslyn/issues/35160
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemFlags.Expanded">
            <summary>
            Indicates this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> should be shown only when expanded items is requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior.SoftSelection">
            <summary>
            If no text has been typed, the item should be soft selected. This is appropriate for 
            completion providers that want to provide suggestions that shouldn't interfere with 
            typing.  For example a provider that comes up on space might offer items that are soft
            selected so that an additional space (or other puntuation character) will not then 
            commit that item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior.HardSelection">
            <summary>
            If no text has been typed, the item should be hard selected.  This is appropriate for
            completion providers that are providing suggestions the user is nearly certain to 
            select.  Because the item is hard selected, any commit characters typed after it will
            cause it to be committed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules">
            <summary>
            Rules for how the individual items are handled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Default">
            <summary>
            The rule used when no rule is specified when constructing a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FilterCharacterRules">
            <summary>
            Rules that modify the set of characters that can be typed to filter the list of completion items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.CommitCharacterRules">
            <summary>
            Rules that modify the set of characters that can be typed to cause the selected item to be committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.EnterKeyRule">
            <summary>
            A rule about whether the enter key is passed through to the editor after the selected item has been committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FormatOnCommit">
            <summary>
            True if the modified text should be formatted automatically.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.MatchPriority">
            <summary>
            True if the related completion item should be initially selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.SelectionBehavior">
            <summary>
            How this item should be selected when the completion list first appears and
            before the user has typed any characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="matchPriority">True if the related completion item should be initially selected.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Nullable{System.Int32},Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="matchPriority">True if the related completion item should be initially selected.</param>
            <param name="selectionBehavior">How this item should be selected if no text has been typed after the completion list is brought up.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance--internal for TypeScript.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="preselect">True if the related completion item should be initially selected.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithFilterCharacterRules(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FilterCharacterRules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithCommitCharacterRules(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.CommitCharacterRules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithEnterKeyRule(Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.EnterKeyRule"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithFormatOnCommit(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FormatOnCommit"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithMatchPriority(System.Int32)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.MatchPriority"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithSelectionBehavior(Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.SelectionBehavior"/> property changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionList">
            <summary>
            The set of completions to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Items">
            <summary>
            The completion items to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.DefaultSpan">
            <summary>
            The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> was created.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> spans may vary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Span">
            <summary>
            The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> 
            was created.
            
            The span identifies the text in the document that is used to filter the initial list 
            presented to the user, and typically represents the region of the document that will 
            be changed if this item is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Rules">
            <summary>
            The rules used to control behavior of the completion list shown to the user during typing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem">
            <summary>
            An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.
            Suggestion mode disables autoselection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.
            Specifying a <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem"/> is a request that the completion host operate in suggestion mode.
            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.
            No text is ever inserted when this item is completed, leaving the text the user typed instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.Create(Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem},Microsoft.CodeAnalysis.Completion.CompletionRules,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> instance.
            </summary>
            <param name="defaultSpan">The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> was created.</param>
            <param name="items">The completion items to present to the user.</param>
            <param name="rules">The rules used to control behavior of the completion list shown to the user during typing.</param>
            <param name="suggestionModeItem">An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithDefaultSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.DefaultSpan"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithItems(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.Items"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithRules(Microsoft.CodeAnalysis.Completion.CompletionRules)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.Rules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithSuggestionModeItem(Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionList.Empty">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> returned when no items are found to populate the list.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionProvider">
            <summary>
            Implement a subtype of this class and export it to provide completions during typing in an editor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.ProvideCompletionsAsync(Microsoft.CodeAnalysis.Completion.CompletionContext)">
            <summary>
            Implement to contribute <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>'s and other details to a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="text">The text that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The triggering action.</param>
            <param name="options">The set of options in effect.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsSyntacticTriggerCharacterAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            This allows Completion Providers that indicated they were triggered textually to use syntax to
            confirm they are really triggered, or decide they are not actually triggered and should become 
            an augmenting provider instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Threading.CancellationToken)">
            <summary>
            Gets the description of the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)">
            <summary>
            Gets the change to be applied when the specified item is committed.
            </summary>
            <param name="document">The current document.</param>
            <param name="item">The item to be committed.</param>
            <param name="commitKey">The optional key character that caused the commit.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsSnippetProvider">
            <summary>
            True if the provider produces snippet items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsExpandItemProvider">
            <summary>
            True if the provider produces items show be shown in expanded list only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractEmbeddedLanguageCompletionProvider">
            <summary>
            The singular completion provider that will hook into completion and will
            provider all completions across all embedded languages.
            
            Completions for an individual language are provided by
            <see cref="P:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.IEmbeddedLanguageFeatures.CompletionProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectCreationCompletionProvider.GetObjectCreationNewExpression(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Return null if not in object creation type context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.ShouldIncludeInTargetTypedCompletionList(Microsoft.CodeAnalysis.ISymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},Microsoft.CodeAnalysis.SemanticModel,System.Int32,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean})">
            <param name="typeConvertibilityCache">A cache to use for repeated lookups. This should be created with <see cref="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.Default"/>
            because we ignore nullability.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.CreateItems(Microsoft.CodeAnalysis.Completion.CompletionContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},System.Func{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.List{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Generic.List{Microsoft.CodeAnalysis.ProjectId},System.Boolean,System.Lazy{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol}},Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.TelemetryCounter)">
            <summary>
            Given a list of symbols, and a mapping from each symbol to its original SemanticModel, 
            creates the list of completion items for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.CreateItem(Microsoft.CodeAnalysis.Completion.CompletionContext,System.String,System.String,System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.List{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Generic.List{Microsoft.CodeAnalysis.ProjectId},System.Boolean)">
            <summary>
            Given a Symbol, creates the completion item for it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.ShouldProvidePreselectedItemsAsync(Microsoft.CodeAnalysis.Completion.CompletionContext,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,Microsoft.CodeAnalysis.Document,System.Int32,System.Lazy{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol}},Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            The decision for whether to provide preselected items can be contextual, e.g. based on trigger character and syntax location
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.FindSymbolsMissingInLinkedContexts(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext},System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol}}})">
            <summary>
            Given a list of symbols, determine which are not recommended at the same position in linked documents.
            </summary>
            <param name="symbolToContext">The symbols recommended in the active context.</param>
            <param name="linkedContextSymbolLists">The symbols recommended in linked documents</param>
            <returns>The list of projects each recommended symbol did NOT appear in.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider.GetInsertionText(Microsoft.CodeAnalysis.Completion.CompletionItem,System.Char)">
            <summary>
            Override this if you want to provide customized insertion based on the character typed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService.GetCacheForProjectAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get appropriate completion items for all the visible top level types from given project. 
            This method is intended to be used for getting types from source only, so the project must support compilation. 
            For getting types from PE, use <see cref="M:Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService.TryGetCacheForPEReference(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.PortableExecutableReference,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Boolean,System.Threading.CancellationToken,System.Nullable{Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService.GetCacheResult}@)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService.TryGetCacheForPEReference(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.PortableExecutableReference,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Boolean,System.Threading.CancellationToken,System.Nullable{Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService.GetCacheResult}@)">
            <summary>
            Get appropriate completion items for all the visible top level types from given PE reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.ITypeImportCompletionService.GetAllTopLevelTypesAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get completion items for all the accessible top level types from the given project and all its references. 
            Each array returned contains all items from one of the reachable entities (i.e. projects and PE references.)
            Returns null if we don't have all the items cached and <paramref name="forceCacheCreation"/> is false.
            </summary>
            <remarks>
            Because items from each entity are cached as a separate array, we simply return them as is instead of an 
            aggregated array to avoid unnecessary allocations.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper">
            <summary>
            Provides completion items for extension methods from unimported namespace.
            </summary>
            <remarks>It runs out-of-proc if it's enabled</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.CacheEntry.SimpleExtensionMethodInfo">
            <summary>
            Mapping from the name of target type to extension method symbol infos.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.CacheServiceFactory">
            <summary>
            We don't use PE cache from the service, so just pass in type `object` for PE entries.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionRules">
            <summary>
            Presentation and behavior rules for completion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfEmpty">
            <summary>
            True if the completion list should be dismissed if the user's typing causes it to filter
            and display no items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfLastCharacterDeleted">
            <summary>
            True if the list should be dismissed when the user deletes the last character in the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultCommitCharacters">
            <summary>
            The default set of typed characters that cause the selected item to be committed.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>s can override this.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultEnterKeyRule">
            <summary>
            The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>s can override this.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.SnippetsRule">
            <summary>
            The rule determining how snippets work.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.Create(System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Char},Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> instance.
            </summary>
            <param name="dismissIfEmpty">True if the completion list should be dismissed if the user's typing causes it to filter and display no items.</param>
            <param name="dismissIfLastCharacterDeleted">True if the list should be dismissed when the user deletes the last character in the span.</param>
            <param name="defaultCommitCharacters">The default set of typed characters that cause the selected item to be committed.</param>
            <param name="defaultEnterKeyRule">The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.Create(System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Char},Microsoft.CodeAnalysis.Completion.EnterKeyRule,Microsoft.CodeAnalysis.Completion.SnippetsRule)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> instance.
            </summary>
            <param name="dismissIfEmpty">True if the completion list should be dismissed if the user's typing causes it to filter and display no items.</param>
            <param name="dismissIfLastCharacterDeleted">True if the list should be dismissed when the user deletes the last character in the span.</param>
            <param name="defaultCommitCharacters">The default set of typed characters that cause the selected item to be committed.</param>
            <param name="defaultEnterKeyRule">The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="snippetsRule">The rule that controls snippets behavior.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDismissIfEmpty(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfEmpty"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDismissIfLastCharacterDeleted(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfLastCharacterDeleted"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDefaultCommitCharacters(System.Collections.Immutable.ImmutableArray{System.Char})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultCommitCharacters"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDefaultEnterKeyRule(Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultEnterKeyRule"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithSnippetsRule(Microsoft.CodeAnalysis.Completion.SnippetsRule)">
            <summary>
            Creates a copy of the this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.SnippetsRule"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionRules.Default">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> if none is otherwise specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionService">
            <summary>
            A per language service for constructing context dependent list of completions that 
            can be presented to a user during typing in an editor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the service corresponding to the specified document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionService.Language">
            <summary>
            The language from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> this service corresponds to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetRules">
            <summary>
            Gets the current presentation and behavior rules.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="text">The document text to trigger completion within </param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The potential triggering action.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <param name="options">Optional options that override the default options.</param>
            <remarks>
            This API uses SourceText instead of Document so implementations can only be based on text, not syntax or semantics.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDefaultItemSpan(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Gets the span of the syntax element at the caret position.
            This is the most common value used for <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/>.
            </summary>
            <param name="text">The document text that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret within the text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Gets the completions available at the caret position.
            </summary>
            <param name="document">The document that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The triggering action.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <param name="options">Optional options that override the default options.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsInternalAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Gets the completions available at the caret position, with additional info indicates 
            whether expander items are available.
            </summary>
            <remarks>
            expandItemsAvailable is true when expanded items are returned or can be provided upon request.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Threading.CancellationToken)">
            <summary>
            Gets the description of the item.
            </summary>
            <param name="document">This will be the  original document that
            <paramref name="item"/> was created against.</param>
            <param name="item">The item to get the description for.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)">
            <summary>
            Gets the change to be applied when the item is committed.
            </summary>
            <param name="document">The document that completion is occurring within.</param>
            <param name="item">The item to get the change for.</param>
            <param name="commitCharacter">The typed character that caused the item to be committed. 
            This character may be used as part of the change. 
            This value is null when the commit was caused by the [TAB] or [ENTER] keys.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Text.TextSpan,System.Nullable{System.Char},System.Threading.CancellationToken)">
             <summary>
             Preferred overload of <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)"/>.
            
             This overload is passed the value of <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CompletionListSpan"/>
             which should be used to determine what span should be updated in the original <paramref
             name="document"/> passed in.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.FilterItems(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem},System.String)">
            <summary>
            Given a list of completion items that match the current code typed by the user,
            returns the item that is considered the best match, and whether or not that
            item should be selected or not.
            
            itemToFilterText provides the values that each individual completion item should
            be filtered against.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionServiceOptions.IsExpandedCompletion">
            <summary>
            Indicates if the completion is trigger by toggle the expander.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders">
            <summary>
            A subtype of <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionService"/> that aggregates completions from one or more <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.GetBuiltInProviders">
            <summary>
            Returns the providers always available to the service.
            This does not included providers imported via MEF composition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.ItemsMatch(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Determines if the items are similar enough they should be represented by a single item in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders.GetBetterItem(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Determines which of two items should represent the matching pair.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTags">
            <summary>
            The set of well known tags used for the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> property.
            These tags influence the presentation of items in the list.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger">
            <summary>
            The action that triggered completion to start.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Kind">
            <summary>
            The reason that completion was started.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Character">
            <summary>
            The character associated with the triggering action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Default">
            <summary>
            Do not use.  Use <see cref="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Invoke"/> instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Invoke">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> when none is specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionTrigger.CreateInsertionTrigger(System.Char)">
            <summary>
            Creates a new instance of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> association with the insertion of a typed character into the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionTrigger.CreateDeletionTrigger(System.Char)">
            <summary>
            Creates a new instance of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> association with the deletion of a character from the document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind">
            <summary>
            The kind of action that triggered completion to start.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Other">
            <summary>
            Completion was triggered via some other mechanism.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Invoke">
            <summary>
            Completion was trigger by a direct invocation of the completion feature 
            (ctrl-j in Visual Studio).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Insertion">
            <summary>
            Completion was triggered via an action inserting a character into the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Deletion">
            <summary>
            Completion was triggered via an action deleting a character from the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Snippets">
            <summary>
            Completion was triggered for snippets only.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.InvokeAndCommitIfUnique">
            <summary>
            Completion was triggered with a request to commit if a unique item would be selected 
            (ctrl-space in Visual Studio).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.EnterKeyRule">
            <summary>
            Determines whether the enter key is passed through to the editor after it has been used to commit a completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.Never">
            <summary>
            The enter key is never passed through to the editor after it has been used to commit the completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.Always">
            <summary>
            The enter key is always passed through to the editor after it has been used to commit the completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.AfterFullyTypedWord">
            <summary>
            The enter is key only passed through to the editor if the completion item has been fully typed out.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.ExportCompletionProviderAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionService"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.LSPCompletionProvider.TriggerCharacters">
            <summary>
            Defines the set of possible non-identifier trigger characters for this completion provider.
            Used by the LSP server to determine the trigger character set for completion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.MatchPriority">
            <summary>
            An additional hint to the matching algorithm that can
            augment or override the existing text-based matching.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchPriority.Default">
            <summary>
            The matching algorithm should give this item no special treatment.
            
            Ordinary <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/>s typically specify this.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchPriority.Preselect">
             <summary>
             The matching algorithm will tend to prefer this item unless
             a dramatically better text-based match is available.
             
             With no filter text, this item (or the first item alphabetically 
             with this priority) should always be selected.
            
             This is used for specific IDE scenarios like "Object creation preselection"
             or "Enum preselection" or "Completion list tag preselection".
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.Default">
            <summary>
            Snippet triggering follows the default rules of the language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.NeverInclude">
            <summary>
            Snippets are never included in the completion list
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.AlwaysInclude">
            <summary>
            Snippets are always included in the completion list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.IncludeAfterTypingIdentifierQuestionTab">
            <summary>
            Snippets are included if the user types: id?&lt;tab&gt;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2.IsSupported(Microsoft.CodeAnalysis.ILocalSymbol,Microsoft.CodeAnalysis.Operations.IForEachLoopOperation,`1)">
            <summary>
            Perform language specific checks if the conversion is supported.
            C#: Currently nothing blocking a conversion
            VB: Nested foreach loops sharing a single Next statement, Next statements with multiple variables and next statements
            not using the loop variable are not supported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchSection">
            <summary>
            Represents a switch-section constructed from a series of
            if-conditions, possibly combined with logical-or operator
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchLabel">
            <summary>
            Represents a switch-label constructed from a series of
            if-conditions, possibly combined by logical-and operator
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern">
            <summary>
            Base class to represents a case clause (pattern) constructed from various checks
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Type">
            <summary>
            Represents a type-pattern, constructed from is-expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Source">
            <summary>
            Represents a source-pattern constructed from C# patterns
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Constant">
            <summary>
            Represents a constant-pattern constructed from an equality check
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Relational">
            <summary>
            Represents a relational-pattern constructed from comparison operators
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Range">
            <summary>
            Represents a range-pattern constructed from a couple of comparison operators
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer._switchTargetExpression">
            <summary>
            Holds the expression determined to be used as the target expression of the switch
            </summary>
            <remarks>
            Note that this is initially unset until we find a non-constant expression.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.None">
            <summary>
            None of operands were constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.Left">
            <summary>
            Signifies that the left operand is the constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.Right">
            <summary>
            Signifies that the right operand is the constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.None">
            <summary>
            Not a range bound.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.Lower">
            <summary>
            Signifies that the lower-bound of a range pattern
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.Higher">
            <summary>
            Signifies that the higher-bound of a range pattern
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.Flip(Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)">
            <summary>
            Changes the direction the operator is pointing
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2.DocumentUpdateInfo">
            <summary>
            Handles information about updating the document with the refactoring.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2.DocumentUpdateInfo.UpdateRoot(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Updates the root of the document with the document update.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.CreateForEachInfo(`0,Microsoft.CodeAnalysis.SemanticModel,System.Boolean)">
            <summary>
            Parses the forEachStatement until a child node cannot be converted into a query clause.
            </summary>
            <param name="forEachStatement"></param>
            <returns>
            1) extended nodes that can be converted into clauses
            2) identifiers introduced in nodes that can be converted
            3) statements that cannot be converted into clauses
            4) trailing comments to be added to the end
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.TryBuildSpecificConverter(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{`0,`1},Microsoft.CodeAnalysis.SemanticModel,`1,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter{`0,`1}@)">
            <summary>
            Tries to build a specific converter that covers e.g. Count, ToList, yield return or other similar cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.CreateDefaultConverter(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{`0,`1})">
            <summary>
            Creates a default converter where foreach is joined with some children statements but other children statements are kept unmodified.
            Example:
            foreach(...)
            {
                if (condition)
                {
                   doSomething();
                }
            }
            is converted to
            foreach(... where condition)
            {
                   doSomething(); 
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.TryBuildConverter(`0,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter{`0,`1}@)">
            <summary>
            Tries to build either a specific or a default converter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1">
            <summary>
            Code refactoring that converts expressions of the form:  a + b + " str " + d + e
            into:
                $"{a + b} str {d}{e}".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate.Document">
            <summary>
            The document to update.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate.NodesToUpdate">
            <summary>
            The subnodes in this document to walk and update.  If empty, the entire document
            should be walked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver.IsApplicable(Microsoft.CodeAnalysis.ISymbol,System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Is this method or property a valid place to set a breakpoint and does it match the expected parameter count?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider">
            <summary>
            An abstraction of a symbol reader that provides a reader of Edit and Continue debug information.
            Owns the underlying PDB reader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateEditAndContinueMethodDebugInfoReader">
            <summary>
            Creates EnC debug information reader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateFromStream(System.IO.Stream)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/> from a stream of Portable or Windows PDB.
            </summary>
            <returns>
            Provider instance, which keeps the <paramref name="stream"/> open until disposed.
            </returns>
            <remarks>
            Requires Microsoft.DiaSymReader.Native.{platform}.dll to be available for reading Windows PDB.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error reading debug information from <paramref name="stream"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateFromMetadataReader(System.Reflection.Metadata.MetadataReaderProvider)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/> from a Portable PDB metadata reader provider.
            </summary>
            <returns>
            Provider instance, which takes ownership of the <paramref name="metadataProvider"/> until disposed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataProvider"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService.GetDataTipInfoAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Find an appropriate span to pass the debugger given a point in a snapshot.  Optionally
            pass back a string to pass to the debugger instead if no good span can be found.  For
            example, if the user hovers on "var" then we actually want to pass the fully qualified
            name of the type that 'var' binds to, to the debugger.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.SourceHashAlgorithms">
            <summary>
            Hash algorithms supported by the debugger used for source file checksums stored in the PDB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants">
            <summary>
            Constants for producing and consuming streams of binary custom debug info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder.ToArray">
            <exception cref="T:System.InvalidOperationException">More than <see cref="F:System.Byte.MaxValue"/> records added.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind">
            <summary>
            The kinds of custom debug info that we know how to interpret.
            The values correspond to possible values of the "kind" byte
            in the record header.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.UsingGroups">
            <summary>
            C# only. Encodes the sizes of using groups that are applicable to the method.
            The actual import strings are stored separately trhu ISymUnmanagedWriter.UsingNamespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardMethodInfo">
            <summary>
            C# only. Indicates that per-method debug information (import strings) is stored on another method, 
            whose token is specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardModuleInfo">
            <summary>
            C# only. Indicates that per-module debug information (assembly reference aliases) is stored on another method, 
            whose token is specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineHoistedLocalScopes">
            <summary>
            C# only. Specifies local scopes for state machine hoisted local variables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineTypeName">
            <summary>
            C# and VB. The name of the state machine type. Emitted for async and iterator kick-off methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.DynamicLocals">
            <summary>
            C# only. Dynamic flags for local variables and constants.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLocalSlotMap">
            <summary>
            C# and VB. Encodes EnC local variable slot map.
            See https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLambdaMap">
            <summary>
            C# and VB. Encodes EnC lambda map.
            See https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.TupleElementNames">
            <summary>
            C# and VB. Tuple element names for local variables and constants.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader">
            <summary>
            A collection of utility method for consuming custom debug info from a PDB.
            </summary>
            <remarks>
            This is not a public API, so we're just going to let bad offsets fail on their own.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)">
            <summary>
            This is the first header in the custom debug info blob.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadRecordHeader(System.Byte[],System.Int32@,System.Byte@,Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind@,System.Int32@,System.Int32@)">
            <summary>
            After the global header (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)"/> comes list of custom debug info record.
            Each record begins with a standard header.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryGetCustomDebugInfoRecord(System.Byte[],Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind)">
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCustomDebugInfoRecords(System.Byte[])">
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            For each namespace declaration enclosing a method (innermost-to-outermost), there is a count
            of the number of imports in that declaration.
            </summary>
            <remarks>
            There's always at least one entry (for the global namespace).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when multiple method would otherwise have identical using records (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})"/>).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardToModuleRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when there are extern aliases and edit-and-continue is disabled.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeStateMachineHoistedLocalScopesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Scopes of state machine hoisted local variables.
            </summary>
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardIteratorRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Indicates that this method is the iterator state machine for the method named in the record.
            </summary>
            <remarks>
            Appears when are iterator methods.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeDynamicLocalsRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Does for locals what System.Runtime.CompilerServices.DynamicAttribute does for parameters, return types, and fields.
            In particular, indicates which occurrences of <see cref="T:System.Object"/> in the signature are really dynamic.
            </summary>
            <remarks>
            Appears when there are dynamic locals.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Bad data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeTupleElementNamesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Tuple element names for locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadRawRecordBody(System.Byte[],System.Int32@,System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Returns the raw bytes of a record.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.SkipRecord(System.Byte[],System.Int32@,System.Int32)">
            <summary>
            Skips past a record.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCSharpGroupedImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Byte[]},System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}},System.Collections.Immutable.ImmutableArray{System.String}@)">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            For each namespace enclosing the method, a list of import strings, innermost to outermost.
            There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetVisualBasicImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}})">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            A list of import strings.  There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseCSharpImportString(System.String,System.String@,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@)">
            <summary>
            Parse a string representing a C# using (or extern alias) directive.
            </summary>
            <remarks>
            <![CDATA[
            For C#:
             "USystem" -> <namespace name="System" />
             "AS USystem" -> <alias name="S" target="System" kind="namespace" />
             "AC TSystem.Console" -> <alias name="C" target="System.Console" kind="type" />
             "AS ESystem alias" -> <alias name="S" qualifier="alias" target="System" kind="type" />
             "XOldLib" -> <extern alias="OldLib" />
             "ZOldLib assembly" -> <externinfo name="OldLib" assembly="assembly" />
             "ESystem alias" -> <namespace qualifier="alias" name="System" />
             "TSystem.Math" -> <type name="System.Math" />
            ]]>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseVisualBasicImportString(System.String,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@,Microsoft.CodeAnalysis.Debugging.VBImportScopeKind@)">
            <summary>
            Parse a string representing a VB import statement.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="import"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Format of <paramref name="import"/> is not valid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadUtf8String(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Read UTF8 string with null terminator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Namespace">
            <summary>
            C# or VB namespace import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Type">
            <summary>
            C# or VB type import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.NamespaceOrType">
            <summary>
            VB namespace or type alias target (not specified).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Assembly">
            <summary>
            C# extern alias.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.XmlNamespace">
            <summary>
            VB XML import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.MethodToken">
            <summary>
            VB forwarding information (i.e. another method has the imports for this one).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.CurrentNamespace">
            <summary>
            VB containing namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.DefaultNamespace">
            <summary>
            VB root namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Defunct">
            <summary>
            A kind that is no longer used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.EndOffset">
            <summary>
            The offset of the first operation outside of the scope, or the method body length.
            If zero then <see cref="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset"/> is also zero and the slot represents a synthesized local.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AbstractHostDiagnosticUpdateSource">
            <summary>
            Diagnostic update source for reporting workspace host specific diagnostics,
            which may not be related to any given project/document in the solution.
            For example, these include diagnostics generated for exceptions from third party analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionSet">
            <summary>
            This class proxies requests for option values first to the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions" /> then to a backup <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> if provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper.CreateAnalyzerExceptionDiagnostic(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Exception)">
            <summary>
            Create a diagnostic for exception thrown by the given analyzer.
            </summary>
            <remarks>
            Keep this method in sync with "AnalyzerExecutor.CreateAnalyzerExceptionDiagnostic".
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper.ComputeDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,System.Func{Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.ISkippedAnalyzersInfo},System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Return all local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer) by calculating them
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper.CollectCompilationActionsContext">
            <summary>
            Right now, there is no API compiler will tell us whether DiagnosticAnalyzer has compilation end analysis or not
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer">
            <summary>
            IDE-only document based diagnostic analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <summary>
            it is not allowed one to implement both DocumentDiagnosticAnalzyer and DiagnosticAnalyzer
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer.Priority">
            <summary>
            This lets vsix installed <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer"/> to
            specify priority of the analyzer. Regular <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> always comes before those 2 different types.
            Priority is ascending order and this only works on HostDiagnosticAnalyzer meaning Vsix installed analyzers in VS.
            This is to support partner teams (such as typescript and F#) who want to order their analyzer's execution order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.FileContentLoadAnalyzer">
            <summary>
            A dummy singleton analyzer. Its only purpose is to represent file content load failures in maps that are keyed by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer">
            <summary>
            IDE-only project based diagnostic analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <summary>
            it is not allowed one to implement both ProjectDiagnosticAnalzyer and DiagnosticAnalyzer
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer.Priority">
            <summary>
            This lets vsix installed <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer"/> to
            specify priority of the analyzer. Regular <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> always comes before those 2 different types.
            Priority is ascending order and this only works on HostDiagnosticAnalyzer meaning Vsix installed analyzers in VS.
            This is to support partner teams (such as typescript and F#) who want to order their analyzer's execution order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerUpdateArgsId">
            <summary>
            Base type of a type that is used as <see cref="P:Microsoft.CodeAnalysis.Common.UpdatedEventArgs.Id"/> for live diagnostic
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.BuildToolId">
            <summary>
            Support ErrorSource information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DefaultDiagnosticAnalyzerService.DefaultDiagnosticIncrementalAnalyzer.GetDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics for the given document.
            
            This is a simple API to get all diagnostics for the given document.
            
            The intended audience for this API is for ones that pefer simplicity over performance such as document that belong to misc project.
            this doesn't cache nor use cache for anything. it will re-caculate new diagnostics every time for the given document.
            it will not persist any data on disk nor use OOP to calcuate the data.
            
            This should never be used when performance is a big concern. for such context, use much complex API from IDiagnosticAnalyzerService
            that provide all kinds of knobs/cache/persistency/OOP to get better perf over simplicity.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache">
            <summary>
            Provides and caches information about diagnostic analyzers such as <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/>, 
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> instance, <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>s.
            Thread-safe.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache._descriptorsInfo">
            <summary>
            Supported descriptors of each <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>. 
            </summary>
            <remarks>
            Holds on <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> instances weakly so that we don't keep analyzers coming from package references alive.
            They need to be released when the project stops referencing the analyzer.
            
            The purpose of this map is to avoid multiple calls to <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> that might return different values
            (they should not but we need a guarantee to function correctly).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache._skippedAnalyzersInfo">
            <summary>
            Information about host analyzers that can be skipped for the given project analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.GetDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> of given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.IsTelemetryCollectionAllowed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Determine whether collection of telemetry is allowed for given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.IsAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Project)">
            <summary>
            Return true if the given <paramref name="analyzer"/> is suppressed for the given project.
            NOTE: This API is intended to be used only for performance optimization.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.SynchronizeWithBuildAsync(Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData}})">
            <summary>
            Synchronize build errors with live error.
            
            no cancellationToken since this can't be cancelled
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticArguments">
            <summary>
            helper type to package diagnostic arguments to pass around between remote hosts
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticEventTaskScheduler">
            <summary>
            This task scheduler will block queuing new tasks if upper bound has met.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind.DiagnosticsRemoved">
            <summary>
            Called when the diagnostic analyzer engine decides to remove existing diagnostics.
            For example, this can happen when a document is removed from a solution.  In that
            case the analyzer engine will delete all diagnostics associated with that document.
            Any layers caching diagnostics should listen for these events to know when to 
            delete their cached items entirely.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind.DiagnosticsCreated">
            <summary>
            Called when a new set of (possibly empty) diagnostics have been produced.  This
            happens through normal editing and processing of files as diagnostic analyzers
            produce new diagnostics for documents and projects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer">
            <summary>
            Diagnostic Analyzer Engine V2
            
            This one follows pattern compiler has set for diagnostic analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ActiveFileState">
            <summary>
            state that is responsible to hold onto local diagnostics data regarding active/opened files (depends on host)
            in memory.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData">
            <summary>
            Simple data holder for local diagnostics for an analyzer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.Version">
            <summary>
            Version of the diagnostic data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.Items">
            <summary>
            Current data that matches the version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.OldItems">
            <summary>
            Last set of data we broadcasted to outer world, or <see langword="default"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData">
            <summary>
            Data holder for all diagnostics for a project for an analyzer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.ProjectId">
            <summary>
            ProjectId of this data
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.Version">
            <summary>
            Version of the Items
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.Result">
            <summary>
            Current data that matches the version
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.OldResult">
            <summary>
            When present, holds onto last data we broadcasted to outer world.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetOrCreateCompilationWithAnalyzersAsync(Microsoft.CodeAnalysis.Project,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},System.Threading.CancellationToken)">
            <summary>
            Return CompilationWithAnalyzer for given project with given stateSets
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetDocumentAnalysisDataAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,System.Threading.CancellationToken)">
            <summary>
            Return all local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer) either from cache or by calculating them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetProjectAnalysisDataAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,Microsoft.CodeAnalysis.Project,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics that belong to given project for the given StateSets (analyzers) either from cache or by calculating them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ComputeDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Calculate all diagnostics for a given project using analyzers referenced by the project and specified IDE analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalyzerReferenceChangedEventArgs">
            <summary>
            EventArgs for <see cref="E:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.ProjectAnalyzerReferenceChanged"/>
            
            this event args contains information such as <see cref="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalyzerReferenceChangedEventArgs.Project"/> the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> has changed
            and what <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> has changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState">
            <summary>
            State for diagnostics that belong to a project at given time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetAnalysisDataAsync(Microsoft.CodeAnalysis.Host.IPersistentStorageService,Microsoft.CodeAnalysis.Project,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics for the given project stored in this state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetAnalysisDataAsync(Microsoft.CodeAnalysis.Host.IPersistentStorageService,Microsoft.CodeAnalysis.Document,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics for the given document stored in this state including non local diagnostics for this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetProjectAnalysisDataAsync(Microsoft.CodeAnalysis.Host.IPersistentStorageService,Microsoft.CodeAnalysis.Project,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all no location diagnostics for the given project stored in this state
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager">
            <summary>
            This is in charge of anything related to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager._hostAnalyzerStateMap">
            <summary>
            Analyzers supplied by the host (IDE). These are built-in to the IDE, the compiler, or from an installed IDE extension (VSIX). 
            Maps language name to the analyzers and their state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager._projectAnalyzerStateMap">
            <summary>
            Analyzers referenced by the project via a PackageReference.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.ProjectAnalyzerReferenceChanged">
            <summary>
            This will be raised whenever <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager"/> finds <see cref="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences"/> change
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetAllStateSets">
            <summary>
            Return all <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>. 
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            Difference with <see cref="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.ProjectId)"/> is that 
            this will only return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s that have same language as <paramref name="project"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrUpdateStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>. 
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the <see cref="T:Microsoft.CodeAnalysis.Project"/> and update internal state.
            
            since this has a side-effect, this should never be called concurrently. and incremental analyzer (solution crawler) should guarantee that.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrCreateStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>. 
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            Unlike <see cref="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrUpdateStateSets(Microsoft.CodeAnalysis.Project)"/>, this has no side effect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrCreateStateSet(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the given <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> in the context of <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will not have any side effect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.CreateBuildOnlyProjectStateSet(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s that are added as the given <see cref="T:Microsoft.CodeAnalysis.Project"/>'s AnalyzerReferences.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.CreateProjectStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Creates a new project state sets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.UpdateProjectStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Updates the map to the given project snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet">
            <summary>
            this contains all states regarding a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet.PersistentNames.StateName">
            <summary>
            Get the unique state name for the given analyzer.
            Note that this name is used by the underlying persistence stream of the corresponding <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState"/> to Read/Write diagnostic data into the stream.
            If any two distinct analyzer have the same diagnostic state name, we will end up sharing the persistence stream between them, leading to duplicate/missing/incorrect diagnostic data.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.LatestDiagnosticsForSpanGetter">
            <summary>
            Get diagnostics for given span either by using cache or calculating it on the spot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetStateSetsForFullSolutionAnalysis(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},Microsoft.CodeAnalysis.Project)">
            <summary>
            Return list of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> to be used for full solution analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzerPackage">
            <summary>
            Information on vsix that contains diagnostic analyzers
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._hostAnalyzerReferencesMap">
            <summary>
            Key is <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id"/>.
            
            We use the key to de-duplicate analyzer references if they are referenced from multiple places.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._hostDiagnosticAnalyzersPerLanguageMap">
            <summary>
            Key is the language the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> supports and key for the second map is analyzer reference identity and
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> for that assembly reference.
            
            Entry will be lazily filled in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._lazyHostDiagnosticAnalyzersPerReferenceMap">
            <summary>
            Key is <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id"/>.
            
            Value is set of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> that belong to the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/>.
            
            We populate it lazily. otherwise, we will bring in all analyzers preemptively
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._compilerDiagnosticAnalyzerMap">
            <summary>
            Maps <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> to compiler diagnostic analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.GetHostAnalyzerReferencesMap">
            <summary>
            It returns a map with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id"/> as key and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> as value
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.GetOrCreateHostDiagnosticAnalyzersPerReference(System.String)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="language"/>
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.CreateDiagnosticAnalyzersPerReference(Microsoft.CodeAnalysis.Project)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="project"/> that
            includes both host and project analyzers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.CreateProjectDiagnosticAnalyzersPerReference(Microsoft.CodeAnalysis.Project)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="project"/> that
            has only project analyzers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.GetCompilerDiagnosticAnalyzer(System.String)">
            <summary>
            Return compiler <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> for the given language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService.ComputeDeclarationsInSpan(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.DeclarationInfo},System.Threading.CancellationToken)">
            <summary>
            Computes the <see cref="T:Microsoft.CodeAnalysis.DeclarationInfo"/> for all the declarations whose span overlaps with the given <paramref name="span"/>.
            </summary>
            <param name="model">The semantic model for the document.</param>
            <param name="span">Span to get declarations.</param>
            <param name="getSymbol">Flag indicating whether <see cref="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol"/> should be computed for the returned declaration infos.
            If false, then <see cref="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol"/> is always null.</param>
            <param name="builder">Builder to add computed declarations.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.AnalyzerInfoCache">
            <summary>
            Provides and caches analyzer information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.HostAnalyzers">
            <summary>
            Host analyzer collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.Reanalyze(Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},System.Boolean)">
            <summary>
            Re-analyze given projects and documents
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetSpecificCachedDiagnosticsAsync(Microsoft.CodeAnalysis.Workspace,System.Object,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get specific diagnostics currently stored in the source. returned diagnostic might be out-of-date if solution has changed but analyzer hasn't run for the new solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetCachedDiagnosticsAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics currently stored in the source. returned diagnostic might be out-of-date if solution has changed but analyzer hasn't run for the new solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics for the given solution. all diagnostics returned should be up-to-date with respect to the given solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.ForceAnalyzeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>
            Force computes diagnostics and raises diagnostic events for the given project or solution. all diagnostics returned should be up-to-date with respect to the given project or solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.ContainsDiagnostics(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if given project has any diagnostics
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics of the given diagnostic ids from the given solution. all diagnostics returned should be up-to-date with respect to the given solution.
            Note that for project case, this method returns diagnostics from all project documents as well. Use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetProjectDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Boolean,System.Threading.CancellationToken)"/>
            if you want to fetch only project diagnostics without source locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetProjectDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get project diagnostics (diagnostics with no source location) of the given diagnostic ids from the given solution. all diagnostics returned should be up-to-date with respect to the given solution.
            Note that this method doesn't return any document diagnostics. Use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Boolean,System.Threading.CancellationToken)"/> to also fetch those.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.TryAppendDiagnosticsForSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.List{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData},System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Try to return up to date diagnostics for the given span for the document.
            
             It will return true if it was able to return all up-to-date diagnostics.
              otherwise, false indicating there are some missing diagnostics in the diagnostic list
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Boolean,System.Func{System.String,System.IDisposable},System.Threading.CancellationToken)">
             <summary>
             Return up to date diagnostics for the given span for the document
            
             This can be expensive since it is force analyzing diagnostics if it doesn't have up-to-date one yet.
             If diagnosticIdOpt is not null, it gets diagnostics only for this given diagnosticIdOpt value
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.IsCompilationEndAnalyzer(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Check whether given <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> is compilation end analyzer
            By compilation end analyzer, it means compilation end analysis here
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService">
            <summary>
            Aggregates events from various diagnostic sources.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.DiagnosticsUpdated">
            <summary>
            Event to get notified as new diagnostics are discovered by IDiagnosticUpdateSource
            
            Notifications for this event are serialized to preserve order.
            However, individual event notifications may occur on any thread.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.GetDiagnostics(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Object,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get current diagnostics stored in IDiagnosticUpdateSource
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.GetDiagnosticsUpdatedEventArgs(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Get current UpdatedEventArgs stored in IDiagnosticUpdateSource
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource">
            <summary>
            Implement this to participate in diagnostic service framework as one of diagnostic update source
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.DiagnosticsUpdated">
            <summary>
            Raise this when new diagnostics are found
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.DiagnosticsCleared">
            <summary>
            Raise this when all diagnostics reported from this update source has cleared
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.SupportGetDiagnostics">
            <summary>
            Return true if the source supports GetDiagnostics API otherwise, return false so that the engine can cache data from DiagnosticsUpdated in memory
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.GetDiagnostics(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Object,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics stored in the source
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSourceRegistrationService">
            <summary>
            A service that let people to register new IDiagnosticUpdateSource
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSourceRegistrationService.Register(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource)">
            <summary>
            Register new IDiagnosticUpdateSource
            
            Currently, it doesn't support unregister since our event is asynchronous and unregistering source that deal with asynchronous event is not straight forward.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IHostDiagnosticAnalyzerPackageProvider.GetHostDiagnosticAnalyzerPackages">
            <summary>
            Gets the analyzers shared across the entire workspace session.
            This includes the analyzers included through VSIX installations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IHostDiagnosticAnalyzerPackageProvider.GetAnalyzerAssemblyLoader">
            <summary>
            Gets the loader for VSIX based analyzer assemblies.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ISupportLiveUpdate">
            <summary>
            Marker interface to indicate whether given diagnostic args are from live analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo">
            <summary>
            Information about analyzers supplied by the host (IDE), which can be completely skipped or its diagnostics partially filtered for the corresponding project
            as project analyzer reference (from NuGet) has equivalent analyzer(s) reporting all or subset of diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo.SkippedAnalyzers">
            <summary>
            Analyzers supplied by the host (IDE), which can be completely skipped for the corresponding project
            as project analyzer reference has equivalent analyzer(s) reporting all diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo.FilteredDiagnosticIdsForAnalyzers">
            <summary>
            Analyzer to diagnostic ID map, such that the diagnostics of those IDs reported by the analyzer should be filtered
            for a correspndiong project.
            This includes the analyzers supplied by the host (IDE), such that project's analyzer references (from NuGet)
            has equivalent analyzer(s) reporting subset of diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions">
            <summary>
            Analyzer options with workspace.
            These are used to fetch the workspace options by our internal analyzers (e.g. simplification analyzer).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticCustomTags.s_microsoftCustomTags">
            <summary>
            it is string[] because DiagnosticDescriptor expects string[]. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{System.Int32}},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="tagIndices">
            a map of location tag to index in additional locations.
            "AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer" for an example of usage.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithMessage(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},Microsoft.CodeAnalysis.LocalizableString)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="message">Localizable message for the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds.FileHeaderMismatch">
            <summary>
            Reported when a file header is missing or does not match the expected string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper">
            <summary>
            Helper type to map <see cref="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds"/> to an unique editorconfig code style option, if any,
            such that diagnostic's severity can be configured in .editorconfig with an entry such as:
                "%option_name% = %option_value%:%severity%
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindMemberDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Finds a member declaration node containing given active statement node.
            </summary>
            <remarks>
            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.
            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetDeclarationBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            If the specified node represents a member declaration returns a node that represents its body,
            i.e. a node used as the root of statement-level match.
            </summary>
            <param name="node">A node representing a declaration or a top-level edit node.</param>
            <param name="isMember">
            True if <paramref name="isMember"/> represents a member declaration,
            false if it represents an edit node.</param>
            <returns>
            Returns null for nodes that don't represent declarations.
            </returns>
            <remarks>
            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.
            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.
            
            If a member doesn't have a body (null is returned) it can't have associated active statements.
            
            Body does not need to cover all active statements that may be associated with the member. 
            E.g. Body of a C# constructor is the method body block. Active statements may be placed on the base constructor call.
                 Body if a VB field declaration with shared AsNew initializer is the New expression. Active statements might be placed on the field variables.
            <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindStatementAndPartner(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,System.Int32@)"/> has to account for such cases.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetDeclarationBodyEdit(Microsoft.CodeAnalysis.Differencing.Edit{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind},Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Interprets an edit as a declaration body edit.
            </summary>
            <param name="edit">A top-level edit.</param>
            <param name="editMap">All top-level edits by syntax node.</param>
            <param name="oldBody">The old body participating in the edit.</param>
            <param name="newBody">The new body participating in the edit.</param>
            <returns>
            True if the specified edit is a declaration body edit, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetActiveTokens(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If the specified node represents a member declaration returns all tokens of the member declaration
            that might be covered by an active statement.
            </summary>
            <returns>
            Tokens covering all possible breakpoint spans associated with the member, 
            or null if the specified node doesn't represent a member declaration or 
            doesn't have a body that can contain active statements.
            </returns>
            <remarks>
            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.
            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetEncompassingAncestor(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns an ancestor that encompasses all active and statement level 
            nodes that belong to the member represented by <paramref name="bodyOrMatchRoot"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindStatementAndPartner(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,System.Int32@)">
            <summary>
            Finds a statement at given span and a declaration body.
            Also returns the corresponding partner statement in <paramref name="partnerDeclarationBody"/>, if specified.
            </summary>
            <remarks>
            The declaration body node may not contain the <paramref name="span"/>. 
            This happens when an active statement associated with the member is outside of its body (e.g. C# constructor).
            If the position doesn't correspond to any statement uses the start of the <paramref name="declarationBody"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindPartner(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Maps <paramref name="leftNode"/> descendant of <paramref name="leftRoot"/> to corresponding descendant node
            of <paramref name="rightRoot"/>, assuming that the trees only differ in trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindEnclosingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns a node that represents a body of a lambda containing specified <paramref name="node"/>,
            or null if the node isn't contained in a lambda. If a node is returned it must uniquely represent the lambda,
            i.e. be no two distinct nodes may represent the same lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetLambdaBodyExpressionsAndStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns all nodes of the body in a syntax list.
            </summary>
            <remarks>
            Note that VB lambda bodies are represented by a lambda header and that some lambda bodies share 
            their parent nodes with other bodies (e.g. join clause expressions).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryMatchActiveStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Matches old active statement to new active statement without constructing full method body match.
            This is needed for active statements that are outside of method body, like constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetActiveSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Get the active span that corresponds to specified node (or its part).
            </summary>
            <returns>
            True if the node has an active span associated with it, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.EnumerateNearStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Yields potential active statements around the specified active statement
            starting with siblings following the statement, then preceding the statement, follows with its parent, its following siblings, etc.
            </summary>
            <returns>
            Pairs of (node, statement part), or (node, -1) indicating there is no logical following statement.
            The enumeration continues until the root is reached.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.StateMachineSuspensionPointKindEquals(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if both nodes represent the same kind of suspension point 
            (await expression, await foreach statement, await using declarator, yield return, yield break).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AreEquivalentActiveStatements(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Returns true if the code emitted for the old active statement part (<paramref name="statementPart"/> of <paramref name="oldStatement"/>) 
            is the same as the code emitted for the corresponding new active statement part (<paramref name="statementPart"/> of <paramref name="newStatement"/>). 
            </summary>
            <remarks>
            A rude edit is reported if an active statement is changed and this method returns true.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetCapturedVariables(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyzes data flow in the member body represented by the specified node and returns all captured variables and parameters (including "this").
            If the body is a field/property initializer analyzes the initializer expression only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetVariableUseSites(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Enumerates all use sites of a specified variable within the specified syntax subtrees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetBodyDisplayName(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind)">
            <summary>
            Returns the display name of an ancestor node that contains the specified node and has a display name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsNestedFunction(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if the node represents any form of a function definition nested in another function body (i.e. anonymous function, lambda, local function).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.HasParameterClosureScope(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the parameters of the symbol are lifted into a scope that is different from the symbol's body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Returns all lambda bodies of a node representing a lambda, 
            or false if the node doesn't represent a lambda.
            </summary>
            <remarks>
            C# anonymous function expression and VB lambda expression both have a single body
            (in VB the body is the header of the lambda expression).
            
            Some lambda queries (group by, join by) have two bodies.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsDeclarationWithInitializer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Return true if the declaration is a field/property declaration with an initializer. 
            Shall return false for enum members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsConstructorWithMemberInitializers(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Return true if the declaration is a constructor declaration to which field/property initializers are emitted. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.LambdaInfo">
            <summary>
            Information about an active and/or a matched lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ComputeMap(Microsoft.CodeAnalysis.Differencing.Match{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ActiveNode[],System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.LambdaInfo}@,System.Collections.Generic.List{Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnostic})">
            <summary>
            Calculates a syntax map of the entire method body including all lambda bodies it contains (recursively).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetMatchingAncestor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Finds the inner-most ancestor of the specified node that has a matching node in the new tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement">
            <summary>
            Represents an instruction range in the code that contains an active instruction of at least one thread and that is delimited by consecutive sequence points.
            More than one thread can share the same instance of <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Ordinal">
            <summary>
            Ordinal of the active statement within the set of all active statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.PrimaryDocumentOrdinal">
            <summary>
            Ordinal of the active statement within the primary containing document (<see cref="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.PrimaryDocumentId"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.InstructionId">
            <summary>
            The instruction of the active statement that is being executed.
            The executing version of the method might be several generations old.
            E.g. when the thread is executing an exception handling region and hasn't been remapped yet.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Span">
            <summary>
            The current source span.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.DocumentIds">
            <summary>
            Document ids - multiple if the physical file is linked.
            TODO: currently we associate all linked documents to the <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement"/> regardless of whether they belong to a project that matches the AS module.
            https://github.com/dotnet/roslyn/issues/24320
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.ThreadIds">
            <summary>
            Threads that share the instruction. May contain duplicates in case a thread is executing a function recursively.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Flags">
            <summary>
            Aggregated across <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.ThreadIds"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a leaf frame.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsNonLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a non-leaf frame.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo">
            <summary>
            Active statement debug information retrieved from the runtime and the PDB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.InstructionId">
            <summary>
            The instruction of the active statement that is being executed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.DocumentNameOpt">
            <summary>
            Document name as found in the PDB, or null if the debugger can't determine the location of the active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.LinePositionSpan">
            <summary>
            Location of the closest non-hidden sequence point retrieved from the PDB, 
            or default(<see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.LinePositionSpan"/>) if the debugger can't determine the location of the active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.Flags">
            <summary>
            Aggregated across <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.ThreadIds"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo.ThreadIds">
            <summary>
            Threads that share the instruction. May contain duplicates in case a thread is executing a function recursively.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions.Spans">
            <summary>
            Exception region spans corresponding to an active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions.IsActiveStatementCovered">
            <summary>
            True if the active statement is covered by any of the exception region spans.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags.IsLeafFrame">
            <summary>
            At least one of the threads whom this active statement belongs to is in a leaf frame.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags.PartiallyExecuted">
            <summary>
            The statement is partially executed.
            </summary>
            <remarks>
            An active statement is partially executed if the thread is stopped in between two sequence points.
            This may happen when the users steps through the code in disassembly window (stepping over machine instructions),
            when the compiler emits a call to Debugger.Break (VB Stop statement), etc.
            
            Partially executed active statement can't be edited.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags.NonUserCode">
            <summary>
            The statement IL is not in user code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags.MethodUpToDate">
            <summary>
            Indicates that the active statement instruction belongs to the latest version of the containing method.
            If not set, the containing method was updated but the active statement was not remapped yet because the thread 
            has not returned to that instruction yet and was not remapped to the new version.
            </summary>
            <remarks>
            When the debugger asks the CLR for the active statement information it compares ICorDebugFunction.GetVersionNumber()
            and ICorDebugFunction.GetCurrentVersionNumber() to determine the value of this flag.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags.IsNonLeafFrame">
            <summary>
            At least one of the threads whom this active statement belongs to is in a non-leaf frame.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementProvider">
            <summary>
            Provides current active statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap.DocumentMap">
            <summary>
            Groups active statements by document. 
            Multiple documents point to the same set of active statements if they are linked to the same underlying source file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap.InstructionMap">
            <summary>
            Active statements by instruction id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementTextSpan.IsLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a leaf frame.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementTextSpan.IsNonLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a non-leaf frame.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution">
            <summary>
            Encapsulates access to the last committed solution.
            We don't want to expose the solution directly since access to documents must be gated by out-of-sync checks.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync">
            <summary>
            The current document content does not match the content the module was compiled with.
            This document state may change to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.Indeterminate">
            <summary>
            It hasn't been possible to determine whether the current document content does matches the content 
            the module was compiled with due to error while reading the PDB or the source file.
            This document state may change to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly">
            <summary>
            The document is not compiled into the module. It's only included in the project
            to support design-time features such as completion, etc.
            This is a final state. Once a document is in this state it won't switch to a different one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput">
            <summary>
            The current document content matches the content the built module was compiled with.
            This is a final state. Once a document is in this state it won't switch to a different one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._documentState">
            <summary>
            Implements workaround for https://github.com/dotnet/project-system/issues/5457.
            
            When debugging is started we capture the current solution snapshot.
            The documents in this snapshot might not match exactly to those that the compiler used to build the module 
            that's currently loaded into the debuggee. This is because there is no reliable synchronization between
            the (design-time) build and Roslyn workspace. Although Roslyn uses file-watchers to watch for changes in 
            the files on disk, the file-changed events raised by the build might arrive to Roslyn after the debugger
            has attached to the debuggee and EnC service captured the solution.
            
            Ideally, the Project System would notify Roslyn at the end of each build what the content of the source
            files generated by various targets is. Roslyn would then apply these changes to the workspace and 
            the EnC service would capture a solution snapshot that includes these changes.
            
            Since this notification is currently not available we check the current content of source files against
            the corresponding checksums stored in the PDB. Documents for which we have not observed source file content 
            that maches the PDB checksum are considered <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync"/>. 
            
            Some documents in the workspace are added for design-time-only purposes and are not part of the compilation
            from which the assembly is built. These documents won't have a record in the PDB and will be tracked as 
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            
            A document state can only change from <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync"/> to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/>.
            Once a document state is <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>
            it will never change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.OnSourceFileUpdatedAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Captures the content of a file that is about to be overwritten by saving an open document,
            if the document is currently out-of-sync and the content of the file matches the PDB.
            If we didn't capture the content before the save we might never be able to find a document
            snapshot that matches the PDB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.GetDocumentAndStateAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns a document snapshot for given <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> whose content exactly matches
            the source file used to compile the binary currently loaded in the debuggee. Returns null
            if it fails to find a document snapshot whose content hash maches the one recorded in the PDB.
            
            The result is cached and the next lookup uses the cached value, including failures unless <paramref name="reloadOutOfSyncDocument"/> is true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.TryReadSourceFileChecksumFromPdb(System.String,Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{System.Byte}@,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm@)">
            <summary>
            Returns true if the PDB contains a document record for given <paramref name="sourceFilePath"/>,
            in which case <paramref name="checksum"/> and <paramref name="algorithm"/> contain its checksum.
            False if the document is not found in the PDB.
            Null if it can't be determined because the PDB is not available or an error occurred while reading the PDB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfoCache">
            <summary>
            A cache of metadata blobs loaded into processes being debugged.
            Thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfoCache.GetOrAdd(System.Guid,System.Func{System.Guid,Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfo})">
            <summary>
            May return null if the provider returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfoCache.Remove(System.Guid)">
            <summary>
            Removes metadata of specified module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession">
            <summary>
            Represents a debugging session.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._projectModuleIds">
            <summary>
            MVIDs read from the assembly built for given project id.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._projectEmitBaselines">
            <summary>
            The current baseline for given project id.
            The baseline is updated when changes are committed at the end of edit session.
            The backing module readers of some baselines need to be kept alive -- store them in 
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._lazyBaselineModuleReaders"/> and dispose them at the end of the debugging session
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.LastCommittedSolution">
            <summary>
            The solution captured when the debugging session entered run mode (application debugging started),
            or the solution which the last changes committed to the debuggee at the end of edit session were calculated from.
            The solution reflecting the current state of the modules loaded in the debugee.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.GetProjectModuleIdAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>
            Reads the MVID of a compiled project.
            </summary>
            <returns>
            An MVID and an error message to report, in case an IO exception occurred while reading the binary.
            The MVID is default if either project not built, or an it can't be read from the module binary.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.GetOrCreateEmitBaseline(Microsoft.CodeAnalysis.ProjectId,System.Guid)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> for given project.
            Must be called on MTA thread.
            </summary>
            <returns>Null if the module corresponding to he project hasn't been loaded yet</returns>
            <exception cref="T:System.IO.IOException">Error reading project's binary.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ActiveStatements">
            <summary>
            Spans of active statements in the document, or null if the document has syntax errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.RudeEditErrors">
            <summary>
            Diagnostics for rude edits in the document, or empty if the document is unchanged or has syntax errors.
            If the compilation has semantic errors only syntactic rude edits are calculated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.SemanticEdits">
            <summary>
            Edits made in the document, or null if the document is unchanged, has syntax errors, has rude edits,
            or if the compilation has semantic errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ExceptionRegions">
             <summary>
             Exception regions -- spans of catch and finally handlers that surround the active statements.
             
             Null if the document has syntax errors or rude edits, or if the compilation has semantic errors.
             </summary>
             <remarks>
             Null if there are any rude edit diagnostics.
             
             Otherwise, each active statement in <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ActiveStatements"/> has a corresponding slot in <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ExceptionRegions"/>.
            
             Exception regions for each EH block/clause are marked as |...|.
               try { ... AS ... } |catch { } finally { }|
               try { } |catch { ... AS ... }| finally { }
               try { } catch { } |finally { ... AS ... }|
             
             Contains a minimal set of spans that cover the handlers.
             For example:
               try { } |finally { try { ... AS ... } catch {  } }|
               try { } |finally { try { } catch { ... AS ... } }|
               try { try { } |finally { ... AS ... }| } |catch { } catch { } finally { }|
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.LineEdits">
            <summary>
            Line edits in the document, or null if the document has syntax errors or rude edits, 
            or if the compilation has semantic errors.
            </summary>
            <remarks>
            Sorted by <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.LineChange.OldLine"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults._hasCompilationErrors">
            <summary>
            The compilation has compilation errors (syntactic or semantic), 
            or null if the document doesn't have any modifications and
            presence of compilation errors was not determined.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource.SupportGetDiagnostics">
            <summary>
            This implementation reports diagnostics via <see cref="E:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource.DiagnosticsUpdated"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource.ClearDiagnostics">
            <summary>
            Clears all diagnostics reported thru this source.
            We do not track the particular reported diagnostics here since we can just clear all of them at once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource.ReportDiagnostics(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Reports given set of diagnostics. 
            Categorizes diagnostic into two groups - diagnostics associated with a document and diagnostics associated with a project or solution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader">
            <summary>
            Reader of debug information needed for EnC.
            This object does not own the underlying memory (SymReader/MetadataReader).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.TryGetDocumentChecksum(System.String,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Guid@)">
            <summary>
            Reads document checksum.
            </summary>
            <returns>True if a document with given path is listed in the PDB.</returns>
            <exception cref="T:System.Exception">Error reading debug information from the PDB.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Portable.TryGetCustomDebugInformation(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Guid,System.Reflection.Metadata.CustomDebugInformation@)">
            <exception cref="T:System.BadImageFormatException">Invalid data format.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Create(Microsoft.DiaSymReader.ISymUnmanagedReader5,System.Int32)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader"/> backed by a given <see cref="T:Microsoft.DiaSymReader.ISymUnmanagedReader5"/>.
            </summary>
            <param name="symReader">SymReader open on a Portable or Windows PDB.</param>
            <param name="version">The version of the PDB to read.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="symReader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="version"/> is less than 1.</exception>
            <exception cref="T:System.Runtime.InteropServices.COMException">Error reading debug information.</exception>
            <returns>
            The resulting reader does not take ownership of the <paramref name="symReader"/> or the memory it reads.
            </returns>
            <remarks>
            Automatically detects the underlying PDB format and returns the appropriate reader.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Create(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader"/> back by a given <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            </summary>
            <param name="pdbReader"><see cref="T:System.Reflection.Metadata.MetadataReader"/> open on a Portable PDB.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pdbReader"/> is null.</exception>
            <returns>
            The resulting reader does not take ownership of the <paramref name="pdbReader"/> or the memory it reads.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService">
            <summary>
            Implements core of Edit and Continue orchestration: management of edit sessions and connecting EnC related services.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService._documentsWithReportedDiagnosticsDuringRunMode">
            <summary>
            A document id is added whenever a diagnostic is reported while in run mode.
            These diagnostics are cleared as soon as we enter break mode or the debugging session terminates.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService.HasChangesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Determine whether the updates made to projects containing the specified file (or all projects that are built, 
            if <paramref name="sourceFilePath"/> is null) are ready to be applied and the debugger should attempt to apply
            them on "continue".
            </summary>
            <returns>
            Returns <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus.Blocked"/> if there are rude edits or other errors 
            that block the application of the updates. Might return <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus.Ready"/> even if there are 
            errors in the code that will block the application of the updates. E.g. emit diagnostics can't be determined until 
            emit is actually performed. Therefore, this method only serves as an optimization to avoid unnecessary emit attempts,
            but does not provide a definitive answer. Only <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService.EmitSolutionUpdateAsync(System.Threading.CancellationToken)"/> can definitively determine whether
            the update is valid or not.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService.IsActiveStatementInExceptionRegionAsync(Microsoft.CodeAnalysis.EditAndContinue.ActiveInstructionId,System.Threading.CancellationToken)">
            <summary>
            Called by the debugger to determine whether an active statement is in an exception region,
            so it can determine whether the active statement can be remapped. This only happens when the EnC is about to apply changes.
            If the debugger determines we can remap active statements, the application of changes proceeds.
            </summary>
            <returns>
            True if the instruction is located within an exception region, false if it is not, null if the instruction isn't an active statement 
            or the exception regions can't be determined.
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession.BaseActiveStatements">
            <summary>
            Lazily calculated map of base active statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession._lazyBaseActiveExceptionRegions">
            <summary>
            For each base active statement the exception regions around that statement. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession._analyses">
            <summary>
            Results of changed documents analysis. 
            The work is triggered by an incremental analyzer on idle or explicitly when "continue" operation is executed.
            Contains analyses of the latest observed document versions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession._documentsWithReportedDiagnostics">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> is added whenever <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticAnalyzer"/> reports 
            rude edits or module diagnostics. At the end of the session we ask the diagnostic analyzer to reanalyze 
            the documents to clean up the diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.GetModuleDiagnosticsAsync(System.Guid,System.String,System.Threading.CancellationToken)">
            <summary>
            Errors to be reported when a project is updated but the corresponding module does not support EnC.
            </summary>
            <returns><see langword="default"/> if the module is not loaded.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.GetBaseActiveExceptionRegionsAsync(System.Threading.CancellationToken)">
            <summary>
            Calculates exception regions for all active statements.
            If an active statement is in a document that's out-of-sync returns default(<see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions"/>) for that statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.GetDocumentAnalysisNoLock(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document)">
            <summary>
            Returns a document analysis or kicks off a new one if one is not available for the specified document snapshot.
            </summary>
            <param name="baseDocument">Base document or null if the document did not exist in the baseline.</param>
            <param name="document">Document snapshot to analyze.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.HasChangesAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Threading.CancellationToken)">
            <summary>
            Determines whether projects contain any changes that might need to be applied.
            Checks only projects containing a given <paramref name="sourceFilePath"/> or all projects of the solution if <paramref name="sourceFilePath"/> is null.
            Invoked by the debugger on every step. It is critical for stepping performance that this method returns as fast as possible in absence of changes.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementTrackingService.TrackingSpansChanged">
            <summary>
            Triggered when tracking spans have changed.
            </summary>
            <remarks>
            The argument is true if the leaf active statement may have changed. 
            It might be true even if it didn't, but it's not false if it does.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementTrackingService.UpdateActiveStatementSpans(Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.ValueTuple{Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementId,Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementTextSpan}})">
            <summary>
            Replaces the existing tracking spans with specified active statement spans.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.IDebuggeeModuleMetadataProvider">
            <summary>
            Provides metadata of modules loaded into processes being debugged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IDebuggeeModuleMetadataProvider.TryGetBaselineModuleInfo(System.Guid)">
            <summary>
            Finds a module of given MVID in one of the processes being debugged and returns its baseline metadata and symbols.
            Shall only be called while in debug mode.
            Shall only be called on MTA thread.
            </summary>
            <returns>Null, if the module with the specified MVID is not loaded.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IDebuggeeModuleMetadataProvider.GetEncAvailabilityAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Checks whether EnC is allowed for all loaded instances of module with specified <paramref name="mvid"/>.
            </summary>
            <returns>
            Returns <see langword="null"/> if no instance of the module is loaded.
            Returns <code>(0, null)</code> if all loaded instances allow EnC.
            Returns error code and a corresponding localized error message otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IDebuggeeModuleMetadataProvider.PrepareModuleForUpdateAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Notifies the debugger that a document changed that may affect the given module when the change is applied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.LineChange.OldLine">
            <summary>
            Zero-based line number.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.LineChange.NewLine">
            <summary>
            Zero-based line number.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.Span">
            <summary>
            Pre-remap span.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.LineDelta">
            <summary>
            Difference between new span and pre-remap span (new = old + delta).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.IsExceptionRegion">
            <summary>
            True if the region represents an exception region, false if it represents an active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.NoChanges">
            <summary>
            Project hasn't been changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.CompilationErrors">
            <summary>
            Project contains syntactic and/or semantic errors.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.RudeEdits">
            <summary>
            Project contains rude edits.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.ValidInsignificantChanges">
            <summary>
            The project only changed in comments, whitespaces, etc. that don't require compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.ValidChanges">
            <summary>
            The project contains valid changes that require application of a delta.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.SemanticEdits">
            <summary>
            All semantic changes made in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.LineChanges">
            <summary>
            All line changes made in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.AddedSymbols">
            <summary>
            All symbols added in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.NewActiveStatements">
            <summary>
            All active statements and the corresponding exception regions in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus.None">
            <summary>
            No updates have been made to the solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus.Ready">
            <summary>
            Solution udpate is ready to be applied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus.Blocked">
            <summary>
            Solution update is blocked. Edit can't be applied due to compiler errors or rude edits.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.TraceLog">
            <summary>
            Fixed size rolling tracing log. 
            </summary>
            <remarks>
            Recent entries are captured in a memory dump.
            If DEBUG is defined, all entries written to <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.TraceLog.DebugWrite(System.String)"/> or
            <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.TraceLog.DebugWrite(System.String,Microsoft.CodeAnalysis.EditAndContinue.TraceLog.Arg[])"/> are print to <see cref="T:System.Diagnostics.Debug"/> output.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper">
            <summary>
            Helper for DisposeAnalysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.IsDisposableCreationOrDisposeOwnershipTransfer(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if the given <paramref name="location"/> was created for an allocation in the <paramref name="containingMethod"/>
            or represents a location created for a constructor parameter whose type indicates dispose ownership transfer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method implements <see cref="M:System.IDisposable.Dispose"/> or overrides an implementation of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.IsAnyDisposeMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if this method is any Dispose method responsible for disposing the disposable fields
            of a disposable named type. For example, "void Dispose()", "void Dispose(bool)", "Task DisposeAsync()", etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.HasDisposeMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose()".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.HasDisposeBoolMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose(bool)".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.HasDisposeCloseMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Close()".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.HasDisposeAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "Task DisposeAsync()".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.HasOverriddenDisposeCoreAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "override Task DisposeCoreAsync(bool)".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DisposeAnalysis.DisposeAnalysisHelper.IsImplementationOfInterfaceMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Checks if the given method is an implementation of the given interface method 
            Substituted with the given typeargument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._listStack">
             <summary>
             Defines the containing lists for the current formatting state. The last item in the list is the
             innermost list.
            
             <list type="bullet">
             <item>
             <term><c>type</c></term>
             <description>The type of list.</description>
             </item>
             <item>
             <term><c>index</c></term>
             <description>The index of the current item in the list.</description>
             </item>
             <item>
             <term><c>renderedItem</c></term>
             <description><see langword="true"/> if the label (a bullet or number) for the current list item has already been rendered; otherwise <see langword="false"/>.</description>
             </item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._navigationTargetStack">
            <summary>
            The top item of the stack indicates the hyperlink to apply to text rendered at the current location. It
            consists of a navigation <c>target</c> (the destination to navigate to when clicked) and a <c>hint</c>
            (typically shown as a tooltip for the link). This stack is never empty; when no hyperlink applies to the
            current scope, the top item of the stack will be a default tuple instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._styleStack">
            <summary>
            Tracks the style for text. The top item of the stack is the current style to apply (the merged result of
            all containing styles). This stack is never empty; when no style applies to the current scope, the top
            item of the stack will be <see cref="F:Microsoft.CodeAnalysis.TaggedTextStyle.None"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState.NextListItem">
            <summary>
            Marks the start of an item in a list; called before each item.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService">
            <summary>
            Note: This is the new version of the language service and superceded the same named type
            in the EditorFeatures layer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentSpan">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> location in a <see cref="P:Microsoft.CodeAnalysis.DocumentSpan.Document"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentSpan.Properties">
            <summary>
            Additional information attached to a document span by it creator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractEmbeddedLanguageFeaturesProvider">
            <summary>
            Abstract implementation of the C# and VB embedded language providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractEmbeddedLanguageFeaturesProvider.EscapeText(System.String,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Escapes <paramref name="text"/> appropriately so it can be inserted into 
            <paramref name="token"/>.  For example if inserting `\p{Number}` into a normal C#
            string token, the `\` would have to be escaped into `\\`.  However in a verbatim-string
            literal (i.e. `@"..."`) it would not have to be escaped.
            </summary>
            <param name="token">The original string token that <paramref name="text"/> is being
            inserted into.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.IEmbeddedLanguageFeatures">
            <summary>
            Services related to a specific embedded language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.IEmbeddedLanguageFeatures.DocumentHighlightsService">
            <summary>
            A optional highlighter that can highlight spans for an embedded language string.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.IEmbeddedLanguageFeatures.CompletionProvider">
            <summary>
            An optional completion provider that can provide completion items for this
            specific embedded language.
            
            <see cref="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractEmbeddedLanguageCompletionProvider"/> will aggregate all these
            individual providers and expose them as one single completion provider to
            the rest of Roslyn.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.AbstractRegexDiagnosticAnalyzer">
            <summary>
            Analyzer that reports diagnostics in strings that we know are regex text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedCompletionProvider.ProvideCompletionsBasedOffOfPrecedingCharacter(Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedCompletionProvider.EmbeddedCompletionContext)">
            <summary>
            Produces completions using the previous character to determine which set of
            regex items to show.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEventName.OrdinaryNameValue">
            <summary>
            Methods, Properties, or Events either have "ordinary" names,
            or explicit interface names. But even explicit names have an
            underlying ordinary name as well. This is just the value for
            ordinary names, or the underlying ordinary name if this is an
            explicit name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.RQName.RQNameInternal">
            <summary>
            Helpers related to <see cref="N:Microsoft.CodeAnalysis.Features.RQName"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.RQName.RQNameInternal.From(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns an RQName for the given symbol, or <see langword="null"/> if the symbol cannot be represented by an RQName.
            </summary>
            <param name="symbol">The symbol to build an RQName for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.RQName.RQNodeBuilder.Build(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Builds the RQName for a given symbol.
            </summary>
            <returns>The node if it could be created, otherwise null</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputFiles.OpenAssemblyStream">
            <summary>
            Opens an assembly file produced by the compiler (corresponds to OutputAssembly build task parameter).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputFiles.OpenPdbStream">
            <summary>
            Opens a PDB file produced by the compiler.
            Returns null if the compiler generated no PDB (the symbols might be embedded in the assembly).
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.CompilationOutputs">
            <summary>
            Reads compilation outputs such as output assembly and PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CompilationOutputs.AssemblyDisplayPath">
            <summary>
            String describing the assembly to be used in user facing error messages (e.g. file path).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CompilationOutputs.PdbDisplayPath">
            <summary>
            String describing the PDB to be used in user facing error messages (e.g. file path).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyMetadata(System.Boolean)">
            <summary>
            Opens metadata section of the assembly file produced by the compiler.
            </summary>
            <param name="prefetch">
            True to prefetch all metadata from the assembly and close the underlying stream on return,
            otherwise keeps the underlying stream open until the returned <see cref="T:System.Reflection.Metadata.MetadataReaderProvider"/> is disposed.
            </param>
            <returns>
            Instance of <see cref="T:System.Reflection.Metadata.MetadataReaderProvider"/>, which owns the opened metadata and must be disposed once the caller is done reading the data, 
            or null if the assembly is not available.
            </returns>
            <exception cref="T:System.BadImageFormatException">Invalid format of the assembly data.</exception>
            <exception cref="T:System.InvalidOperationException">The stream returned by <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStreamChecked"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error while reading assembly data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.ReadAssemblyModuleVersionId">
            <summary>
            Reads MVID of the output assembly. Overridable for test mocking.
            Returns <see cref="F:System.Guid.Empty"/> if the assembly is not available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdb">
            <summary>
            Opens PDB produced by the compiler.
            The caller must dispose the returned <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/>.
            </summary>
            <returns>
            Instance of <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/>, which owns the opened PDB and must be disposed once the caller is done reading the data,
            or null if PDB is not available.
            </returns>
            <exception cref="T:System.BadImageFormatException">Invalid format of the PDB or assembly data.</exception>
            <exception cref="T:System.InvalidOperationException">The stream returned by <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStreamChecked"/> or <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStreamChecked"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error while reading assembly data.</exception>
            <remarks>
            If a separate PDB stream is not available (<see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStreamChecked"/> returns null) opens the PDB embedded in the assembly, if present.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStream">
            <summary>
            Opens an assembly file produced by the compiler.
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
            <returns>New <see cref="T:System.IO.Stream"/> instance or null if the assembly is not available.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStream">
            <summary>
            Opens a PDB file produced by the compiler.
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
            <returns>New <see cref="T:System.IO.Stream"/> instance or null if the compiler generated no PDB (the symbols might be embedded in the assembly).</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.OperationStatusFlag">
            <summary>
            status code for extract method operations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.OperationStatusFlag.Succeeded">
            <summary>
            operation has succeeded
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.OperationStatusFlag.Suggestion">
            <summary>
            operation has succeeded with a span that is different than original span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.OperationStatusFlag.BestEffort">
            <summary>
            operation has failed but can provide some best effort result
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.GetTokenWithAnnotation(Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            get tokens with given annotation in current document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.ResolveType``1(Microsoft.CodeAnalysis.SemanticModel,``0)">
            <summary>
            resolve the given symbol against compilation this snapshot has
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.HasDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            check whether node contains error for itself but not from its child node
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Succeeded">
            <summary>
            True if the extract method operation succeeded.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.SucceededWithSuggestion">
            <summary>
            True if the extract method operation is possible if the original span is adjusted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Document">
            <summary>
            The transformed document that was produced as a result of the extract method operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Reasons">
            <summary>
            The reasons why the extract method operation did not succeed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.MethodDeclarationNode">
            <summary>
            the generated method node that contains the extracted code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.InvocationNameToken">
            <summary>
            The name token for the invocation node that replaces the extracted code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Status">
            <summary>
            internal status of result. more fine grained reason why it is failed. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult">
            <summary>
            contains information to restore trivia later on to the annotated tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult.Root">
            <summary>
            root node of the annotated tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult.RestoreTrivia(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ExtractMethod.AnnotationResolver,Microsoft.CodeAnalysis.ExtractMethod.TriviaResolver)">
            <summary>
            restore saved trivia to given tree
            </summary>
            <param name="root">root node to the annotated tree</param>
            <param name="annotationResolver">it provides a custom way of resolving annotations to retrieve right tokens to attach trivia</param>
            <param name="triviaResolver">it provides a custom way of creating trivia list between two tokens</param>
            <returns>root node to a trivia restored tree</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService">
            <summary>
            syntax trivia related services
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService.SaveTriviaAroundSelection(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            save trivia around span and let user restore trivia later
            </summary>
            <param name="root">root node of a tree</param>
            <param name="textSpan">selection whose trivia around its edges will be saved</param>
            <returns>object that holds onto enough information to restore trivia later</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetFlowAnalysisNodeRange">
            <summary>
            convert text span to node range for the flow analysis API
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.ContainsReturnStatementInSelectedCode(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            check whether selection contains return statement or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.CreateFromSymbol(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ExtractMethod.VariableStyle,System.Boolean)">
            <summary>
            create VariableInfo type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetIndexOfVariableInfoToUseAsReturnValue(System.Collections.Generic.IList{Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.VariableInfo})">
            <summary>
            among variables that will be used as parameters at the extracted method, check whether one of the parameter can be used as return
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetRangeVariableType(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.IRangeVariableSymbol)">
            <summary>
            get type of the range variable symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.ReadOnlyFieldAllowed">
            <summary>
            check whether the selection is at the placed where read-only field is allowed to be extracted out
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(System.Boolean,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.DataFlowAnalysis,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.List{Microsoft.CodeAnalysis.SyntaxToken}},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.VariableInfo}@,System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol}@)">
            <param name="bestEffort">When false, variables whose data flow is not understood
            will be returned in <paramref name="failedVariables"/>. When true, we assume any
            variable we don't understand has <see cref="F:Microsoft.CodeAnalysis.ExtractMethod.VariableStyle.None"/></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.UseInstanceMember">
            <summary>
            used to determine whether static can be used
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.ShouldBeReadOnly">
            <summary>
            Indicates whether the extracted method should have a 'readonly' modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.EndOfSelectionReachable">
            <summary>
            used to determine whether "return" statement needs to be inserted
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.SemanticDocument">
            <summary>
            document this result is based on
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.AwaitTaskReturn">
            <summary>
            flag to show whether task return type is due to await
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.ReturnType">
            <summary>
            return type
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.AnalyzerResult.Status">
            <summary>
            analyzer result operation status
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.VariableSymbol">
            <summary>
            temporary symbol until we have a symbol that can hold onto both local and parameter symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.VariableSymbol.OriginalTypeHadAnonymousTypeOrDelegate">
            <summary>
            return true if original type had anonymous type or delegate somewhere in the type
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.VariableSymbol.OriginalType">
            <summary>
            get the original type with anonymous type removed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.OperationStatus.Create``1(Microsoft.CodeAnalysis.ExtractMethod.OperationStatus,``0)">
            <summary>
            create operation status with the given data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.OperationStatus`1">
            <summary>
            operation status paired with data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.SelectionResult">
            <summary>
            clean up this code when we do selection validator work.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem">
            <summary>
            Information about a symbol's definition that can be displayed in an editor
            and used for navigation.
            
            Standard implmentations can be obtained through the various <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/>.Create
            overloads.
            
            Subclassing is also supported for scenarios that fall outside the bounds of
            these common cases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.MetadataSymbolKey">
            <summary>
            For metadata symbols we encode information in the <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties"/> so we can 
            retrieve the symbol later on when navigating.  This is needed so that we can go to
            metadata-as-source for metadata symbols.  We need to store the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>
            for the symbol and the project ID that originated the symbol.  With these we can correctly recover the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.NonNavigable">
            <summary>
            If this item is something that cannot be navigated to.  We store this in our
            <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties"/> to act as an explicit marker that navigation is not possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>. These tags may influence how the 
            item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties">
            <summary>
            Additional properties that can be attached to the definition for clients that want to
            keep track of additional data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayableProperties">
            <summary>
            Additional diplayable properties that can be attached to the definition for clients that want to
            display additional data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.NameDisplayParts">
            <summary>
            The DisplayParts just for the name of this definition.  Generally used only for 
            error messages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayParts">
            <summary>
            The full display parts for this definition.  Displayed in a classified 
            manner when possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.OriginationParts">
            <summary>
            Where the location originally came from (for example, the containing assembly or
            project name).  May be used in the presentation of a definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.SourceSpans">
            <summary>
            Additional locations to present in the UI.  A definition may have multiple locations 
            for cases like partial types/members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayIfNoReferences">
            <summary>
            Whether or not this definition should be presented if we never found any references to
            it.  For example, when searching for a property, the FindReferences engine will cascade
            to the accessors in case any code specifically called those accessors (can happen in 
            cross-language cases).  However, in the normal case where there were no calls specifically
            to the accessor, we would not want to display them in the UI.  
            
            For most definitions we will want to display them, even if no references were found.  
            This property allows for this customization in behavior.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DefaultDefinitionItem">
            <summary>
            Implementation of a <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/> that sits on top of a 
            <see cref="T:Microsoft.CodeAnalysis.DocumentSpan"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences">
            <summary>
            A collection of <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/>s and <see cref="T:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem"/>s
            that can be presented in an editor and used to navigate to the defintions and
            references found for a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.Definitions">
            <summary>
            All the definitions to show.  Note: not all definitions may have references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.References">
            <summary>
            All the references to show.  Note: every <see cref="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.Definition"/> 
            should be in <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.Definitions"/> 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.ExternalReferenceItem">
            <summary>
            Information about a symbol's reference that can be used for display and navigation in an
            editor.  These generally reference items outside of the Roslyn <see cref="T:Microsoft.CodeAnalysis.Solution"/> model
            provided by external sources such as online indices.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.ExternalReferenceItem.Definition">
            <summary>
            The definition this reference corresponds to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem">
            <summary>
            Information about a symbol's reference that can be used for display and 
            navigation in an editor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.Definition">
            <summary>
            The definition this reference corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.SourceSpan">
            <summary>
            The location of the source item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.IsWrittenTo">
            <summary>
            If this reference is a location where the definition is written to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.SymbolUsageInfo">
            <summary>
            Symbol usage info associated with the reference.
            This entry indicates that the reference has additional usage information, such as
            it is a read/write reference for 'a++'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.AdditionalProperties">
            <summary>
            Additional properties for the reference.
            For example, { "ContainingTypeInfo" } = { "MyClass" }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> is responsible for allowing a user to pick a 
            set of members from a class or struct, and then generate a constructor for that takes in
            matching parameters and assigns them to those members.  The members can be picked using 
            a actual selection in the editor, or they can be picked using a picker control that will
            then display all the viable members and allow the user to pick which ones they want to
            use.
            
            Importantly, this type is not responsible for generating constructors when the user types
            something like "new MyType(x, y, z)", nor is it responsible for generating constructors
            in a derived type that delegate to a base type. Both of those are handled by other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider.#ctor(Microsoft.CodeAnalysis.PickMembers.IPickMembersService)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateDefaultConstructors.GenerateDefaultConstructorsCodeRefactoringProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> gives users a way to generate constructors for
            a derived type that delegate to a base type.  For all accessibly constructors in the base
            type, the user will be offered to create a constructor in the derived type with the same
            signature if they don't already have one.  This way, a user can override a type and easily
            create all the forwarding constructors.
            
            Importantly, this type is not responsible for generating constructors when the user types
            something like "new MyType(x, y, z)", nor is it responsible for generating constructors
            for a type based on the fields/properties of that type. Both of those are handled by other 
            services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule">
            <summary>
            Specialized formatter for the "return a == obj.a &amp;&amp; b == obj.b &amp;&amp; c == obj.c &amp;&amp; ...
            code that we spit out.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            Wrap the large &amp;&amp; expression after every &amp;&amp; token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            Align all the wrapped parts of the expression with the token after 'return'.
            That way we get:
            
            return a == obj.a &amp;&amp;
                   b == obj.b &amp;&amp;
                   ...
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService">
            <summary>
            Service that can be used to generate <see cref="M:System.Object.Equals(System.Object)"/> and
            <see cref="M:System.Object.GetHashCode"/> overloads for use from other IDE features.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.FormatDocumentAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Formats only the members in the provided document that were generated by this interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateEqualsMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.String,System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.Equals(System.Object)"/> that works by comparing the
            provided <paramref name="members"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateEqualsMethodThroughIEquatableEqualsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.Equals(System.Object)"/> that works by delegating to
            <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateIEquatableEqualsMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Generates an implementation of <see cref="M:System.IEquatable`1.Equals(`0)"/> that works by
            comparing the provided <paramref name="members"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateGetHashCodeMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.GetHashCode"/> that computes a reasonable
            hash based on the provided <paramref name="members"/>.  The generated function will
            defer to HashCode.Combine if it exists.  Otherwise, it will determine if it should
            generate code directly in-line to compute the hash, or defer to something like
            <see cref="M:System.ValueTuple.GetHashCode"/> to provide a reasonable alternative.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateFromMembers.AbstractGenerateFromMembersCodeRefactoringProvider.DetermineParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule})">
            <summary>
            Returns an array of parameter symbols that correspond to selected member symbols.
            If a selected member symbol has an empty base identifier name, the parameter symbol will not be added.
            </summary>
            <param name="selectedMembers"></param>
            <param name="rules"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4.State.GenerateDeconstructMethodStateAsync(`0,Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Make a State instance representing the Deconstruct method we want to generate.
            The method will be called "Deconstruct". It will be a member of `typeToGenerateIn`.
            Its arguments will be based on `targetVariables`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService.ImplementInterfaceCodeAction.AttributesToRemove(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Lists compiler attributes that we want to remove.
            The TupleElementNames attribute is compiler generated (it is used for naming tuple element names).
            We never want to place it in source code.
            Same thing for the Dynamic attribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider">
            <summary>
            Features like add-using want to be able to quickly search symbol indices for projects and
            metadata.  However, creating those indices can be expensive.  As such, we don't want to
            construct them during the add-using process itself.  Instead, we expose this type as an 
            Incremental-Analyzer to walk our projects/metadata in the background to keep the indices
            up to date.
            
            We also then export this type as a service that can give back the index for a project or
            metadata dll on request.  If the index has been produced then it will be returned and 
            can be used by add-using.  Otherwise, nothing is returned and no results will be found.
            
            This means that as the project is being indexed, partial results may be returned.  However
            once it is fully indexed, then total results will be returned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider.MetadataInfo.SymbolTreeInfo">
            <summary>
            Can't be null.  Even if we weren't able to read in metadata, we'll still create an empty
            index.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider.MetadataInfo.ReferencingProjects">
            <summary>
            Note: the Incremental-Analyzer infrastructure guarantees that it will call all the methods
            on <see cref="T:Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider.IncrementalAnalyzer"/> in a serial fashion.  As that is the only type that
            reads/writes these <see cref="T:Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider.MetadataInfo"/> objects, we don't need to lock this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5.TryFindParameterCheckStatement(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.Operations.IBlockOperation,System.Threading.CancellationToken)">
            <summary>
            Tries to find an if-statement that looks like it is checking the provided parameter
            in some way.  If we find a match, we'll place our new null-check statement before/after
            this statement as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalLanguageNames">
            <summary>
            A class that provides constants for internal partner language names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2.IsLegalUsingStatementType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Up to date with C# 7.3. Pattern-based disposal is likely to be added to C# 8.0,
            in which case accessible instance and extension methods will need to be detected.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2.AddReferencedLocalVariables(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,System.Threading.CancellationToken)">
            <summary>
            Adds local variables that are being referenced within a statement to a set of symbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3">
            <summary>
            Code refactoring to help convert code like `!a || !b` to `!(a &amp;&amp; b)`
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3.s_annotation">
            <summary>
            See comment in <see cref="M:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3.InvertLogicalAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> to understand the need for this annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService.AbstractSymbolDescriptionBuilder.AddCaptures(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            If the symbol is a local or anonymous function (lambda or delegate), adds the variables captured
            by that local or anonymous function to the "Captures" group.
            </summary>
            <param name="symbol"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService.AbstractSymbolDescriptionBuilder.AddCaptures(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given the body of a local or an anonymous function (lambda or delegate), add the variables captured
            by that local or anonymous function to the "Captures" group.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddSuppressOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddAnchorIndentationOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddIndentBlockOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddAlignTokensOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.GetAdjustNewLinesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.GetAdjustSpacesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.RemoveSimplifierAnnotationsFromImportsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Editing.ImportAdderService"/> adds <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation"/> to Import Directives it adds,
            which causes the <see cref="T:Microsoft.CodeAnalysis.Simplification.Simplifier"/> to remove import directives when thety are only used by attributes.
            Presumably this is because MetadataAsSource isn't actually semantically valid code.
            
            To fix this we remove these annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.GetFormattingRules(Microsoft.CodeAnalysis.Document)">
            <summary>
            provide formatting rules to be used when formatting MAS file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.AddAssemblyInfoRegionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Prepends a region directive at the top of the document with a name containing
            information about the assembly and a comment inside containing the path to the
            referenced assembly.  The containing assembly may not have a path on disk, in which case
            a string similar to "location unknown" will be placed in the comment inside the region
            instead of the path.
            </summary>
            <param name="document">The document to generate source into</param>
            <param name="symbolCompilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> in which symbol is resolved.</param>
            <param name="symbol">The symbol to generate source for</param>
            <param name="cancellationToken">To cancel document operations</param>
            <returns>The updated document</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService.AddSourceToAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Generates formatted source code containing general information about the symbol's
            containing assembly, and the public, protected, and protected-or-internal interface of
            which the given ISymbol is or is a part of into the given document
            </summary>
            <param name="document">The document to generate source into</param>
            <param name="symbolCompilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> in which <paramref name="symbol"/> is resolved.</param>
            <param name="symbol">The symbol to generate source for</param>
            <param name="cancellationToken">To cancel document operations</param>
            <returns>The updated document</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers">
            <summary>
            Helpers shared by both the text service and the editor service
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.CanNavigateToSpan(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether it is possible to navigate to the given position in the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.CanNavigateToLineAndOffset(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Int32,System.Int32)">
            <summary>
            Determines whether it is possible to navigate to the given line/offset in the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.CanNavigateToPosition(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Int32,System.Int32)">
            <summary>
            Determines whether it is possible to navigate to the given virtual position in the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.TryNavigateToSpan(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Navigates to the given position in the specified document, opening it if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.TryNavigateToLineAndOffset(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Int32,System.Int32,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Navigates to the given line/offset in the specified document, opening it if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.TryNavigateToPosition(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Int32,System.Int32,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Navigates to the given virtual position in the specified document, opening it if necessary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.DisplayTaggedParts">
            <summary>
            The tagged parts to display for this item. If default, the line of text from <see cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.Document"/> is used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.DisplayFileLocation">
            <summary>
            Return true to display the file path of <see cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.Document"/> and the span of <see cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.SourceSpan"/> when displaying this item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.IsImplicitlyDeclared">
            <summary>
            his is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.  For example, a default synthesized constructor in C# when the class contains no
            explicit constructors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.TryNavigateToSymbol(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Navigate to the first source location of a given symbol.
            </summary>
            <param name="project">A project context with which to generate source for symbol
            if it has no source locations</param>
            <param name="symbol">The symbol to navigate to</param>
            <param name="options">A set of options. If these options are not supplied the
            current set of options from the project's workspace will be used.</param>
            <param name="cancellationToken">The token to check for cancellation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.TrySymbolNavigationNotify(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <returns>True if the navigation was handled, indicating that the caller should not 
            perform the navigation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.WouldNavigateToSymbol(Microsoft.CodeAnalysis.FindUsages.DefinitionItem,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken,System.String@,System.Int32@,System.Int32@)">
            <returns>True if the navigation would be handled.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.NavigableItemFactory.DeclaredSymbolNavigableItem.IsImplicitlyDeclared">
            <summary>
            DeclaredSymbolInfos always come from some actual declaration in source.  So they're
            never implicitly declared.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Navigation.NavigationOptions.PreferProvisionalTab">
            <summary>
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that a provisional (or preview) tab 
            be used for any document that needs to be opened, if one is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.INotificationService.SendNotification(System.String,System.String,Microsoft.CodeAnalysis.Notification.NotificationSeverity)">
            <summary>
            Displays a message box with an OK button to the user.
            </summary>
            <param name="message">The message shown within the message box.</param>
            <param name="title">The title bar to be shown in the message box. May be ignored by some implementations.</param>
            <param name="severity">The severity of the message.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.INotificationService.ConfirmMessageBox(System.String,System.String,Microsoft.CodeAnalysis.Notification.NotificationSeverity)">
            <summary>
            Displays a message box with a yes/no question to the user.
            </summary>
            <param name="message">The message shown within the message box.</param>
            <param name="title">The title bar to be shown in the message box. May be ignored by some implementations.</param>
            <param name="severity">The severity of the message.</param>
            <returns>true if yes was clicked, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Organizing.IOrganizingService">
            <summary>
            internal interface used to use language specific service from common service layer
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.IOrganizingService.GetDefaultOrganizers">
            <summary>
            return default organizers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.IOrganizingService.OrganizeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer},System.Threading.CancellationToken)">
            <summary>
            Organize document
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer.SyntaxNodeTypes">
            <summary>
            syntax node types this organizer is applicable to
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer.OrganizeNode(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            organize given node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.OrganizingService.OrganizeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer},System.Threading.CancellationToken)">
            <summary>
            Organize the whole document.
            
            Optionally you can provide your own organizers. otherwise, default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeDiagnosticAnalyzerBase`3.ShouldReportDiagnostic(`2,Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.String,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Detects the context of this occurrence of predefined type and determines if we should report it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeDiagnosticAnalyzerBase`3.OptionSettingPrefersFrameworkType(Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2{System.Boolean},Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            checks if style is preferred and the enforcement is not None.
            </summary>
            <remarks>if predefined type is not preferred, it implies the preference is framework type.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectManagement.IProjectManagementService">
            <summary>
            This service provides a way to extract all the folders under a given project, or find the default namespace if it exists.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.Member">
            <summary>
            The member needs to be pulled up.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeOriginalToPublic">
            <summary>
            Indicate whether this member needs to be changed to public so it won't cause error after it is pulled up to destination.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeOriginalToNonStatic">
            <summary>
            Indicate whether this member needs to be changed to non-static so it won't cause error after it is pulled up to destination.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.MakeMemberDeclarationAbstract">
            <summary>
            Indicate whether this member's declaration in destination needs to be made to abstract. It is only used by the dialog UI.
            If this property is true, then pull a member up to a class will only generate a abstract declaration in the destination.
            It will always be false if the refactoring is triggered from Quick Action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeDestinationTypeToAbstract">
            <summary>
            Indicate whether pulling this member up would change the destination to abstract. It will be true if:
            1. Pull an abstract member to a non-abstract class
            2. The 'Make abstract' check box of a member is checked, and the destination is a non-abstract class
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.PullMemberUpNeedsToDoExtraChanges">
            <summary>
            Indicate whether it would cause error if we directly pull Member into destination.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions">
            <summary>
            This class contains all the operations needs to be done on members and destination to complete the pull up operation.
            If user clicked the cancel button, it will be null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.Destination">
            <summary>
            Destination of where members should be pulled up to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.MemberAnalysisResults">
            <summary>
            All the members involved in this pull up operation,
            and the other changes (in adddition to pull up) needed so that this pull up operation won't cause error.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.PullUpOperationNeedsToDoExtraChanges">
            <summary>
            Indicate whether it would cause error if we directly pull all members in MemberAnalysisResults up to destination.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.ExportQuickInfoProviderAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.IndentationHelper.GetSpansWithAlignedIndentation(Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Int32)">
            <summary>
            Recomputes span segments so that all text lines appear to have the same reduction in indentation.
            This operation is typically used to align text for display when the initial span does not include all of the first line's identation.
            This operation will potentially split spans that cover multiple lines into separate spans.
            </summary>
            <param name="text"></param>
            <param name="classifiedSpans">The initial set of spans to align.</param>
            <param name="tabSize">The number of spaces to </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> when providing quick info.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.Document">
            <summary>
            The document that quick info was requested within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.Position">
            <summary>
            The caret position where quick info was requested from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.CancellationToken">
            <summary>
            The cancellation token to use for this operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.#ctor(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Span">
            <summary>
            The span of the document that the item is based on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Tags">
            <summary>
            Descriptive tags from the <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/> type.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Sections">
            <summary>
            One or more <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection"/> describing the item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.RelatedSpans">
            <summary>
            Alternate regions of the document that help describe the item.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider">
            <summary>
            A provider that produces <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/>'s. 
            Providers are used with some <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/> implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider.GetQuickInfoAsync(Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> for the position.
            </summary>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> or null if no item is available.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderNames">
            <summary>
            Some of the known <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> names in use.
            Names are used for ordering providers with the <see cref="T:Microsoft.CodeAnalysis.ExtensionOrderAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection">
            <summary>
            Sections are used to make up a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Kind">
            <summary>
            The kind of this section. Use <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds"/> for the most common kinds.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.TaggedParts">
            <summary>
            The individual tagged parts of this section.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection"/>.
            </summary>
            <param name="kind">The kind of the section. Use <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds"/> for the most common kinds.</param>
            <param name="taggedParts">The individual tagged parts of the section.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Text">
            <summary>
            The text of the section without tags.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds">
            <summary>
            The set of well known kinds used for the <see cref="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Kind"/> property.
            These tags influence the presentation of quick info section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService">
            <summary>
            A service that is used to determine the appropriate quick info for a position in a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the appropriate <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/> for the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService.GetQuickInfoAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> associated with position in the document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders">
            <summary>
            Base class for <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/>'s that delegate to <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/>'s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Scripting.IScriptEnvironmentService">
            <summary>
            Provides information on the current script environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Scripting.IScriptEnvironmentService.BaseDirectory">
            <summary>
            Full path of a directory to be used to resolve relative paths specified in #r and #load directives
            that are used in script that itself doesn't have a path (e.g. interactive submission).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Scripting.IScriptEnvironmentService.MetadataReferenceSearchPaths">
            <summary>
            Search paths used to find metadata references (#r directive).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Scripting.IScriptEnvironmentService.SourceReferenceSearchPaths">
            <summary>
            Search paths uses to find source references (#load directive).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetNamingRulesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets the set of naming rules the user has set for this document.  Will include a set of default naming rules
            that match if the user hasn't specified any for a particular symbol type.  The are added at the end so they
            will only be used if the user hasn't specified a preference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetNamingRulesAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule},System.Threading.CancellationToken)">
            <summary>
            Get the user-specified naming rules, with the added <paramref name="defaultRules"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions.GetValueText(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Gets the concatenated value text for the token list.
            </summary>
            <returns>The concatenated value text, or an empty string if there are no tokens in the list.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules.Default">
            <summary>
            Standard symbol names if the user doesn't have any existing naming rules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules.CompletionOfferingRules">
            <summary>
            Standard name rules for name suggestion/completion utilities.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Options.ServiceComponentOnOffOptions">
            <summary>
            options to indicate whether a certain component in Roslyn is enabled or not
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Options.ServiceFeatureOnOffOptions.ClosedFileDiagnostic">
            <summary>
            This option is used by TypeScript.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Options.ServiceFeatureOnOffOptions.RemoveDocumentDiagnosticsOnDocumentClose">
            <summary>
            This option is used by TypeScript.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.LinkedFilesSymbolEquivalenceComparer">
            <summary>
            For completion and quickinfo in linked files, we compare symbols from different documents
            to determine if they are similar enough for us to suppress the platform dependence
            warning icon. We consider symbols equivalent if they have the same name and kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider.CreateSignatureHelpItems(System.Collections.Generic.IList{Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem},Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpState)">
            <remarks>
            This overload is required for compatibility with existing extensions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.IsTriggerCharacter(System.Char)">
            <summary>
            Returns true if the character might trigger completion, 
            e.g. '(' and ',' for method invocations 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.IsRetriggerCharacter(System.Char)">
            <summary>
            Returns true if the character might end a Signature Help session, 
            e.g. ')' for method invocations.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.GetItemsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo,System.Threading.CancellationToken)">
            <summary>
            Returns valid signature help items at the specified position in the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem.IsVariadic">
            <summary>
            True if this signature help item can have an unbounded number of arguments passed to it.
            If it is variadic then the last parameter will be considered selected, even if the
            selected parameter index strictly goes past the number of defined parameters for this
            item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.Items">
            <summary>
            The list of items to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ApplicableSpan">
            <summary>
            The span this session applies to.
            
            Navigation outside this span will cause signature help to be dismissed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ArgumentIndex">
            <summary>
            Returns the specified argument index that the provided position is at in the current document.  This 
            index may be greater than the number of arguments in the selected <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ArgumentCount">
            <summary>
            Returns the total number of arguments that have been typed in the current document.  This may be 
            greater than the ArgumentIndex if there are additional arguments after the provided position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ArgumentName">
            <summary>
            Returns the name of specified argument at the current position in the document.  
            This only applies to languages that allow the user to provide named arguments.
            If no named argument exists at the current position, then null should be returned. 
            
            This value is used to determine which documentation comment should be provided for the current
            parameter.  Normally this is determined simply by determining the parameter by index.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.SelectedItemIndex">
            <summary>
            The item to select by default.  If this is <see langword="null"/> then the controller will
            pick the first item that has enough arguments to be viable based on what argument 
            position the user is currently inside of.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter">
            <summary>
            Used for C#/VB sig help providers so they can build up information using SymbolDisplayParts.
            These parts will then by used to properly replace anonymous type information in the parts.
            Once that it done, this will be converted to normal SignatureHelpParameters which only 
            point to TaggedText parts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.Name">
            <summary>
            The name of this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.DocumentationFactory">
            <summary>
            Documentation for this parameter.  This should normally be presented to the user when
            this parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.PrefixDisplayParts">
            <summary>
            Display parts to show before the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.SuffixDisplayParts">
            <summary>
            Display parts to show after the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.DisplayParts">
            <summary>
            Display parts for this parameter.  This should normally be presented to the user as part
            of the entire signature display.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.IsOptional">
            <summary>
            True if this parameter is optional or not.  Optional parameters may be presented in a
            different manner to users.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.SelectedDisplayParts">
            <summary>
            Display parts for this parameter that should be presented to the user when this
            parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.Name">
            <summary>
            The name of this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.DocumentationFactory">
            <summary>
            Documentation for this parameter.  This should normally be presented to the user when
            this parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.PrefixDisplayParts">
            <summary>
            Display parts to show before the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.SuffixDisplayParts">
            <summary>
            Display parts to show after the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.DisplayParts">
            <summary>
            Display parts for this parameter.  This should normally be presented to the user as part
            of the entire signature display.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.IsOptional">
            <summary>
            True if this parameter is optional or not.  Optional parameters may be presented in a
            different manner to users.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.SelectedDisplayParts">
            <summary>
            Display parts for this parameter that should be presented to the user when this
            parameter is selected.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.InvokeSignatureHelpCommand">
            <summary>
            Signature Help was triggered through the 'Invoke Signature Help' command
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.TypeCharCommand">
            <summary>
            Signature Help was triggered through the 'Type Char' command.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.RetriggerCommand">
            <summary>
            Signature Help was triggered through typing a closing brace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.IsIgnoredCodeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if a code block is eligible for analysis by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext)"/>.
            </summary>
            <param name="codeBlock">The syntax node provided via <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CodeBlock"/>.</param>
            <returns><see langword="true"/> if the code block should be analyzed by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext)"/>;
            otherwise, <see langword="false"/> to skip analysis of the block. If a block is skipped, one or more child
            blocks may be analyzed by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext)"/>, and any remaining spans can be analyzed by
            <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.AnalyzeSemanticModel(Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext,Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree{Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector})"/>.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1.AnalyzerImpl._codeBlockIntervals">
             <summary>
             Tracks the analysis state of syntax trees in a compilation. Each syntax tree has the properties:
             <list type="bullet">
             <item><description>
             <para><c>completed</c>: <see langword="true"/> to indicate that <c>intervalTree</c> has been obtained
             for use in a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext"/> callback; otherwise, <see langword="false"/> to
             indicate that <c>intervalTree</c> may be updated by adding a new non-overlapping <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>
             for analysis performed by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext"/> callback.</para>
            
             <para>This field also serves as the lock object for updating both <c>completed</c> and
             <c>intervalTree</c>.</para>
             </description></item>
             <item><description>
             <para><c>intervalTree</c>: the set of intervals analyzed by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext"/>
             callbacks, and therefore do not need to be analyzed again by a
             <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext"/> callback.</para>
            
             <para>This field may only be accessed while <c>completed</c> is locked, and is not valid after
             <c>completed</c> is <see langword="true"/>.</para>
             </description></item>
             </list>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerProgressReporter">
            <summary>
            Provide a way to see whether solution crawler is started or not
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerProgressReporter.InProgress">
            <summary>
            Return true if solution crawler is in progress.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerProgressReporter.ProgressChanged">
            <summary>
            Raised when solution crawler progress changed
            
            Notifications for this event are serialized to preserve order. 
            However, individual event notifications may occur on any thread.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCrawler.ProgressData.PendingItemCount">
            <summary>
            number of pending work item in the queue. 
            null means N/A for the associated <see cref="P:Microsoft.CodeAnalysis.SolutionCrawler.ProgressData.Status"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerService">
            <summary>
            Provide a way to control solution crawler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerService.Reanalyze(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},System.Boolean)">
            <summary>
            Ask solution crawler to re-analyze given <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s or/and <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s 
            in given <see cref="T:Microsoft.CodeAnalysis.Workspace"/> with given <see cref="T:Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerService.GetProgressReporter(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerProgressReporter"/> for the given <see cref="T:Microsoft.CodeAnalysis.Workspace"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.IWorkCoordinatorPriorityService.IsLowPriorityAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            True if this document is less important than other documents in the project it is 
            contained in, and should have work scheduled for it happen after all other documents
            in the project.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.SolutionCrawlerProgressReporter">
            <summary>
            Progress reporter
            
            this progress reporter is a best effort implementation. it doesn't stop world to find out accurate data
            
            what this reporter care is we show start/stop background work and show things are moving or paused
            without too much cost.
            
            due to how solution cralwer calls Start/Stop (see caller of those 2), those 2 can't have a race
            and that is all we care for this reporter
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.SolutionCrawlerProgressReporter.GetEvaluatingScope">
            <summary>
            Allows the solution crawler to start evaluating work enqueued to it. 
            Returns an IDisposable that the caller must dispose of to indicate that it no longer needs the crawler to continue evaluating. 
            Multiple callers can call into this simultaneously. 
            Only when the last one actually disposes the scope-object will the crawler 
            actually revert back to the paused state where no work proceeds.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.NullReporter">
            <summary>
            reporter that doesn't do anything
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.EnsureRegistration(Microsoft.CodeAnalysis.Workspace,System.Boolean)">
            <summary>
            make sure solution cralwer is registered for the given workspace.
            </summary>
            <param name="workspace"><see cref="T:Microsoft.CodeAnalysis.Workspace"/> this solution crawler runs for</param>
            <param name="initializeLazily">
            when true, solution crawler will be initialized when there is the first workspace event fired. 
            otherwise, it will be initialized when workspace is registered right away. 
            something like "Build" will use initializeLazily:false to make sure diagnostic analyzer engine (incremental analyzer)
            is initialized. otherwise, if build is called before workspace is fully populated, we will think some errors from build
            doesn't belong to us since diagnostic analyzer engine is not there yet and 
            let project system to take care of these unknown errors.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.SolutionCrawlerService">
            <summary>
            nested class of <see cref="T:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService"/> since it is tightly coupled with it.
            
            <see cref="T:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerService"/> is implemented by this class since WorkspaceService doesn't allow a class to implement
            more than one <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.WorkItem.SpecificAnalyzers">
            <summary>
            Non-empty if this work item is intended to be executed only for specific incremental analyzer(s).
            Otherwise, the work item is applicable to all relevant incremental analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.WorkItem.GetApplicableAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer})">
            <summary>
            Gets all the applicable analyzers to execute for this work item.
            If this work item has any specific analyzer(s), then returns the intersection of <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.WorkCoordinator.WorkItem.SpecificAnalyzers"/>
            and the given <paramref name="allAnalyzers"/>.
            Otherwise, returns <paramref name="allAnalyzers"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService.EnqueueItem">
            <summary>
            this will be used in the unit test to indicate certain action has happened or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingService.TryGetActiveDocument">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> of the active document. May be null if there is no active document
            or the active document is not in the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingService.GetVisibleDocuments">
            <summary>
            Get a read only collection of the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of all the visible documents in the workspace.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.IDocumentTrackingService.NonRoslynBufferTextChanged">
            <summary>
            Raised when a text buffer that's not part of a workspace is changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingServiceExtensions.GetActiveDocument(Microsoft.CodeAnalysis.IDocumentTrackingService,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Gets the active <see cref="T:Microsoft.CodeAnalysis.Document"/> the user is currently working in. May be null if
            there is no active document or the active document is not in this <paramref name="solution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingServiceExtensions.GetVisibleDocuments(Microsoft.CodeAnalysis.IDocumentTrackingService,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Get a read only collection of all the unique visible documents in the workspace that are
            contained within <paramref name="solution"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator">
            <summary>
            When querying the syntax, C# else if chains are "flattened" and modeled to look like VB else-if clauses,
            so an "ifOrElseIf" can be followed a sequence of else-if clauses and an optional final else clause.
            These else-if clauses are treated as independent when removing or inserting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.GetRootIfStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the topmost if statement for an else-if clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.GetElseIfAndElseClauses(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the list of subsequent else-if clauses and a final else clause (if present).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.ToIfStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts an else-if clause to an if statement, preserving its subsequent else-if and else clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.ToElseIfClause(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Convert an if statement to an else-if clause, discarding any of its else-if and else clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.InsertElseIfClause(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Inserts <paramref name="elseIfClause"/> as a new else-if clause directly below
            <paramref name="afterIfOrElseIf"/>, between it and any of its existing else-if clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.RemoveElseIfClause(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes <paramref name="elseIfClause"/> from a sequence of else-if clauses, preserving any subsequent clauses.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.IsCollapsible">
            <summary>
            Whether or not this span can be collapsed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.TextSpan">
            <summary>
            The span of text to collapse.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.HintSpan">
            <summary>
            The span of text to display in the hint on mouse hover.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.BannerText">
            <summary>
            The text to display inside the collapsed region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.AutoCollapse">
            <summary>
            Whether or not this region should be automatically collapsed when the 'Collapse to Definitions' command is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.IsDefaultCollapsed">
            <summary>
            Whether this region should be collapsed by default when a file is opened the first time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.BlockStructureService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the service corresponding to the specified document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockStructureService.Language">
            <summary>
            The language from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> this service corresponds to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.BlockStructureService.GetBlockStructure(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Structure.BlockStructure"/> for the provided document. Note that the
            default implementation works by calling into <see cref="M:Microsoft.CodeAnalysis.Structure.BlockStructureService.GetBlockStructureAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)"/>
            and blocking on the async operation. Subclasses should provide more efficient
            implementations that do not block on async operations if possible.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders.GetBuiltInProviders">
            <summary>
            Returns the providers always available to the service.
            This does not included providers imported via MEF composition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider">
            <summary>
            Note: this type is for subclassing by the VB and C# provider only.
            It presumes that the language supports Syntax Trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider.ProvideBlockStructure(Microsoft.CodeAnalysis.Structure.BlockStructureContext)">
            <summary>
            Keep in sync with <see cref="M:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider.ProvideBlockStructureAsync(Microsoft.CodeAnalysis.Structure.BlockStructureContext)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider.ProvideBlockStructureAsync(Microsoft.CodeAnalysis.Structure.BlockStructureContext)">
            <summary>
            Keep in sync with <see cref="M:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider.ProvideBlockStructure(Microsoft.CodeAnalysis.Structure.BlockStructureContext)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService.MapSymbolAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SymbolKey,System.Threading.CancellationToken)">
            <summary>
            Given a <cref see="SymbolId"/> and the document whence the corresponding <cref see="ISymbol"/>
            came, locate an identical symbol in the correct solution for performing common symbol operations
            (e.g. find references) as defined by this service.
            </summary>
            <param name="document">The document whence the symbol came</param>
            <param name="symbolId">The id of the symbol to map</param>
            <param name="cancellationToken">To cancel symbol resolution</param>
            <returns>The matching symbol from the correct solution or null</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService.MapSymbolAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Given an <cref see="ISymbol"/> and the document whence the corresponding <cref see="ISymbol"/>
            came, locate an identical symbol in the correct solution for performing common symbol operations
            (e.g. find references) as defined by this service.
            </summary>
            <param name="document">The document whence the symbol came</param>
            <param name="symbol">The symbol to map</param>
            <param name="cancellationToken">To cancel symbol resolution</param>
            <returns>The matching symbol from the correct solution or null</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TodoComments.TodoComment">
            <summary>
            A TODO comment that has been found within the user's code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TodoComments.TodoCommentDescriptor">
            <summary>
            Description of a TODO comment type to find in a user's comments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_removeEscapedBracketsRegex">
            <summary>
            this regex is used to remove escaped brackets from
            the format string before looking for valid {} pairs
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_extractPlaceholdersRegex">
            <summary>
            this regex is used to extract the text between the
            brackets and save the contents in a MatchCollection
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.RemoveEscapedBrackets(System.String)">
            <summary>
            removing escaped left brackets and replacing with space characters so they won't
            impede the extraction of placeholders, yet the locations of the placeholders are
            the same as in the original string.
            </summary>
            <param name="formatString"></param>
            <returns>string with left brackets removed and replaced by spaces</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.BackgroundParser">
            <summary>
            when users type, we chain all those changes as incremental parsing requests 
            but doesn't actually realize those changes. it is saved as a pending request. 
            so if nobody asks for final parse tree, those chain can keep grow. 
            we do this since Roslyn is lazy at the core (don't do work if nobody asks for it)
            
            but certain host such as VS, we have this (BackgroundParser) which preemptively 
            trying to realize such trees for open/active files expecting users will use them soonish.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ProjectCacheService">
            <summary>
            This service will implicitly cache previous Compilations used by each supported Workspace implementation.
            The number of Compilations cached is determined by <see cref="F:Microsoft.CodeAnalysis.Host.ProjectCacheService.ImplicitCacheSize"/>.  For now, we'll only
            support implicit caching for VS Workspaces (<see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/>), as caching is known to
            reduce latency in designer scenarios using the VS workspace.  For other Workspace kinds, the cost of the
            cache is likely to outweigh the benefit (for example, in Misc File Workspace cases, we can end up holding
            onto a lot of memory even after a file is closed).  We can opt in other kinds of Workspaces as needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper">
            <summary>
            Common implementation of all <see cref="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper"/>.  This type takes care of a lot of common logic for
            all of them, including:
            
            1. Keeping track of code action invocations, allowing code actions to then be prioritized on
               subsequent invocations.
               
            2. Checking nodes and tokens to make sure they are safe to be wrapped.
            
            Individual subclasses may be targeted at specific syntactic forms.  For example, wrapping
            lists, or wrapping logical expressions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1">
            <summary>
            Class responsible for actually computing the entire set of code actions to offer the
            user.  Contains lots of helper functionality used by all the different Wrapper
            implementations.
            
            Specifically subclasses of this type can simply provide a list of code-actions to
            perform.  This type will then take those code actions and will ensure there aren't
            multiple code actions that end up having the same effect on the document.  For example,
            a "wrap all" action may produce the same results as a "wrap long" action.  In that case
            this type will only keep around the first of those actions to prevent showing the user
            something that will be unclear.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1.s_toFormatAnnotation">
            <summary>
            Annotation used so that we can track the top-most node we want to format after
            performing all our edits.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1._seenDocumentRoots">
            <summary>
            The contents of the documents we've created code-actions for.  This is used so that
            we can prevent creating multiple code actions that produce the same results.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1.TryCreateCodeActionAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Wrapping.Edit},System.String,System.String)">
            <summary>
            Try to create a CodeAction representing these edits.  Can return <see langword="null"/> in several 
            cases, including:
            
                1. No edits.
                2. Edits would change more than whitespace.
                3. A previous code action was created that already had the same effect.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider">
            <summary>
            Base type for the C# and VB wrapping refactorings.  The only responsibility of this type is
            to walk up the tree at the position the user is at, seeing if any node above the user can be
            wrapped by any provided <see cref="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper"/>s.
            
            Once we get any wrapping actions, we stop looking further.  This keeps the refactorings
            scoped as closely as possible to where the user is, as well as preventing overloading of the
            lightbulb with too many actions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.GetNewLineBeforeOperatorTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Get's the language specific trivia that should be inserted before an operator if the
            user wants to wrap the operator to the next line.  For C# this is a simple newline-trivia.
            For VB, this will be a line-continuation char (<c>_</c>), followed by a newline.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._newlineBeforeOperatorTrivia">
            <summary>
            trivia to place at the end of a node prior to a chunk that is wrapped.
            For C# this will just be a newline.  For VB this will include a line-
            continuation character.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._indentAndAlignTrivia">
            <summary>
            The indent trivia to insert if we are trying to align wrapped code with the 
            start of the original expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._smartIndentTrivia">
            <summary>
            The indent trivia to insert if we are trying to simply smart-indent all wrapped
            parts of the expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2">
             <summary>
             Finds and wraps 'chained' expressions.  For the purpose of this feature, a chained
             expression is built out of 'chunks' where each chunk is of the form
            
             <code>
                 . name (arglist) remainder
             </code>
             
             So, if there are two or more of these like:
             
             <code>
                 . name1 (arglist1) remainder1 . name2 (arglist2) remainder2
             </code>
             
             Then this will be wrapped such that the dots align like so:
             
             <code>
                 . name1 (arglist1) remainder1
                 . name2 (arglist2) remainder2
             </code>
             
             Note: for the sake of simplicity, (arglist) is used both for the argument list of
             an InvocationExpression and an ElementAccessExpression.
             
             'remainder' is all the postfix expression that can follow <c>. name (arglist)</c>.  i.e.
             member-access expressions, conditional-access expressions, etc.  Effectively, anything
             the language allows at this point as long as it doesn't start another 'chunk' itself.
             
             This approach gives an intuitive wrapping algorithm that matches the common way
             many wrap dotted invocations, while also effectively not limiting the wrapper to
             only simple forms like <c>.a(...).b(...).c(...)</c>.  
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.GetNewLineBeforeOperatorTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Gets the language specific trivia that should be inserted before an operator if the
            user wants to wrap the operator to the next line.  For C# this is a simple newline-trivia.
            For VB, this will be a line-continuation char (<c>_</c>), followed by a newline.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.FindNextChunkStart(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxNodeOrToken},System.Boolean,System.Int32)">
            <summary>
            Looks for the next sequence of <c>. Name (ArgList)</c>.  Note, except for the first
            chunk, this cannot be of the form <c>? . Name (ArgList)</c> as we do not want to 
            wrap before a dot in a <c>?.</c> form.  This doesn't matter for the first chunk as
            we won't be wrapping that one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.Decompose(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Recursively walks down <paramref name="node"/> decomposing it into the individual 
            tokens and nodes we want to look for chunks in. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer">
            <summary>
            Responsible for actually computing the set of potential wrapping options
            for chained expressions.  The three options we offer are basically
            1. wrap-each. Each chunk will be wrapped and aligned with the first chunk.
            2. wrap-long. The same as '1', except a chunk will only be wrapped
               if it would go past the preferred wrapping column.
            3. Unwrap.  All the chunks will be placed on a single line.
            
            Note: These three options are always computed and returned.  The caller
            is the one that ends up eliminating any if they would be redundant.  i.e.
            if wrap-long produces the same results as wrap-each, then the caller will
            filter it out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._chunks">
            <summary>
            The chunks to normalize and wrap.  The first chunk will be normalized,
            but not wrapped.  Successive chunks will be normalized and wrapped 
            appropriately depending on if this is wrap-each or wrap-long.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._newlineBeforeOperatorTrivia">
            <summary>
            trivia to place at the end of a node prior to a chunk that is wrapped.
            For C# this will just be a newline.  For VB this will include a line-
            continuation character.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._firstPeriodIndentationTrivia">
            <summary>
            The indent trivia to insert if we are trying to align wrapped chunks with the 
            first period of the original chunk.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._smartIndentTrivia">
            <summary>
            The indent trivia to insert if we are trying to simply smart-indent all wrapped
            chunks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.Edit">
            <summary>
            Represents an edit between two tokens.  Specifically, provides the new trailing trivia for
            the <see cref="F:Microsoft.CodeAnalysis.Wrapping.Edit.Left"/> token and the new leading trivia for the <see
            cref="F:Microsoft.CodeAnalysis.Wrapping.Edit.Right"/> token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.Edit.DeleteBetween(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Create the Edit representing the deletion of all trivia between left and right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer.GetTopLevelCodeActionsAsync">
            <summary>
            Produces the actual top-level code wrapping actions for the original node provided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper">
            <summary>
            Interface for types that can wrap some sort of language construct.
            </summary>
            <remarks>
            The main refactoring
            keeps walking up nodes until it finds the first IWrapper that can handle that node.  That
            way the user is not inundated with lots of wrapping options for all the nodes their cursor
            is contained within.
            </remarks>
            <seealso cref="T:Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper.TryCreateComputerAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer"/> that produces wrapping code actions for the  
            node passed in.  Returns <see langword="null"/> if this Wrapper cannot wrap this node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2">
            <summary>
            Base type for all wrappers that involve wrapping a comma-separated list of items.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer">
            <summary>
            Class responsible for actually computing the entire set of code actions to offer the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._afterOpenTokenIndentationTrivia">
            <summary>
            The indentation string necessary to indent an item in a list such that the start of
            that item will exact start at the end of the open-token for the containing list. i.e.
            
                void Goobar(
                            ^
                            |
            
            This is the indentation we want when we're aligning wrapped items with the first item 
            in the list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._singleIndentationTrivia">
            <summary>
            Indentation amount for any items that have been wrapped to a new line.  Valid if we're
            not aligning with the first item. i.e.
            
                void Goobar(
                    ^
                    |
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.WrapFirst_IndentRest">
            <summary>
            Wraps first item.  Subsequent items, if wrapped, will be aligned with that first item:
                 MethodName(
                     int a, int b, int c, int d, int e,
                     int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.UnwrapFirst_AlignRest">
            <summary>
            Unwraps first item.  Subsequent items, if wrapped, will be aligned with that first item:
                 MethodName(int a, int b, int c, int d, int e,
                            int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.UnwrapFirst_IndentRest">
            <summary>
            Unwraps first item.  Subsequent items, if wrapped, will be indented:
                 MethodName(int a, int b, int c, int d, int e,
                     int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.WrapItemsAction">
            <summary>
            Code action for actually wrapping items.  Provided as a special subclass because it will
            also update the wrapping most-recently-used list when the code action is actually
            invoked.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.WrappingGroup">
            <summary>
            A group of wrapping actions placed under a common title.  For example:
                Unwrap group:
                    unwrap option 1
                    unwrap option 2
                Wrap all group:
                    wrap all option 1
                    wrap all optoin 2
                    ...
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.WrappingGroup.IsInlinable">
            <summary>
            Whether or not the items in this group can be inlined in the topmost lightbulb.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.WrappingGroup.WrappingActions">
            <summary>
            The actual wrapping code actions for this group to present to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DeclarationInfo">
            <summary>
            Struct containing information about a source declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredNode">
            <summary>
            Topmost syntax node for this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.ExecutableCodeBlocks">
            <summary>
            Syntax nodes for executable code blocks (method body, initializers, etc.) associated with this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol">
            <summary>
            Symbol declared by this declaration.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2.s_diagnosticDescriptor">
            <summary>
            A diagnostic descriptor used to squiggle and message the span.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2.s_fadeLocations">
            <summary>
            This analyzer inserts the fade locations into indices 1 and 2 inside additional locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2.GetDiagnosticSquiggleLocation(`1,System.Threading.CancellationToken)">
            <summary>
            Gets the span of text to squiggle underline.
            If the expression is contained within a single line, the entire expression span is returned.
            Otherwise it will return the span from the expression start to the end of the same line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.CommentPrefix">
            <summary>
            Gets the text prefix indicating a single-line comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.SingleLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.SingleLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.MultiLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.MultiLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.WhitespaceTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.WhitespaceTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.EndOfLineTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.EndOfLineTrivia"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.IndexOfFirstNonWhitespaceTrivia``1(``0)">
            <summary>
            Returns the index of the first non-whitespace trivia in the given trivia list.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index where the non-whitespace starts, or -1 if there is no non-whitespace trivia.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader">
            <summary>
            Contains the parsed file header information for a syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._fileHeaderStart">
            <summary>
            The location in the source where the file header was expected to start.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._commentPrefixLength">
            <summary>
            The length of the prefix indicating the start of a comment. For example:
            <list type="bullet">
              <item>
                <term>C#</term>
                <description>2, for the length of <c>//</c>.</description>
              </item>
              <item>
                <term>Visual Basic</term>
                <description>1, for the length of <c>'</c>.</description>
              </item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="copyrightText">The copyright string, as parsed from the header.</param>
            <param name="fileHeaderStart">The offset within the file at which the header started.</param>
            <param name="fileHeaderEnd">The offset within the file at which the header ended.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="fileHeaderStart">The offset within the file at which the header started, or was expected to start.</param>
            <param name="isMissing"><see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.IsMissing">
            <summary>
            Gets a value indicating whether the file header is missing.
            </summary>
            <value>
            <see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.CopyrightText">
            <summary>
            Gets the copyright text, as parsed from the header.
            </summary>
            <value>
            The copyright text, as parsed from the header.
            </value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.MissingFileHeader(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header starting at the specified
            position.
            </summary>
            <param name="fileHeaderStart">The location at which a file header was expected. This will typically be the
            start of the first line after any directive trivia (<see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.IsDirective"/>) to account for
            source suppressions.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.GetLocation(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the location representing the start of the file header.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <returns>The location representing the start of the file header.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers._lastParsed">
            <remarks>
            Reference type so we can read/write atomically.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3.CanMemberAccessBeQualified(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Reports on whether the specified member is suitable for qualification. Some member
            access expressions cannot be qualified; for instance if they begin with <c>base.</c>,
            <c>MyBase.</c>, or <c>MyClass.</c>.
            </summary>
            <returns>True if the member access can be qualified; otherwise, False.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`2.HandleNamedTypeSymbolStart(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ValueUsageInfo})">
            <summary>
            Override this method to register custom language specific actions to find symbol usages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`2.CompilationAnalyzer.IsCandidateSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the given symbol meets the following criteria to be
            a candidate for dead code analysis:
                1. It is marked as "private".
                2. It is not an implicitly declared symbol.
                3. It is either a method, field, property or an event.
                4. If method, then it is a constructor OR a method with <see cref="F:Microsoft.CodeAnalysis.MethodKind.Ordinary"/>,
                   such that is meets a few criteria (see implementation details below).
                5. If field, then it must not be a backing field for an auto property.
                   Backing fields have a non-null <see cref="P:Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol"/>.
                6. If property, then it must not be an explicit interface property implementation.
                7. If event, then it must not be an explicit interface event implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method adjusts the <paramref name="declarators"/> to remove based on whether or not all variable declarators
            within a field declaration should be removed,
            i.e. if all the fields declared within a field declaration are unused,
            we can remove the entire field declaration instead of individual variable declarators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            If all the <paramref name="childDeclarators"/> are contained in <paramref name="declarators"/>,
            the removes the <paramref name="childDeclarators"/> from <paramref name="declarators"/>, and
            adds the <paramref name="parentDeclaration"/> to the <paramref name="declarators"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer">
            <summary>
            Analyzer to report unused expression values and parameters:
            It flags the following cases:
                1. Expression statements that drop computed value, for example, "Computation();".
                   These should either be removed (redundant computation) or should be replaced
                   with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueExpressionStatement".
                2. Value assignments to locals/parameters that are never used on any control flow path,
                   For example, value assigned to 'x' in first statement below is unused and will be flagged:
                        x = Computation();
                        if (...)
                            x = Computation2();
                        else
                            Computation3(out x);
                        ... = x;
                   Just as for case 1., these should either be removed (redundant computation) or
                   should be replaced with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueAssignment".
                3. Redundant parameters that fall into one of the following two categories:
                    a. Have no references in the executable code block(s) for its containing method symbol.
                    b. Have one or more references but its initial value at start of code block is never used.
                       For example, if 'x' in the example for case 2. above was a parameter symbol with RefKind.None
                       and "x = Computation();" is the first statement in the method body, then its initial value
                       is never used. Such a parameter should be removed and 'x' should be converted into a local.
                   We provide additional information in the diagnostic message to clarify the above two categories
                   and also detect and mention about potential breaking change if the containing method is a public API.
                   Currently, we do not provide any code fix for removing unused parameters as it needs fixing the
                   call sites and any automated fix can lead to subtle overload resolution differences,
                   though this may change in future.
                   This diagnostic configuration is controlled by <see cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.UnusedParameters"/> option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.ShouldBailOutFromRemovableAssignmentAnalysis(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Indicates if we should bail from removable assignment analysis for the given
            symbol write operation.
            Removable assignment analysis determines if the assigned value for the symbol write
            has no side effects and can be removed without changing the semantics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsCallStatement(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given expression statement operation has an explicit "Call" statement syntax indicating explicit discard.
            For example, VB "Call" statement.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsExpressionOfExpressionBody(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given operation is an expression of an expression body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.CreatePropertiesMap">
            <summary>
            Method to compute well-known diagnostic property maps for different comnbinations of diagnostic properties.
            The property map is added to each instance of the reported diagnostic and is used by the code fixer to
            compute the correct code fix.
            It currently maps to three different properties of the diagnostic:
                1. The underlying <see cref="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference"/> for the reported diagnostic
                2. "isUnusedLocalAssignment": Flag indicating if the flagged local variable has no reads/uses.
                3. "isRemovableAssignment": Flag indicating if the assigned value is from an expression that has no side effects
                        and hence can be removed completely. For example, if the assigned value is a constant or a reference
                        to a local/parameter, then it has no side effects, but if it is method invocation, it may have side effects.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer, such as '_', '_1', '_2', etc.
            These are treated as special discard symbol names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateCreationOrAnonymousFunction">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateEscape">
            <summary>
            Indicates if the operation block has an operation that leads to a delegate escaping the current block,
            which would prevent us from performing accurate flow analysis of lambda/local function invocations
            within this operation block.
            Some examples:
                1. Delegate assigned to a field or property.
                2. Delegate passed as an argument to an invocation or object creation.
                3. Delegate added to an array or wrapped within a tuple.
                4. Delegate converted to a non-delegate type.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasInvalidOperation">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._referencedParameters">
            <summary>
            Parameters which have at least one read/write reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledDelegateCreationOrAnonymousFunctionTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledLocalOrParameterReferenceTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation"/>
            of delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)">
            <summary>
            Method invoked in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.AnalyzeOperationBlockEnd(Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext)"/>
            for each operation block to determine if we should analyze the operation block or bail out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer._unusedParameters">
            <summary>
            Map from unused parameters to a boolean value indicating if the parameter has a read reference or not.
            For example, a parameter whose initial value is overwritten before any reads
            is an unused parameter with read reference(s).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11">
            <summary>
            Code fixer for unused expression value diagnostics reported by <see cref="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer"/>.
            We provide following code fixes:
                1. If the unused value assigned to a local/parameter has no side-effects,
                   we recommend removing the assignment. We consider an expression value to have no side effects
                   if one of the following is true:
                    1. Value is a compile time constant.
                    2. Value is a local or parameter reference.
                    3. Value is a field reference with no or implicit this instance.
                2. Otherwise, if user preference is set to DiscardVariable, and project's
                   language version supports discard variable, we recommend assigning the value to discard.
                3. Otherwise, we recommend assigning the value to a new unused local variable which has no reads.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Method to update the identifier token for the local/parameter declaration or reference
            that was flagged as an unused value write by the analyzer.
            Returns null if the provided node is not one of the handled node kinds.
            Otherwise, returns the new node with updated identifier.
            </summary>
            <param name="node">Flaggged node containing the identifier token to be replaced.</param>
            <param name="newName">New identifier token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetForEachStatementIdentifier(`6)">
            <summary>
            Gets the identifier token for the iteration variable of the given foreach statement node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.WrapWithBlockIfNecessary(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Wraps the given statements within a block statement.
            Note this method is invoked when replacing a statement that is parented by a non-block statement syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(`7,Microsoft.CodeAnalysis.Editing.SyntaxEditor,`4)">
            <summary>
            Inserts the given declaration statement at the start of the given switch case block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetReplacementNodeForCompoundAssignment(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Gets the replacement node for a compound assignment expression whose
            assigned value is redundant.
            For example, "x += MethodCall()", where assignment to 'x' is redundant
            is replaced with "_ = MethodCall()" or "var unused = MethodCall()"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.NeedsToMoveNewLocalDeclarationsNearReference(System.String)">
            <summary>
            Flag to indicate if the code fix can introduce local declaration statements
            that need to be moved closer to the first reference of the declared variable.
            This is currently only possible for the unused value assignment fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.ReplaceDiscardDeclarationsWithAssignmentsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the
            local declarations named '_' converted to simple assignments to discard.
            For example, <code>int _ = Computation();</code> is converted to
            <code>_ = Computation();</code>.
            This is needed to prevent the code fix/FixAll from generating code with
            multiple local variables named '_', which is a compiler error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.AdjustLocalDeclarationsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the new
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_newLocalDeclarationStatementAnnotation"/>
            moved closer to first reference and all the existing
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_existingLocalDeclarationWithoutInitializerAnnotation"/>
            whose declared local is no longer used removed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionDiagnosticAnalyzer`4">
            <summary>
            Looks for code of the form "x == null ? y : x" and offers to convert it to "x ?? y";
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3._binaryToAssignmentMap">
            <summary>
            Maps from a binary expression kind (like AddExpression) to the corresponding assignment
            form (like AddAssignmentExpression).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3._assignmentToTokenMap">
            <summary>
            Maps from an assignment form (like AddAssignmentExpression) to the corresponding
            operator type (like PlusEqualsToken).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers.UnwrapSingleStatementBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Will unwrap a block with a single statement in it to just that block.  Used so we can
            support both <c>if (expr) { statement }</c> and <c>if (expr) statement</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.CreateConditionalExpressionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Operations.IConditionalOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Helper to create a conditional expression out of two original IOperation values
            corresponding to the whenTrue and whenFalse parts. The helper will add the appropriate
            annotations and casts to ensure that the conditional expression preserves semantics, but
            is also properly simplified and formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.MakeMultiLineAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Checks if we should wrap the conditional expression over multiple lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6.FixOneAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)">
            <summary>
            Returns 'true' if a multi-line conditional was created, and thus should be
            formatted specially.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer">
            <summary>
            Helper code to support both "UseSystemHashCodeCodeFixProvider" and
            <see cref="T:Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeDiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.GetHashedMembers(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Analyzes the containing <c>GetHashCode</c> method to determine which fields and
            properties were combined to form a hash code for this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.IsLiteralNumber(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Matches positive and negative numeric literals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.OperationDeconstructor">
            <summary>
            Breaks down complex <see cref="T:Microsoft.CodeAnalysis.IOperation"/> trees, looking for particular
            <see cref="M:System.Object.GetHashCode"/> patterns and extracting out the field and property
            symbols use to compute the hash.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.OperationDeconstructor.TryAddHashedSymbol(Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Recursive function that decomposes <paramref name="value"/>, looking for particular
            forms that VS or ReSharper generate to hash fields in the containing type.
            </summary>
            <param name="seenHash">'seenHash' is used to determine if we actually saw something
            that indicates that we really hashed a field/property and weren't just simply
            referencing it.  This is used as we recurse down to make sure we've seen a
            pattern we explicitly recognize by the time we hit a field/prop.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer">
             <summary>
             Looks for patterns of the form:
             <code>
             if (a == null) {
               throw SomeException();
             }
            
             x = a;
             </code>
            
             and offers to change it to
            
             <code>
             x = a ?? throw SomeException();
             </code>
            
             Note: this analyzer can be updated to run on VB once VB supports 'throw'
             expressions as well.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_project_reference_to_0">
            <summary>Add project reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_reference_to_0">
            <summary>Add reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Actions_can_not_be_empty">
            <summary>Actions can not be empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generic_overload">
            <summary>generic overload</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generic_overloads">
            <summary>generic overloads</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.overload">
            <summary>overload</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.overloads_">
            <summary>overloads</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_Keyword">
            <summary>{0} Keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_field_colon_0_and_use_property">
            <summary>Encapsulate field: '{0}' (and use property)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_field_colon_0_but_still_use_field">
            <summary>Encapsulate field: '{0}' (but still use field)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_fields_and_use_property">
            <summary>Encapsulate fields (and use property)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_fields_but_still_use_field">
            <summary>Encapsulate fields (but still use field)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
            <summary>Could not extract interface: The selection is not inside a class/interface/struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
            <summary>Could not extract interface: The type does not contain any member that can be extracted to an interface.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.can_t_not_construct_final_tree">
            <summary>can't not construct final tree</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
            <summary>Parameters' type or return type cannot be an anonymous type : [{0}]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_no_active_statement">
            <summary>The selection contains no active statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_a_local_function_call_without_its_declaration">
            <summary>The selection contains a local function call without its declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_an_error_or_unknown_type">
            <summary>The selection contains an error or unknown type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Type_parameter_0_is_hidden_by_another_type_parameter_1">
            <summary>Type parameter '{0}' is hidden by another type parameter '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_address_of_a_variable_is_used_inside_the_selected_code">
            <summary>The address of a variable is used inside the selected code.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
            <summary>Assigning to readonly fields must be done in a constructor : [{0}].</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generated_code_is_overlapping_with_hidden_portion_of_the_code">
            <summary>generated code is overlapping with hidden portion of the code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_optional_parameters_to_0">
            <summary>Add optional parameters to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameters_to_0">
            <summary>Add parameters to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_delegating_constructor_0_1">
            <summary>Generate delegating constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constructor_0_1">
            <summary>Generate constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_field_assigning_constructor_0_1">
            <summary>Generate field assigning constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_Equals_and_GetHashCode">
            <summary>Generate Equals and GetHashCode</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_Equals_object">
            <summary>Generate Equals(object)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_GetHashCode">
            <summary>Generate GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constructor_in_0">
            <summary>Generate constructor in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_all">
            <summary>Generate all</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_enum_member_1_0">
            <summary>Generate enum member '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constant_1_0">
            <summary>Generate constant '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_read_only_property_1_0">
            <summary>Generate read-only property '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_property_1_0">
            <summary>Generate property '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_read_only_field_1_0">
            <summary>Generate read-only field '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_field_1_0">
            <summary>Generate field '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_local_0">
            <summary>Generate local '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_0_1_in_new_file">
            <summary>Generate {0} '{1}' in new file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_nested_0_1">
            <summary>Generate nested {0} '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Global_Namespace">
            <summary>Global Namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_all_members_explicitly">
            <summary>Implement all members explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_interface_abstractly">
            <summary>Implement interface abstractly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_interface_through_0">
            <summary>Implement interface through '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_interface">
            <summary>Implement interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field_for_0">
            <summary>Introduce field for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_for_0">
            <summary>Introduce local for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant_for_0">
            <summary>Introduce constant for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_constant_for_0">
            <summary>Introduce local constant for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field_for_all_occurrences_of_0">
            <summary>Introduce field for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_for_all_occurrences_of_0">
            <summary>Introduce local for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant_for_all_occurrences_of_0">
            <summary>Introduce constant for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_constant_for_all_occurrences_of_0">
            <summary>Introduce local constant for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable_for_all_occurrences_of_0">
            <summary>Introduce query variable for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable_for_0">
            <summary>Introduce query variable for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Anonymous_Types_colon">
            <summary>Anonymous Types:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.is_">
            <summary>is</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Represents_an_object_whose_operations_will_be_resolved_at_runtime">
            <summary>Represents an object whose operations will be resolved at runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.constant">
            <summary>constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.field">
            <summary>field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_constant">
            <summary>local constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_variable">
            <summary>local variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.label">
            <summary>label</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.range_variable">
            <summary>range variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.parameter">
            <summary>parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.discard">
            <summary>discard</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_">
            <summary>in</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Summary_colon">
            <summary>Summary:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Locals_and_parameters">
            <summary>Locals and parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Type_parameters_colon">
            <summary>Type parameters:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Returns_colon">
            <summary>Returns:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Exceptions_colon">
            <summary>Exceptions:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remarks_colon">
            <summary>Remarks:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generating_source_for_symbols_of_this_type_is_not_supported">
            <summary>generating source for symbols of this type is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Assembly">
            <summary>Assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.location_unknown">
            <summary>location unknown</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_interface">
            <summary>Extract interface...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_0_to_1_will_prevent_the_debug_session_from_continuing_because_it_changes_the_shape_of_the_state_machine">
            <summary>Changing '{0}' to '{1}' will prevent the debug session from continuing because it changes the shape of the state machine.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing">
            <summary>Updating a complex statement containing an await expression will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_visibility_of_a_constructor_will_prevent_the_debug_session_from_continuing">
            <summary>Changing visibility of a constructor will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing">
            <summary>Capturing variable '{0}' that hasn't been captured before will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing">
            <summary>Ceasing to capture variable '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing">
            <summary>Deleting captured variable '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the type of a captured variable '{0}' previously of type '{1}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the parameters of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the return type of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the type of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the declaration scope of a captured variable '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing">
            <summary>Accessing captured variable '{0}' that hasn't been accessed before in {1} will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing">
            <summary>Ceasing to access captured variable '{0}' in {1} will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' that accesses captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
            <summary>Removing '{0}' that accessed captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' into a '{1}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_an_interface_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' into an interface will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_an_interface_method_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' into an interface method will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' into a class with explicit or sequential layout will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the modifiers of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the Handles clause of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' with the Handles clause will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the Implements clause of a '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing">
            <summary>Changing the constraint from '{0}' to '{1}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the variance of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the type of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the initializer of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the size of a '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the underlying type of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the base class and/or base interface(s) of '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing">
            <summary>Updating a field to an event or vice versa will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the kind of a type will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the kind of an property/event accessor will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the kind of a method (Sub/Function) will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the library name of Declare Statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
            <summary>Updating the alias of Declare Statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_0_will_prevent_the_debug_session_from_continuing">
            <summary>Renaming '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding an abstract '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a MustOverride '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_extern_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding an extern '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_imported_method_will_prevent_the_debug_session_from_continuing">
            <summary>Adding an imported method will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a user defined '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_generic_0_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a generic '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Adding '{0}' around an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Moving_0_will_prevent_the_debug_session_from_continuing">
            <summary>Moving '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_0_will_prevent_the_debug_session_from_continuing">
            <summary>Deleting '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Deleting '{0}' around an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_method_body_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a method body will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_a_method_body_will_prevent_the_debug_session_from_continuing">
            <summary>Deleting a method body will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session">
            <summary>An active statement has been removed from its original method. You must revert your changes to continue or restart the debugging session.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_a_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Updating a '{0}' around an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Updating async or iterator modifier around an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_0_from_asynchronous_to_synchronous_will_prevent_the_debug_session_from_continuing">
            <summary>Changing '{0}' from asynchronous to synchronous will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying a generic method will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying whitespace or comments in a generic '{0}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying a method inside the context of a generic type will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying whitespace or comments in '{0}' inside the context of a generic type will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying the initializer of '{0}' in a generic type will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_the_initializer_of_0_in_a_partial_type_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying the initializer of '{0}' in a partial type will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a constructor to a type with a field or property initializer that contains an anonymous function will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing">
            <summary>Renaming a captured variable, from '{0}' to '{1}' will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying a catch/finally handler with an active statement in the try block will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying a try/catch/finally statement when the finally block is active will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying a catch handler around an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying '{0}' which contains the 'stackalloc' operator will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_a_switch_expression_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying '{0}' which contains a switch expression will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying an active '{0}' which contains 'On Error' or 'Resume' statements will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying '{0}' which contains an Aggregate, Group By, or Join query clauses will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying source with experimental language features enabled will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Updating an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing">
            <summary>Removing '{0}' that contains an active statement will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_new_file_will_prevent_the_debug_session_from_continuing">
            <summary>Adding a new file will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing">
            <summary>Attribute '{0}' is missing. Updating an async method or an iterator will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unexpected_interface_member_kind_colon_0">
            <summary>Unexpected interface member kind: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown_symbol_kind">
            <summary>Unknown symbol kind</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_abstract_property_1_0">
            <summary>Generate abstract property '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_abstract_method_1_0">
            <summary>Generate abstract method '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_method_1_0">
            <summary>Generate method '{1}.{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Requested_assembly_already_loaded_from_0">
            <summary>Requested assembly already loaded from '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_symbol_does_not_have_an_icon">
            <summary>The symbol does not have an icon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_local_function">
            <summary>Extract local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_method">
            <summary>Extract method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
            <summary>Asynchronous method cannot have ref/out parameters : [{0}]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_member_is_defined_in_metadata">
            <summary>The member is defined in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
            <summary>You can only change the signature of a constructor, indexer, method or delegate.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
            <summary>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.
            
            Do you want to continue?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_signature">
            <summary>Change signature...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_new_type">
            <summary>Generate new type...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.User_Diagnostic_Analyzer_Failure">
            <summary>User Diagnostic Analyzer Failure.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Analyzer_0_threw_an_exception_of_type_1_with_message_2">
            <summary>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Analyzer_0_threw_the_following_exception_colon_1">
            <summary>Analyzer '{0}' threw the following exception:
            '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_Names">
            <summary>Simplify Names</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_Member_Access">
            <summary>Simplify Member Access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_qualification">
            <summary>Remove qualification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.This_signature_does_not_contain_parameters_that_can_be_changed">
            <summary>This signature does not contain parameters that can be changed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown_error_occurred">
            <summary>Unknown error occurred</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Available">
            <summary>Available</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Not_Available">
            <summary>Not Available</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_1">
            <summary>{0} - {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_can_use_the_navigation_bar_to_switch_context">
            <summary>You can use the navigation bar to switch context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Source">
            <summary>in Source</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Suppression_File">
            <summary>in Suppression File</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_Suppression_0">
            <summary>Remove Suppression {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_Suppression">
            <summary>Remove Suppression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_0_severity">
            <summary>Configure {0} severity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_0_code_style">
            <summary>Configure {0} code style</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_severity_for_all_0_analyzers">
            <summary>Configure severity for all '{0}' analyzers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_severity_for_all_analyzers">
            <summary>Configure severity for all analyzers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pending">
            <summary>&lt;Pending&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Awaited_task_returns_0">
            <summary>Awaited task returns '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Awaited_task_returns_no_value">
            <summary>Awaited task returns no value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Note_colon_Tab_twice_to_insert_the_0_snippet">
            <summary>Note: Tab twice to insert the '{0}' snippet.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_interface_explicitly_with_Dispose_pattern">
            <summary>Implement interface explicitly with Dispose pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_interface_with_Dispose_pattern">
            <summary>Implement interface with Dispose pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Suppress_0">
            <summary>Suppress {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Re_triage_0_currently_1">
            <summary>Re-triage {0}(currently '{1}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Argument_cannot_have_a_null_element">
            <summary>Argument cannot have a null element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Argument_cannot_be_empty">
            <summary>Argument cannot be empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer">
            <summary>Reported diagnostic with ID '{0}' is not supported by the analyzer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Computing_fix_all_occurrences_code_fix">
            <summary>Computing fix all occurrences code fix...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_all_occurrences">
            <summary>Fix all occurrences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Document">
            <summary>Document</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Project">
            <summary>Project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Solution">
            <summary>Solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.TODO_colon_dispose_managed_state_managed_objects">
            <summary>TODO: dispose managed state (managed objects)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.TODO_colon_set_large_fields_to_null">
            <summary>TODO: set large fields to null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing">
            <summary>Modifying '{0}' which contains a static variable will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Compiler2">
            <summary>Compiler</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.EditAndContinue">
            <summary>Edit and Continue</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Live">
            <summary>Live</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.namespace_">
            <summary>namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.class_">
            <summary>class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.interface_">
            <summary>interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.enum_">
            <summary>enum</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.enum_value">
            <summary>enum value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.delegate_">
            <summary>delegate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.const_field">
            <summary>const field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.method">
            <summary>method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.operator_">
            <summary>operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.constructor">
            <summary>constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.auto_property">
            <summary>auto-property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.property_">
            <summary>property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.event_">
            <summary>event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.event_accessor">
            <summary>event accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.type_constraint">
            <summary>type constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.type_parameter">
            <summary>type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.attribute">
            <summary>attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_and_1_with_property">
            <summary>Replace '{0}' and '{1}' with property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_property">
            <summary>Replace '{0}' with property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Method_referenced_implicitly">
            <summary>Method referenced implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_type_0">
            <summary>Generate type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_0_1">
            <summary>Generate {0} '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_0_to_1">
            <summary>Change '{0}' to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Non_invoked_method_cannot_be_replaced_with_property">
            <summary>Non-invoked method cannot be replaced with property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
            <summary>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Roslyn_HostError">
            <summary>Roslyn.HostError</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
            <summary>An instance of analyzer {0} cannot be created from {1}: {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_assembly_0_does_not_contain_any_analyzers">
            <summary>The assembly {0} does not contain any analyzers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unable_to_load_Analyzer_assembly_0_colon_1">
            <summary>Unable to load Analyzer assembly {0}: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Make_method_synchronous">
            <summary>Make method synchronous</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.from_0">
            <summary>from {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Find_and_install_latest_version">
            <summary>Find and install latest version</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_local_version_0">
            <summary>Use local version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_locally_installed_0_version_1_This_version_used_in_colon_2">
            <summary>Use locally installed '{0}' version '{1}'
            This version used in: {2}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Find_and_install_latest_version_of_0">
            <summary>Find and install latest version of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_with_package_manager">
            <summary>Install with package manager...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_0_1">
            <summary>Install '{0} {1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_version_0">
            <summary>Install version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_variable_0">
            <summary>Generate variable '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Classes">
            <summary>Classes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Constants">
            <summary>Constants</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Delegates">
            <summary>Delegates</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Enums">
            <summary>Enums</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Events">
            <summary>Events</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extension_methods">
            <summary>Extension methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fields">
            <summary>Fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Interfaces">
            <summary>Interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Locals">
            <summary>Locals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Methods">
            <summary>Methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modules">
            <summary>Modules</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Namespaces">
            <summary>Namespaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Properties">
            <summary>Properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Structures">
            <summary>Structures</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Parameters_colon">
            <summary>Parameters:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
            <summary>Variadic SignatureHelpItem must have at least one parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_method">
            <summary>Replace '{0}' with method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_methods">
            <summary>Replace '{0}' with methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_referenced_implicitly">
            <summary>Property referenced implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_cannot_safely_be_replaced_with_a_method_call">
            <summary>Property cannot safely be replaced with a method call</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_interpolated_string">
            <summary>Convert to interpolated string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_type_to_0">
            <summary>Move type to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Rename_file_to_0">
            <summary>Rename file to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Rename_type_to_0">
            <summary>Rename type to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_tag">
            <summary>Remove tag</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_missing_param_nodes">
            <summary>Add missing param nodes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Make_containing_scope_async">
            <summary>Make containing scope async</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Make_containing_scope_async_return_Task">
            <summary>Make containing scope async (return Task)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.paren_Unknown_paren">
            <summary>(Unknown)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_abstract_class">
            <summary>Implement abstract class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_framework_type">
            <summary>Use framework type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_package_0">
            <summary>Install package '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.project_0">
            <summary>project {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Inline_variable_declaration">
            <summary>Inline variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_interpolated_verbatim_string">
            <summary>Use interpolated verbatim string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_typo_0">
            <summary>Fix typo '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fully_qualify_0">
            <summary>Fully qualify '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_reference_to_0">
            <summary>Remove reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Keywords">
            <summary>Keywords</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Snippets">
            <summary>Snippets</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.All_lowercase">
            <summary>All lowercase</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.All_uppercase">
            <summary>All uppercase</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.First_word_capitalized">
            <summary>First word capitalized</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pascal_Case">
            <summary>Pascal Case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Variable_declaration_can_be_inlined">
            <summary>Variable declaration can be inlined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_document_0">
            <summary>Remove document '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_document_0">
            <summary>Add document '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_argument_name_0">
            <summary>Add argument name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_tuple_element_name_0">
            <summary>Add tuple element name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Take_0">
            <summary>Take '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Take_both">
            <summary>Take both</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Take_bottom">
            <summary>Take bottom</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Take_top">
            <summary>Take top</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unused_variable">
            <summary>Remove unused variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_binary">
            <summary>Convert to binary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_decimal">
            <summary>Convert to decimal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_hex">
            <summary>Convert to hex</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_thousands">
            <summary>Separate thousands</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_words">
            <summary>Separate words</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_nibbles">
            <summary>Separate nibbles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_separators">
            <summary>Remove separators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameter_to_0">
            <summary>Add parameter to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameter_to_0_and_overrides_implementations">
            <summary>Add parameter to '{0}' (and overrides/implementations)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_to_0">
            <summary>Add to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Related_method_signatures_found_in_metadata_will_not_be_updated">
            <summary>Related method signatures found in metadata will not be updated.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constructor">
            <summary>Generate constructor...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_be_used_as_constructor_parameters">
            <summary>Pick members to be used as constructor parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_be_used_in_Equals_GetHashCode">
            <summary>Pick members to be used in Equals/GetHashCode</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_overrides">
            <summary>Generate overrides...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_override">
            <summary>Pick members to override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_check">
            <summary>Add null check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_string_IsNullOrEmpty_check">
            <summary>Add 'string.IsNullOrEmpty' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_string_IsNullOrWhiteSpace_check">
            <summary>Add 'string.IsNullOrWhiteSpace' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_initialize_field_0">
            <summary>Create and initialize field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_initialize_property_0">
            <summary>Create and initialize property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Initialize_field_0">
            <summary>Initialize field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Initialize_property_0">
            <summary>Initialize property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_checks">
            <summary>Add null checks</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_operators">
            <summary>Generate operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0">
            <summary>Implement {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_inferred_member_name">
            <summary>Use inferred member name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Member_name_can_be_simplified">
            <summary>Member name can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
            <summary>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
            <summary>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_0_project_1">
            <summary>in {0} (project {1})</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_accessibility_modifiers">
            <summary>Add accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_local_function">
            <summary>Use local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_declaration_near_reference">
            <summary>Move declaration near reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_full_property">
            <summary>Convert to full property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constructor_in_0_without_fields">
            <summary>Generate constructor in '{0}' (without fields)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_Method_overrides_symbol_from_metadata">
            <summary>Warning: Method overrides symbol from metadata</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_0">
            <summary>Use {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing">
            <summary>Switching between a lambda and a local function will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_argument_name_0_including_trailing_arguments">
            <summary>Add argument name '{0}' (including trailing arguments)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_function">
            <summary>local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.indexer_">
            <summary>indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Alias_ambiguous_type_0">
            <summary>Alias ambiguous type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_Collection_was_modified_during_iteration">
            <summary>Warning: Collection was modified during iteration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_Iteration_variable_crossed_function_boundary">
            <summary>Warning: Iteration variable crossed function boundary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_Collection_may_be_modified_during_iteration">
            <summary>Warning: Collection may be modified during iteration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_linq">
            <summary>Convert to LINQ</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_class">
            <summary>Convert to class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_struct">
            <summary>Convert to struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_member">
            <summary>updating usages in containing member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_project">
            <summary>updating usages in containing project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_type">
            <summary>updating usages in containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_dependent_projects">
            <summary>updating usages in dependent projects</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Formatting_document">
            <summary>Formatting document</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_member_name">
            <summary>Add member name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_block_body_for_lambda_expressions">
            <summary>Use block body for lambda expressions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_expression_body_for_lambda_expressions">
            <summary>Use expression body for lambda expressions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_linq_call_form">
            <summary>Convert to LINQ (call form)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing">
            <summary>Adding a method with an explicit interface specifier will prevent the debug session from continuing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error">
            <summary>Modifying source file {0} will prevent the debug session from continuing due to internal error: {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_namespace_to_0">
            <summary>Change namespace to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_file_to_0">
            <summary>Move file to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_file_to_project_root_folder">
            <summary>Move file to project root folder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_to_namespace">
            <summary>Move to namespace...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_to_global_namespace">
            <summary>Change to global namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
            <summary>Warning: Changing namespace may produce invalid code and change code meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invert_conditional">
            <summary>Invert conditional</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_1">
            <summary>Replace '{0}' with '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Align_wrapped_parameters">
            <summary>Align wrapped parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_all_parameters">
            <summary>Indent all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_wrapped_parameters">
            <summary>Indent wrapped parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_all_parameters">
            <summary>Unwrap all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_and_indent_all_parameters">
            <summary>Unwrap and indent all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_every_parameter">
            <summary>Wrap every parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_parameter_list">
            <summary>Wrap long parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_parameter_list">
            <summary>Unwrap parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Align_wrapped_arguments">
            <summary>Align wrapped arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_all_arguments">
            <summary>Indent all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_wrapped_arguments">
            <summary>Indent wrapped arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_all_arguments">
            <summary>Unwrap all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_and_indent_all_arguments">
            <summary>Unwrap and indent all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_every_argument">
            <summary>Wrap every argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_argument_list">
            <summary>Wrap long argument list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_argument_list">
            <summary>Unwrap argument list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant">
            <summary>Introduce constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field">
            <summary>Introduce field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local">
            <summary>Introduce local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable">
            <summary>Introduce query variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Failed_to_analyze_data_flow_for_0">
            <summary>Failed to analyze data-flow for: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_formatting">
            <summary>Fix formatting</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Split_into_nested_0_statements">
            <summary>Split into nested '{0}' statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_outer_0_statement">
            <summary>Merge with outer '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Split_into_consecutive_0_statements">
            <summary>Split into consecutive '{0}' statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_previous_0_statement">
            <summary>Merge with previous '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_expression">
            <summary>Unwrap expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_expression">
            <summary>Wrap expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrapping">
            <summary>Wrapping</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_nested_0_statement">
            <summary>Merge with nested '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_next_0_statement">
            <summary>Merge with next '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_0_up">
            <summary>Pull '{0}' up</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_members_up_to_base_type">
            <summary>Pull members up to base type...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_call_chain">
            <summary>Unwrap call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_call_chain">
            <summary>Wrap call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_call_chain">
            <summary>Wrap long call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_0_up_to_1">
            <summary>Pull '{0}' up to '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_expression">
            <summary>Wrap and align expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_contents_to_namespace">
            <summary>Move contents to namespace...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_optional_parameter_to_constructor">
            <summary>Add optional parameter to constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameter_to_constructor">
            <summary>Add parameter to constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Target_type_matches">
            <summary>Target type matches</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_parameter_0">
            <summary>Generate parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_parameter_0_and_overrides_implementations">
            <summary>Generate parameter '{0}' (and overrides/implementations)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Source_attribute">
            <summary>in Source (attribute)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.StreamMustSupportReadAndSeek">
            <summary>Stream must support read and seek operations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.MethodMustReturnStreamThatSupportsReadAndSeek">
            <summary>{0} must return a stream that supports read and seek operations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.RudeEdit">
            <summary>Rude edit</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.EditAndContinueDisallowedByModule">
            <summary>Edit and Continue disallowed by module</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.CannotApplyChangesUnexpectedError">
            <summary>Cannot apply changes -- unexpected error: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ErrorReadingFile">
            <summary>Error while reading file '{0}': {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.EditAndContinueDisallowedByProject">
            <summary>Changes made in project '{0}' will prevent the debug session from continuing: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangesNotAppliedWhileRunning">
            <summary>Changes made in project '{0}' will not be applied while the application is running</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.DocumentIsOutOfSyncWithDebuggee">
            <summary>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.UnableToReadSourceFileOrPdb">
            <summary>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangesDisallowedWhileStoppedAtException">
            <summary>Changes are not allowed while stopped at exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Dispose_objects_before_losing_scope">
            <summary>Dispose objects before losing scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Disposable_object_created_by_0_is_never_disposed">
            <summary>Disposable object created by '{0}' is never disposed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_recommended_dispose_pattern">
            <summary>Use recommended dispose pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_recommended_dispose_pattern_to_ensure_that_object_created_by_0_is_disposed_on_all_paths_using_statement_declaration_or_try_finally">
            <summary>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths: using statement/declaration or try/finally</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.UseRecommendedDisposePatternDescription">
            <summary>Use recommended dispose pattern to ensure that locally scoped disposable objects are disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local var ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Disposable_fields_should_be_disposed">
            <summary>Disposable fields should be disposed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Disposable_field_0_is_never_disposed">
            <summary>Disposable field '{0}' is never disposed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.DisposableFieldsShouldBeDisposedDescription">
            <summary>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_call_chain">
            <summary>Wrap and align call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_long_call_chain">
            <summary>Wrap and align long call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_semantics_may_change_when_converting_statement">
            <summary>Warning: Semantics may change when converting statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_checks_for_all_parameters">
            <summary>Add null checks for all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0_implicitly">
            <summary>Implement '{0}' implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_all_interfaces_implicitly">
            <summary>Implement all interfaces implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_implicitly">
            <summary>Implement implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0_explicitly">
            <summary>Implement '{0}' explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Interpolation_can_be_simplified">
            <summary>Interpolation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_interpolation">
            <summary>Simplify interpolation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Make_member_static">
            <summary>Make static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Value_colon">
            <summary>Value:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_through_0">
            <summary>Implement through '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_all_interfaces_explicitly">
            <summary>Implement all interfaces explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_explicitly">
            <summary>Implement explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Resolve_conflict_markers">
            <summary>Resolve conflict markers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Base_classes_contain_inaccessible_unimplemented_members">
            <summary>Base classes contain inaccessible unimplemented members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Do_not_change_this_code_Put_cleanup_code_in_0_method">
            <summary>Do not change this code. Put cleanup code in '{0}' method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer">
            <summary>TODO: free unmanaged resources (unmanaged objects) and override finalizer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources">
            <summary>TODO: override finalizer only if '{0}' has code to free unmanaged resources</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_conditional_expression">
            <summary>Simplify conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Conditional_expression_can_be_simplified">
            <summary>Conditional expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_remaining_members_explicitly">
            <summary>Implement remaining members explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_Unnecessary_Cast">
            <summary>Remove Unnecessary Cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_member">
            <summary>Remove unused member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_is_unused">
            <summary>Private member '{0}' is unused.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_private_members">
            <summary>Remove unused private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unread_private_members">
            <summary>Remove unread private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read">
            <summary>Private member '{0}' can be removed as the value assigned to it is never read.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_method_0_can_be_removed_as_it_is_never_invoked">
            <summary>Private method '{0}' can be removed as it is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked">
            <summary>Private property '{0}' can be converted to a method as its get accessor is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_is_missing_a_required_header">
            <summary>A source file is missing a required header.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_is_missing_or_not_located_at_the_top_of_the_file">
            <summary>The file header is missing or not located at the top of the file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_contains_a_header_that_does_not_match_the_required_text">
            <summary>A source file contains a header that does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_does_not_match_the_required_text">
            <summary>The file header does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_throw_expression">
            <summary>Use 'throw' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_this_or_Me_qualification">
            <summary>Add 'this' or 'Me' qualification.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Member_access_should_be_qualified">
            <summary>Member access should be qualified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Null_check_can_be_simplified">
            <summary>Null check can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_collection_initialization">
            <summary>Simplify collection initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Collection_initialization_can_be_simplified">
            <summary>Collection initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_object_initialization">
            <summary>Simplify object initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Object_initialization_can_be_simplified">
            <summary>Object initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_readonly_modifier">
            <summary>Add readonly modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Make_field_readonly">
            <summary>Make field readonly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_rule_violation_0">
            <summary>Naming rule violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_Styles">
            <summary>Naming Styles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_missing_cases">
            <summary>Add missing cases</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Populate_switch">
            <summary>Populate switch</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Modifiers_are_not_ordered">
            <summary>Modifiers are not ordered</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Order_modifiers">
            <summary>Order modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Expression_value_is_never_used">
            <summary>Expression value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value_to_0">
            <summary>Unnecessary assignment of a value to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value">
            <summary>Unnecessary assignment of a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc">
            <summary>Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name sta ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter">
            <summary>Remove unused parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0">
            <summary>Remove unused parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names">
            <summary>Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API">
            <summary>Remove unused parameter '{0}' if it is not part of a shipped public API</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed if it is not part of a shipped public API; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_accessibility_modifiers">
            <summary>Add accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Accessibility_modifiers_required">
            <summary>Accessibility modifiers required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Convert_to_conditional_expression">
            <summary>Convert to conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_coalesce_expression">
            <summary>Use coalesce expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime">
            <summary>Changes to expression trees may result in behavior changes at runtime</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_can_be_removed">
            <summary>Parentheses can be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unnecessary_parentheses">
            <summary>Remove unnecessary parentheses</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_parentheses_for_clarity">
            <summary>Add parentheses for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_should_be_added_for_clarity">
            <summary>Parentheses should be added for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Prefer_explicitly_provided_tuple_element_name">
            <summary>Prefer explicitly provided tuple element name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_explicitly_provided_tuple_name">
            <summary>Use explicitly provided tuple name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_System_HashCode">
            <summary>Use 'System.HashCode'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.GetHashCode_implementation_can_be_simplified">
            <summary>'GetHashCode' implementation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_compound_assignment">
            <summary>Use compound assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_null_propagation">
            <summary>Use null propagation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_auto_property">
            <summary>Use auto property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Format_string_contains_invalid_placeholder">
            <summary>Format string contains invalid placeholder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_format_string">
            <summary>Invalid format string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Convert_to_tuple">
            <summary>Convert to tuple</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_file_banner">
            <summary>Add file banner</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Fix_Name_Violation_colon_0">
            <summary>Fix Name Violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_both">
            <summary>Add both</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_default_case">
            <summary>Add default case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discarded_local">
            <summary>Use discarded local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discard_underscore">
            <summary>Use discard '_'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_redundant_assignment">
            <summary>Remove redundant assignment</summary>
        </member>
    </members>
</doc>
