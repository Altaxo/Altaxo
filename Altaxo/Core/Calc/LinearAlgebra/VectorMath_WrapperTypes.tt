<#@ template language="C#" #>
<#@ output extension="autogenerated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="VectorMath_Header.ttinclude" #>

// ******************************************* Unary functions not returning a vector, valid for all non-null vector types  ********************

<# 


    var types = new string[][]
    {      // scalar,   array                   rwArray            Length    negInfinity                 posInfinity                upCast    typeAbs
		       // ---------------------------------------------------------------------------------------------------------------------------
      new[]{ "double", "Double", "IReadOnlyList<double>", "IVector<double>", "Count",  "double.NegativeInfinity",	"double.PositiveInfinity",	"",				"double" },
      new[]{ "float",	 "Float",  "IReadOnlyList<float>",  "IVector<float>",  "Count", "float.NegativeInfinity",    "float.PositiveInfinity",		"",				"float" },
      new[]{ "int",	   "Int",  "IReadOnlyList<int>",  "IVector<int>",  "Count", "int.MinValue",    "int.MaxValue",		"",				"int" },
    };

    foreach (var entry in types)
    {
      var scalT =  entry[0]; // scalar type
			var bigScalT = entry[1]; // scalar type, capital
      var arrT =   entry[2]; // array type
      var rwArrT = entry[3]; // array type
			var length = entry[4]; // Length property
      var negInf = entry[5]; // negative Infinity
      var posInf = entry[6]; // positive Infinity
			var upCast = entry[7]; // up-cast to next bigger number
			var typeAbs = entry[8]; // type for absolute values

// ----------- Begin of code after next line --------------------------------------------------------------------
#>
// ******************************************** Definitions for <#= arrT #> *******************************************

    /// <summary>
		/// Provides a read-only vector with equal and constant items.
		/// </summary>
		private class RO<#= bigScalT #>ConstantVector : IROVector<<#= scalT #>>
		{
			private int _length;
			private <#= scalT #> _value;

			public RO<#= bigScalT #>ConstantVector(<#= scalT #> value, int length)
			{
				_length = length;
				_value = value;
			}

			public int Length
			{
				get { return _length; }
			}

      public int Count
      {
        get { return _length; }
      }

      public <#= scalT #> this[int i]
			{
				get { return _value; }
			}

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return _value;
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return _value;
      }
    }


		  /// <summary>
    /// Provides a read-only vector with equally spaced elements y[i] = start + i * increment.
    /// </summary>
    private class RO<#= bigScalT #>EquallySpacedVector : IROVector<<#= scalT #>>
    {
      private int _length;
      private <#= scalT #> _startValue;
      private <#= scalT #> _incrementValue;

      public RO<#= bigScalT #>EquallySpacedVector(<#= scalT #> start, <#= scalT #> increment, int length)
      {
        _length = length;
        _startValue = start;
        _incrementValue = increment;
      }

      public int Length
      {
        get { return _length; }
      }

      public int Count
      {
        get { return _length; }
      }

      public <#= scalT #> this[int i]
      {
        get { return _startValue + i * _incrementValue; }
      }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }


		/// <summary>
    /// Serves as wrapper for an array to plug-in where a IROVector is neccessary.
    /// </summary>
    private class RO<#= bigScalT #>ArrayWrapper : IROVector<<#= scalT #>>
    {
      private int _length;
      protected <#= scalT #>[] _x;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
      public RO<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x)
      {
        _length = _x.Length;
        _x = x;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RO<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x, int usedlength)
      {
        if (usedlength > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get
        {
          return _x[i];
        }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get
        {
          return _length;
        }
      } 

     /// <summary>The number of elements of this vector.</summary>
     public int Count
      {
        get
        {
          return _length;
        }
      }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }


		  /// <summary>
    /// Serves as wrapper for a section of an array to plug-in where an IROVector is neccessary.
    /// </summary>
    private class RO<#= bigScalT #>ArraySectionWrapper : IROVector<<#= scalT #>>
    {
      protected <#= scalT #>[] _x;
      protected int _start;
      protected int _length;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      public RO<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x)
      {
        _length = _x.Length;
        _start = 0;
        _x = x;
      }

      /// <summary>
      /// Constructor, takes a double array, and start and length of the section, for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap.</param>
      /// <param name="start">Index of the element in <paramref name="x"/> used as the first element of the vector.</param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RO<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x, int start, int usedlength)
      {
        if (start < 0)
          throw new ArgumentException("start is negative");
        if (usedlength < 0)
          throw new ArgumentException("usedlength is negative");

        if ((start + usedlength) > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _x = x;
        _start = start;
        _length = usedlength;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i] { get { return _x[i + _start]; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      /// <summary>
      /// Returns an enumerator that iterates through the elements of the vector.
      /// </summary>
      /// <returns>
      /// An enumerator that can be used to iterate through the elements of the vector.
      /// </returns>
      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }


		/// <summary>
    /// Serves as wrapper for an array to plug-in where a IVector is neccessary.
    /// </summary>
		private class RW<#= bigScalT #>ArrayWrapper : RO<#= bigScalT #>ArrayWrapper, IVector<<#= scalT #>>
    {
      public RW<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x)
        : base(x)
      {
      }

      public RW<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x, int usedlength)
        : base(x, usedlength)
      {
      }

      public new <#= scalT #> this[int i]
      {
        get { return _x[i]; }
        set { _x[i] = value; }
      }
    }

		private class RW<#= bigScalT #>ArraySectionWrapper : RO<#= bigScalT #>ArraySectionWrapper, IVector<<#= scalT #>>
    {
      public RW<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x)
        : base(x)
      {
      }

      public RW<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x, int start, int usedlength)
        : base(x, start, usedlength)
      {
      }

      public new <#= scalT #> this[int i]
      {
        get { return _x[i + _start]; }
        set { _x[i + _start] = value; }
      }
    }


		 /// <summary>
    /// Serves as wrapper for an IROVector to get only a section of the original wrapper.
    /// </summary>
    private class RO<#= bigScalT #>VectorSectionWrapper : IROVector<<#= scalT #>>
    {
      protected IReadOnlyList<<#= scalT #>> _x;
      private int _start;
      private int _length;


		 /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The vector to wrap.</param>
      /// <param name="start">Start index of the section of the vector to wrap.</param>
      /// <param name="len">Length of the section to wrap.</param>
      public RO<#= bigScalT #>VectorSectionWrapper(IReadOnlyList<<#= scalT #>> x, int start, int len)
      {
        if (start >= x.Count)
          throw new ArgumentException("Start of the section is beyond length of the vector");
        if (start + len > x.Count)
          throw new ArgumentException("End of the section is beyond length of the vector");

        _x = x;
        _start = start;
        _length = len;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i] { get { return _x[i + _start]; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for(int i = 0; i < _length; ++i)
					yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for(int i = 0; i < _length; ++i)
					yield return this[i];
      }
    }


		  /// <summary>
    /// Serves as wrapper for an IVector to get only a section of the original wrapper.
    /// </summary>
    private class RW<#= bigScalT #>VectorSectionWrapper : IVector<<#= scalT #>>
    {
      protected IVector<<#= scalT #>> _x;
      private int _start;
      private int _length;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="start">Start index of the section to wrap.</param>
      /// <param name="len">Length of the section to wrap.</param>
      public RW<#= bigScalT #>VectorSectionWrapper(IVector<<#= scalT #>> x, int start, int len)
      {
        if (start >= x.Length)
          throw new ArgumentException("Start of the section is beyond length of the vector");
        if (start + len >= x.Length)
          throw new ArgumentException("End of the section is beyond length of the vector");

        _x = x;
        _start = start;
        _length = len;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get { return _x[i + _start]; }
        set { _x[i + _start] = value; }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }

<# 
// ----------- End of code before previous line --------------------------------------------------------------------
    }
#>
<#@ include file="VectorMath_Footer.ttinclude" #>
