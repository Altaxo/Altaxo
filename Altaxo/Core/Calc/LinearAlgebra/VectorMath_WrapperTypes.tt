<#@ template language="C#" #>
<#@ output extension="generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="VectorMath_Header.ttinclude" #>

// ******************************************* Unary functions not returning a vector, valid for all non-null vector types  ********************

<# 


    var types = new string[][]
    {      // scalar,   Name      roType              rwType            inverseElementType
		       // ---------------------------------------------------------------------------------------------------------------------------
      new[]{ "Double", "Double", "IROVector<Double>", "IVector<Double>", "Double" },
      new[]{ "Single", "Float",  "IROVector<Single>", "IVector<Single>", "Single" },
      new[]{ "Int32",	 "Int",    "IROVector<Int32>",  "IVector<Int32>",  "Double"  },
      new[]{ "Int16",	 "Short",  "IROVector<Int16>",  "IVector<Int16>",  "Double" },
      new[]{ "SByte",	 "SByte",  "IROVector<SByte>",  "IVector<SByte>",  "Double" },
    };

    foreach (var entry in types)
    {
      var scalT =  entry[0]; // scalar type
			var bigScalT = entry[1]; // scalar type, capital, for naming of the wrapping type
			var roVecT = entry[2]; // read-only vector type
			var rwVecT = entry[3]; // read-write vector type
			var inverseEleT = entry[4]; // type of the inverse of an element

			/*
			var arrT =   entry[2]; // array type
      var rwArrT = entry[3]; // array type
			var length = entry[4]; // Length property
      var negInf = entry[5]; // negative Infinity
      var posInf = entry[6]; // positive Infinity
			var upCast = entry[7]; // up-cast to next bigger number
			var typeAbs = entry[8]; // type for absolute values
			*/

// ----------- Begin of code after next line --------------------------------------------------------------------
#>
// ******************************************** Definitions for <#= scalT #> *******************************************

    /// <summary>
		/// Provides a read-only vector with equal and constant items.
		/// </summary>
		private class RO<#= bigScalT #>ConstantVector : <#= roVecT #>
		{
			private int _length;
			private <#= scalT #> _value;

			public RO<#= bigScalT #>ConstantVector(<#= scalT #> value, int length)
			{
				_length = length;
				_value = value;
			}

			public int Length
			{
				get { return _length; }
			}

      public int Count
      {
        get { return _length; }
      }

      public <#= scalT #> this[int i]
			{
				get { return _value; }
			}

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return _value;
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return _value;
      }
    }

			/// <summary>
		/// Gets a vector with all elements equal to a provided value.
		/// </summary>
		/// <param name="value">Value of all elements.</param>
		/// <param name="length">Length of the vector.</param>
		/// <returns>Read-only vector with all elements equal to the provided <paramref name="value"/>.</returns>
		public static <#= roVecT #> GetConstantVector(<#= scalT #> value, int length)
		{
			return new RO<#= bigScalT #>ConstantVector(value, length);
		}


		/// <summary>
    /// Provides a read-only vector with equally spaced elements y[i] = start + i * increment.
    /// </summary>
    private class RO<#= bigScalT #>EquidistantElementVector : <#= roVecT #>
    {
      private int _length;
      private <#= scalT #> _startValue;
      private <#= scalT #> _incrementValue;

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="start">Value of the first element of the vector.</param>
			/// <param name="increment">Difference between an element of the vector and the previous element.</param>
			/// <param name="length">Length of the vector.</param>
      public RO<#= bigScalT #>EquidistantElementVector(<#= scalT #> start, <#= scalT #> increment, int length)
      {
        _length = length;
        _startValue = start;
        _incrementValue = increment;
      }

			/// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get { return _length; }
      }

      	/// <summary>The number of elements of this vector.</summary>
			public int Count
      {
        get { return _length; }
      }

			/// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
			/// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get { return (<#= scalT #>)(_startValue + i * _incrementValue); }
      }

			/// <summary>
			/// Enumerates all elements of the vector.
			/// </summary>
			/// <returns>Enumerator that enumerates all elements of the vector.</returns>
      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

			/// <summary>
			/// Enumerates all elements of the vector.
			/// </summary>
			/// <returns>Enumerator that enumerates all elements of the vector.</returns>
      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }


			/// <summary>
		/// Creates a read-only vector with equidistant elements with values from start to start+(length-1)*step. The created vector
		/// consumes memory only for the three variables, independent of its length.
		/// </summary>
		/// <param name="start">First element of the vector.</param>
		/// <param name="step">Difference between two successive elements.</param>
		/// <param name="length">Length of the vector.</param>
		/// <returns>Read-only vector with equidistant elements with values from start to start+(length-1)*step.</returns>
		public static <#= roVecT #> CreateEquidistantSequenceByStartStepLength(<#= scalT #> start, <#= scalT #> step, int length)
		{
			return new RO<#= bigScalT #>EquidistantElementVector(start, step, length);
		}

			
			/// <summary>
		/// Provides a read-only vector with equally spaced elements y[i] = start + (i-startOffset) * increment.
		/// </summary>
		private class RO<#= bigScalT #>EquidistantElementVectorStartAtOffsetStepLength : <#= roVecT #>
		{
			private <#= scalT #> _start;
			private int _startOffset;

			private <#= scalT #> _increment;
			private int _length;

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="start">Value of the element at index <paramref name="startOffset"/> of the vector.</param>
			/// <param name="startOffset">The index of the element for which a value is provided in <paramref name="start"/>.</param>
			/// <param name="increment">Difference between an element of the vector and the previous element.</param>
			/// <param name="length">Length of the vector.</param>
			public RO<#= bigScalT #>EquidistantElementVectorStartAtOffsetStepLength(<#= scalT #> start, int startOffset, <#= scalT #> increment, int length)
			{
				_start = start;
				_startOffset = startOffset;
				_increment = increment;
				_length = length;
			}

			/// <summary>The number of elements of this vector.</summary>
			public int Length
			{
				get { return _length; }
			}

			/// <summary>The number of elements of this vector.</summary>
			public int Count
			{
				get { return _length; }
			}

			/// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
			/// <value>The element at index i.</value>
			public <#= scalT #> this[int i]
			{
				get
				{
					if (i < 0 || i >= _length)
						throw new ArgumentOutOfRangeException("i");
					return (<#= scalT #>)(_start + (i - _startOffset) * _increment);
				}
			}

			/// <summary>
			/// Enumerates all elements of the vector.
			/// </summary>
			/// <returns>Enumerator that enumerates all elements of the vector.</returns>
			public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i<_length; ++i)
          yield return this[i];
      }

		/// <summary>
		/// Enumerates all elements of the vector.
		/// </summary>
		/// <returns>Enumerator that enumerates all elements of the vector.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			for (int i = 0; i < _length; ++i)
				yield return this[i];
		}
	}

		/// <summary>
		/// Creates a read-only vector with equidistant elements from start - startOffset*step to start + (length - 1 -startOffset)*step. The created vector
		/// consumes memory only for the three variables, independent of its length.
		/// </summary>
		/// <param name="start">Value of the element of the vector at index <paramref name="startOffset"/>).</param>
		/// <param name="startOffset">Index of the element of the vector which gets the value of <paramref name="start"/>.</param>
		/// <param name="step">Difference between two successive elements.</param>
		/// <param name="length">Length of the vector.</param>
		/// <returns>Read-only vector with equidistant elements from start - startOffset*step to start + (length - 1 -startOffset)*step.</returns>
		public static <#= roVecT #> CreateEquidistantSequencyByStartAtOffsetStepLength(<#= scalT #> start, int startOffset, <#= scalT #> step, int length)
		{
			return new RO<#= bigScalT #>EquidistantElementVectorStartAtOffsetStepLength(start, startOffset, step, length);
		}


	  	/// <summary>
		/// Provides a read-only vector with equally spaced elements so that y[0] = start and y[length-1] = end.
		/// </summary>
		private class RO<#= bigScalT #>EquidistantElementVectorStartEndLength : <#= roVecT #>
		{
			private <#= scalT #> _start;
			private <#= scalT #> _end;
			private int _length;

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="start">Value of the first element of the vector.</param>
			/// <param name="end">Value of the last element of the vector.</param>
			/// <param name="length">Length of the vector.</param>
			public RO<#= bigScalT #>EquidistantElementVectorStartEndLength(<#= scalT #> start, <#= scalT #> end, int length)
			{
				_start = start;
				_end = end;
				_length = length;
			}

			/// <summary>The number of elements of this vector.</summary>
			public int Length
			{
				get { return _length; }
			}

			/// <summary>The number of elements of this vector.</summary>
			public int Count
			{
				get { return _length; }
			}

			/// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
			/// <value>The element at index i.</value>
			public <#= scalT #> this[int i]
			{
				get
				{
					if (i < 0 || i >= _length)
						throw new ArgumentOutOfRangeException("i");

					double r = i / (double)(_length - 1);
					return (<#= scalT #>)(_start * (1 - r) + _end * (r));
				}
			}

			/// <summary>
			/// Enumerates all elements of the vector.
			/// </summary>
			/// <returns>Enumerator that enumerates all elements of the vector.</returns>
			public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i<_length; ++i)
          yield return this[i];
      }

			/// <summary>
			/// Enumerates all elements of the vector.
			/// </summary>
			/// <returns>Enumerator that enumerates all elements of the vector.</returns>
			IEnumerator IEnumerable.GetEnumerator()
			{
				for (int i = 0; i < _length; ++i)
					yield return this[i];
			}
		}

		/// <summary>
		/// Creates a read-only vector with equidistant element values from start to end. The created vector
		/// consumes memory only for the three variables, independent of its length.
		/// </summary>
		/// <param name="start">First element of the vector.</param>
		/// <param name="end">Last element of the vector.</param>
		/// <param name="length">Length of the vector.</param>
		/// <returns>Read-only vector with equidistant element values from start to end.</returns>
		public static <#= roVecT #> CreateEquidistantSequenceByStartEndLength(<#= scalT #> start, <#= scalT #> end, int length)
		{
			return new RO<#= bigScalT #>EquidistantElementVectorStartEndLength(start, end, length);
		}


		/// <summary>
    /// Serves as wrapper for an RO Vector which returns the inverse of the elements of the original array.
    /// </summary>
    private class RO<#= bigScalT #>InverseElementWrapper : IROVector<<#= inverseEleT #>>
    {
      private int _length;
      protected IReadOnlyList<<#= scalT #>> _x;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
      public RO<#= bigScalT #>InverseElementWrapper(IReadOnlyList<<#= scalT #>> x)
      {
        _x = x;
        _length = x.Count;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RO<#= bigScalT #>InverseElementWrapper(IReadOnlyList<<#= scalT #>> x, int usedlength)
      {
        if (usedlength > x.Count)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= inverseEleT #> this[int i]
      {
        get
        {
          return 1/(<#= inverseEleT #>)_x[i];
        }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get
        {
          return _length;
        }
      } 

     /// <summary>The number of elements of this vector.</summary>
     public int Count
      {
        get
        {
          return _length;
        }
      }

      public IEnumerator<<#= inverseEleT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }

		/// <summary>
		/// Wraps a <#= scalT #>[] array to get an  <see cref="IROVector{<#= scalT #>}" /> with elements = 1 / elements of the original vector.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> returning elements that are inverse to those of the original vector.</returns>
		public static IROVector<<#= inverseEleT #>> ToInverseROVector(this IReadOnlyList<<#= scalT #>> array)
		{
			return array is null ? null : new RO<#= bigScalT #>InverseElementWrapper(array);
		}

		/// <summary>
		/// Wraps a <#= scalT #>[] array till a given length to get an <see cref="IROVector{<#= scalT #>}" /> with elements = 1 / elements of the original vector.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array returning elements that are inverse to those of the original vector..</returns>
		public static IROVector<<#= inverseEleT #>> ToInverseROVector(this IReadOnlyList<<#= scalT #>> array, int usedlength)
		{
			return new RO<#= bigScalT #>InverseElementWrapper(array, usedlength);
		}


		/// <summary>
    /// Serves as wrapper for an array to plug-in where an <see cref="IROVector{<#= scalT #>}" /> is neccessary.
    /// </summary>
    private class RO<#= bigScalT #>ArrayWrapper : <#= roVecT #>
    {
      private int _length;
      protected <#= scalT #>[] _x;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
      public RO<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x)
      {
        _length = x.Length;
        _x = x;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RO<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x, int usedlength)
      {
        if (usedlength > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get
        {
          return _x[i];
        }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get
        {
          return _length;
        }
      } 

     /// <summary>The number of elements of this vector.</summary>
     public int Count
      {
        get
        {
          return _length;
        }
      }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }

		/// <summary>
		/// Wraps a <#= scalT #>[] array to get an <see cref="IROVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= roVecT #> ToROVector(this <#= scalT #>[] array)
		{
			return array is null ? null : new RO<#= bigScalT #>ArrayWrapper(array);
		}

		/// <summary>
		/// Wraps a <#= scalT #>[] array till a given length to get an <see cref="IROVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= roVecT #> ToROVector(this <#= scalT #>[] array, int usedlength)
		{
			return new RO<#= bigScalT #>ArrayWrapper(array, usedlength);
		}

			/// <summary>
    /// Serves as wrapper for an array to plug-in where an <see cref="IROVector{<#= scalT #>}" /> is neccessary.
    /// </summary>
    private class RODouble_<#= bigScalT #>ArrayWrapper : IROVector<Double>
    {
      private int _length;
      protected <#= scalT #>[] _x;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
      public RODouble_<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x)
      {
        _length = x.Length;
        _x = x;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RODouble_<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x, int usedlength)
      {
        if (usedlength > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public double this[int i]
      {
        get
        {
          return _x[i];
        }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get
        {
          return _length;
        }
      } 

     /// <summary>The number of elements of this vector.</summary>
     public int Count
      {
        get
        {
          return _length;
        }
      }

      public IEnumerator<double> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return (double)this[i];
      }
    }

		/// <summary>
		/// Wraps a <#= scalT #>[] array to get an <see cref="IROVector{Double}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static IROVector<Double> ToRODoubleVector(this <#= scalT #>[] array)
		{
			return array is null ? null : new RODouble_<#= bigScalT #>ArrayWrapper(array);
		}

		/// <summary>
		/// Wraps a <#= scalT #>[] array till a given length to get an <see cref="IROVector{Double}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static IROVector<Double> ToRODoubleVector(this <#= scalT #>[] array, int usedlength)
		{
			return new RODouble_<#= bigScalT #>ArrayWrapper(array, usedlength);
		}


		  /// <summary>
    /// Serves as wrapper for a section of an array to plug-in where an <see cref="IROVector{<#= scalT #>}" /> is neccessary.
    /// </summary>
    private class RO<#= bigScalT #>ArraySectionWrapper : <#= roVecT #>
    {
      protected <#= scalT #>[] _x;
      protected int _start;
      protected int _length;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      public RO<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x)
      {
        _length = x.Length;
        _start = 0;
        _x = x;
      }

      /// <summary>
      /// Constructor, takes a double array, and start and length of the section, for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap.</param>
      /// <param name="start">Index of the element in <paramref name="x"/> used as the first element of the vector.</param>
      /// <param name="usedlength">The length used for the vector.</param>
      public RO<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x, int start, int usedlength)
      {
        if (start < 0)
          throw new ArgumentException("start is negative");
        if (usedlength < 0)
          throw new ArgumentException("usedlength is negative");

        if ((start + usedlength) > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _x = x;
        _start = start;
        _length = usedlength;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i] { get { return _x[i + _start]; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      /// <summary>
      /// Returns an enumerator that iterates through the elements of the vector.
      /// </summary>
      /// <returns>
      /// An enumerator that can be used to iterate through the elements of the vector.
      /// </returns>
      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }

		/// <summary>
		/// Wraps an array to an <see cref="IROVector{<#= scalT #>}" />. Start and length of the used section of the array are specified in the parameters.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="start">Index of the element in <paramref name="array"/> used as the first element of the vector.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array.</param>
		/// <returns>A wrapper object with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= roVecT #> ToROVector(this <#= scalT #>[] array, int start, int usedlength)
		{
			if (0 == start)
				return new RO<#= bigScalT #>ArrayWrapper(array, usedlength);
			else
				return new RO<#= bigScalT #>ArraySectionWrapper(array, start, usedlength);
		}


		/// <summary>
    /// Serves as wrapper for an array to plug-in where an <see cref="IROVector{<#= scalT #>}" /> is neccessary.
    /// </summary>
    private class RO<#= bigScalT #>ArrayWrapperAmendedShifted : <#= roVecT #>
    {
      private int _length;
      protected <#= scalT #>[] _x;
			protected <#= scalT #> _amendedValueAtStart;
			protected int _amendedValuesAtStartCount;
			protected <#= scalT #> _amendedValueAtEnd;
			protected int _amendedValuesAtEndCount;
			
      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
			/// <param name="amendedValueAtStart">Value of the vector at the first <paramref name="amendedValuesAtStartCount"/> indices</param>.
			/// <param name="amendedValuesAtStartCount">Number of indices at the start of the vector that take the value of <paramref name="amendedValueAtStart"/>. The first element of the wrapped array starts at index <paramref name="amendedValuesAtStartCount"/>.</param>
			/// <param name="amendedValueAtEnd">Value of the vector at the last <paramref name="amendedValuesAtEndCount"/> indices</param>.
			/// <param name="amendedValuesAtEndCount">Number of indices at the end of the vector that take the value of <paramref name="amendedValueAtEnd"/>.</param>

      public RO<#= bigScalT #>ArrayWrapperAmendedShifted(<#= scalT #>[] x, <#= scalT #> amendedValueAtStart, int amendedValuesAtStartCount, <#= scalT #> amendedValueAtEnd, int amendedValuesAtEndCount)
      {
        _length = x.Length;
        _x = x;
			 _amendedValueAtStart = amendedValueAtStart;
			 _amendedValuesAtStartCount = amendedValuesAtStartCount;
			 _amendedValueAtEnd = amendedValueAtEnd;
			 _amendedValuesAtEndCount = amendedValuesAtEndCount;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
			/// <param name="amendedValueAtStart">Value of the vector at the first <paramref name="amendedValuesAtStartCount"/> indices</param>.
			/// <param name="amendedValuesAtStartCount">Number of indices at the start of the vector that take the value of <paramref name="amendedValueAtStart"/>. The first element of the wrapped array starts at index <paramref name="amendedValuesAtStartCount"/>.</param>
			/// <param name="amendedValueAtEnd">Value of the vector at the last <paramref name="amendedValuesAtEndCount"/> indices</param>.
			/// <param name="amendedValuesAtEndCount">Number of indices at the end of the vector that take the value of <paramref name="amendedValueAtEnd"/>.</param>

      public RO<#= bigScalT #>ArrayWrapperAmendedShifted(<#= scalT #>[] x, int usedlength, <#= scalT #> amendedValueAtStart, int amendedValuesAtStartCount, <#= scalT #> amendedValueAtEnd, int amendedValuesAtEndCount)
      {
        if (usedlength > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
			 _amendedValueAtStart = amendedValueAtStart;
			 _amendedValuesAtStartCount = amendedValuesAtStartCount;
			 _amendedValueAtEnd = amendedValueAtEnd;
			 _amendedValuesAtEndCount = amendedValuesAtEndCount;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get
        {
					if(i<_amendedValuesAtStartCount)
						return _amendedValueAtStart;
          else if(i<_length +_amendedValuesAtStartCount)
						return _x[i - _amendedValuesAtStartCount];
					else 
						return _amendedValueAtEnd;
        }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length
      {
        get
        {
          return _length + _amendedValuesAtStartCount + _amendedValuesAtEndCount;
        }
      } 

     /// <summary>The number of elements of this vector.</summary>
     public int Count
      {
        get
        {
           return _length + _amendedValuesAtStartCount + _amendedValuesAtEndCount;
        }
      }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
				for (int i = 0; i < _amendedValuesAtStartCount; ++i)
					yield return _amendedValueAtStart;
				for (int i = 0; i < _length; ++i)
					yield return _x[i];
				for (int i = 0; i < _amendedValuesAtEndCount; ++i)
					yield return _amendedValueAtEnd;
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
				for (int i = 0; i < _amendedValuesAtStartCount; ++i)
					yield return _amendedValueAtStart;
				for (int i = 0; i < _length; ++i)
					yield return _x[i];
				for (int i = 0; i < _amendedValuesAtEndCount; ++i)
					yield return _amendedValueAtEnd;
      }
    }

			/// <summary>
		/// Wraps a <#= scalT #>[] array to get an <see cref="IROVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap. The first element of the array has index <paramref name="amendedValuesAtStartCount"/> in the returned vector.</param>
		/// <param name="amendedValueAtStart">Value of the vector at the first <paramref name="amendedValuesAtStartCount"/> indices</param>.
		/// <param name="amendedValuesAtStartCount">Number of indices at the start of the vector that take the value of <paramref name="amendedValueAtStart"/>. The first element of the wrapped array starts at index <paramref name="amendedValuesAtStartCount"/>.</param>
		/// <param name="amendedValueAtEnd">Value of the vector at the last <paramref name="amendedValuesAtEndCount"/> indices</param>.
		/// <param name="amendedValuesAtEndCount">Number of indices at the end of the vector that take the value of <paramref name="amendedValueAtEnd"/>.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= roVecT #> ToROVectorAmendedShifted(this <#= scalT #>[] array,<#= scalT #> amendedValueAtStart, int amendedValuesAtStartCount, <#= scalT #> amendedValueAtEnd, int amendedValuesAtEndCount)
		{
			return array is null ? null : new RO<#= bigScalT #>ArrayWrapperAmendedShifted(array, amendedValueAtStart, amendedValuesAtStartCount, amendedValueAtEnd, amendedValuesAtEndCount);
		}

		/// <summary>
		/// Wraps a <#= scalT #>[] array till a given length to get an <see cref="IROVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array. The first element of the array has index <paramref name="amendedValuesAtStartCount"/> in the returned vector.</param>
		/// <param name="amendedValueAtStart">Value of the vector at the first <paramref name="amendedValuesAtStartCount"/> indices</param>.
		/// <param name="amendedValuesAtStartCount">Number of indices at the start of the vector that take the value of <paramref name="amendedValueAtStart"/>. The first element of the wrapped array starts at index <paramref name="amendedValuesAtStartCount"/>.</param>
		/// <param name="amendedValueAtEnd">Value of the vector at the last <paramref name="amendedValuesAtEndCount"/> indices</param>.
		/// <param name="amendedValuesAtEndCount">Number of indices at the end of the vector that take the value of <paramref name="amendedValueAtEnd"/>.</param>
		/// <returns>A wrapper objects with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= roVecT #> ToROVectorAmendedShifted(this <#= scalT #>[] array, int usedlength,<#= scalT #> amendedValueAtStart, int amendedValuesAtStartCount, <#= scalT #> amendedValueAtEnd, int amendedValuesAtEndCount)
		{
			return new RO<#= bigScalT #>ArrayWrapperAmendedShifted(array, usedlength, amendedValueAtStart, amendedValuesAtStartCount, amendedValueAtEnd, amendedValuesAtEndCount);
		}


		/// <summary>
    /// Serves as thin wrapper struct for an array when additional data at the start and the end of the array are neccessary.
    /// </summary>
    public struct RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted : <#= roVecT #>
    {
      private int _length;
      private  <#= scalT #>[] _x;
			private  <#= scalT #> _amendedValueAtStart;
			private  <#= scalT #> _amendedValueAtEnd;
			
      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The array to wrap. The array is used directly (without copying).</param>
			/// <param name="amendedValueAtStart">Value of the vector at indices less than zero.</param>.
			/// <param name="amendedValueAtEnd">Value of the vector at indices greater then or equal to Length.</param>.
      public RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted(<#= scalT #>[] x, <#= scalT #> amendedValueAtStart, <#= scalT #> amendedValueAtEnd)
      {
        _length = x.Length;
        _x = x;
			 _amendedValueAtStart = amendedValueAtStart;
			 _amendedValueAtEnd = amendedValueAtEnd;
      }

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="usedlength">The length used for the vector.</param>
			/// <param name="amendedValueAtStart">Value of the vector at indices less than zero.</param>.
			/// <param name="amendedValueAtEnd">Value of the vector at indices greater then or equal to Length.</param>.
	      public RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted(<#= scalT #>[] x, int usedlength, <#= scalT #> amendedValueAtStart, <#= scalT #> amendedValueAtEnd)
      {
        if (usedlength > x.Length)
          throw new ArgumentException("Length provided in argument usedlength is greater than length of array");

        _length = Math.Max(0,usedlength);
        _x = x;
			 _amendedValueAtStart = amendedValueAtStart;
			 _amendedValueAtEnd = amendedValueAtEnd;
      }

      /// <summary>Gets the value at index i. For indices &lt;0, the value amendedValueAtStart is returned.
			/// For indices &gt;=Length, the value amendedValueAtEnd is returned.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get
        {
					if(i<0)
						return _amendedValueAtStart;
          else if(i<_length)
						return _x[i];
					else 
						return _amendedValueAtEnd;
        }
      }

      /// <summary>Attention! Returns the length of the wrapped part of the array.</summary>
      public int Length
      {
        get
        {
          return _length;
        }
      } 

     /// <summary>Attention! Returns the length of the wrapped part of the array.</summary>
     public int Count
      {
        get
        {
          return _length;
        }
      }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
				yield return _amendedValueAtStart;

				for (int i = 0; i < _length; ++i)
					yield return _x[i];

				yield return _amendedValueAtEnd;
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
				yield return _amendedValueAtStart;

				for (int i = 0; i < _length; ++i)
					yield return _x[i];

				yield return _amendedValueAtEnd;
      }
    }

		
		/// <summary>
		/// Wraps a <#= scalT #>[] array to get a struct with an <see cref="IROVector{<#= scalT #>}" /> implementation. The wrapping is done lazily, i.e. you can access elements with indices below zero and
		/// above Length, which is normally forbidden. The values for that are given as parameters.
		/// </summary>
		/// <param name="array">The array to wrap. The first element of the array has index 0 in the returned vector.</param>
		/// <param name="amendedValueAtStart">Value of the vector at indices less than zero.</param>.
		/// <param name="amendedValueAtEnd">Value of the vector at indices greater than or equal to <paramref name="array"/>.Length.</param>.
		/// <returns>A wrapper struct with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array, and allows access to elements below and above the valid indices of the array.</returns>
		public static RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted ToROVectorStructAmendedUnshifted(this <#= scalT #>[] array,<#= scalT #> amendedValueAtStart, <#= scalT #> amendedValueAtEnd)
		{
			return new RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted(array, amendedValueAtStart, amendedValueAtEnd);
		}

		/// <summary>
		/// Wraps a <#= scalT #>[] array till a given length to get a struct with an <see cref="IROVector{<#= scalT #>}" /> implementation. The wrapping is done lazily, i.e. you can access elements with indices below zero and
		/// above <paramref name="usedlength"/>, which is normally forbidden. The values for that are given as parameters.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Length of the resulting vector. Can be equal or less the length of the array. The first element of the array has index 0 in the returned vector.</param>
		/// <param name="amendedValueAtStart">Value of the vector at indices less than zero.</param>.
		/// <param name="amendedValueAtEnd">Value of the vector at indices greater then or equal to <paramref name="usedlength"/>.</param>.
		/// <returns>A wrapper struct with the <see cref="IROVector{<#= scalT #>}" /> interface that wraps the provided array, and allows access to elements below and above the valid indices of the array.</returns>
		public static RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted ToROVectorStructAmendedUnshifted(this <#= scalT #>[] array, int usedlength,<#= scalT #> amendedValueAtStart, <#= scalT #> amendedValueAtEnd)
		{
			return new RO<#= bigScalT #>ArrayWrapperStructAmendedUnshifted(array, usedlength, amendedValueAtStart, amendedValueAtEnd );
		}


		/// <summary>
    /// Serves as wrapper for an array to plug-in where a IVector is neccessary.
    /// </summary>
		private class RW<#= bigScalT #>ArrayWrapper : RO<#= bigScalT #>ArrayWrapper, <#= rwVecT #>
    {
      public RW<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x)
        : base(x)
      {
      }

      public RW<#= bigScalT #>ArrayWrapper(<#= scalT #>[] x, int usedlength)
        : base(x, usedlength)
      {
      }

      public new <#= scalT #> this[int i]
      {
        get { return _x[i]; }
        set { _x[i] = value; }
      }
    }


			/// <summary>
		/// Wraps an array to get an <see cref="IVector{<#= scalT #>}" />
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <returns>A wrapper objects with the <see cref="IVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= rwVecT #> ToVector(this <#= scalT #>[] array)
		{
			return new RW<#= bigScalT #>ArrayWrapper(array);
		}

		/// <summary>
		/// Wraps an array to get an <see cref="IVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="usedlength">Used length of the array to get the wrapped vector (i.e. the vector wraps around <paramref name="array"/>[0..usedLength-1]).</param>
		/// <returns>A wrapper objects with the <see cref="IVector{<#= scalT #>}" /> interface that wraps the provided array.</returns>
		public static <#= rwVecT #> ToVector(<#= scalT #>[] array, int usedlength)
		{
			return new RW<#= bigScalT #>ArrayWrapper(array, usedlength);
		}

		
		private class RW<#= bigScalT #>ArraySectionWrapper : RO<#= bigScalT #>ArraySectionWrapper, <#= rwVecT #>
    {
      public RW<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x)
        : base(x)
      {
      }

      public RW<#= bigScalT #>ArraySectionWrapper(<#= scalT #>[] x, int start, int usedlength)
        : base(x, start, usedlength)
      {
      }

      public new <#= scalT #> this[int i]
      {
        get { return _x[i + _start]; }
        set { _x[i + _start] = value; }
      }
    }

		/// <summary>
		/// Wraps a section of an array to get a <see cref="IVector{<#= scalT #>}" />.
		/// </summary>
		/// <param name="array">The array to wrap.</param>
		/// <param name="start">Index of first element of <paramref name="array"/> to use.</param>
		/// <param name="count">Number of elements of <paramref name="array"/> to use.</param>
		/// <returns>A wrapper objects with the <see cref="IVector{<#= scalT #>}" /> interface that wraps a section of the provided array.</returns>
		public static <#= rwVecT #> ToVector(this <#= scalT #>[] array, int start, int count)
		{
			if (0 == start)
				return new RW<#= bigScalT #>ArrayWrapper(array, count);
			else
				return new RW<#= bigScalT #>ArraySectionWrapper(array, start, count);
		}



		 /// <summary>
    /// Serves as wrapper for an <see cref="IROVector{<#= scalT #>}" /> to get only a section of the original wrapper.
    /// </summary>
    private class RO<#= bigScalT #>VectorSectionWrapper : <#= roVecT #>
    {
      protected IReadOnlyList<<#= scalT #>> _x;
      private int _start;
      private int _length;


		 /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x">The vector to wrap.</param>
      /// <param name="start">Start index of the section of the vector to wrap.</param>
      /// <param name="len">Length of the section to wrap.</param>
      public RO<#= bigScalT #>VectorSectionWrapper(IReadOnlyList<<#= scalT #>> x, int start, int len)
      {
        if (start >= x.Count)
          throw new ArgumentException("Start of the section is beyond length of the vector");
        if (start + len > x.Count)
          throw new ArgumentException("End of the section is beyond length of the vector");

        _x = x;
        _start = start;
        _length = len;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i] { get { return _x[i + _start]; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for(int i = 0; i < _length; ++i)
					yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for(int i = 0; i < _length; ++i)
					yield return this[i];
      }
    }


		/// <summary>
		/// Wraps a section of an original vector into a new vector.
		/// </summary>
		/// <param name="vector">Original vector.</param>
		/// <param name="start">Index of the start of the section to wrap.</param>
		/// <param name="usedLength">Length (=number of elements) of the section to wrap.</param>
		/// <returns>An <see cref="IROVector{<#= scalT #>}" /> that contains the section from <c>start</c> to <c>start+len-1</c> of the original vector.</returns>
		public static <#= roVecT #> ToROVector(this IReadOnlyList<<#= scalT #>> vector, int start, int usedLength)
		{
			return new RO<#= bigScalT #>VectorSectionWrapper(vector, start, usedLength);
		}

		  /// <summary>
    /// Serves as wrapper for an IVector to get only a section of the original wrapper.
    /// </summary>
    private class RW<#= bigScalT #>VectorSectionWrapper : <#= rwVecT #>
    {
      protected IVector<<#= scalT #>> _x;
      private int _start;
      private int _length;

      /// <summary>
      /// Constructor, takes a double array for wrapping.
      /// </summary>
      /// <param name="x"></param>
      /// <param name="start">Start index of the section to wrap.</param>
      /// <param name="len">Length of the section to wrap.</param>
      public RW<#= bigScalT #>VectorSectionWrapper(IVector<<#= scalT #>> x, int start, int len)
      {
        if (start >= x.Length)
          throw new ArgumentException("Start of the section is beyond length of the vector");
        if (start + len >= x.Length)
          throw new ArgumentException("End of the section is beyond length of the vector");

        _x = x;
        _start = start;
        _length = len;
      }

      /// <summary>Gets the value at index i with 0 &lt;= i &lt;=Length-1.</summary>
      /// <value>The element at index i.</value>
      public <#= scalT #> this[int i]
      {
        get { return _x[i + _start]; }
        set { _x[i + _start] = value; }
      }

      /// <summary>The number of elements of this vector.</summary>
      public int Length { get { return _length; } }

      /// <summary>The number of elements of this vector.</summary>
      public int Count { get { return _length; } }

      public IEnumerator<<#= scalT #>> GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }

      IEnumerator IEnumerable.GetEnumerator()
      {
        for (int i = 0; i < _length; ++i)
          yield return this[i];
      }
    }

		/// <summary>
		/// Wraps a section of an original vector into a new vector.
		/// </summary>
		/// <param name="vector">Original vector.</param>
		/// <param name="start">Index of the start of the section to wrap.</param>
		/// <param name="len">Length (=number of elements) of the section to wrap.</param>
		/// <returns>A IVector that contains the section from <c>start</c> to <c>start+len-1</c> of the original vector.</returns>
		public static IVector<<#= scalT #>> ToVector(this IVector<<#= scalT #>> vector, int start, int len)
		{
			return new RW<#= bigScalT #>VectorSectionWrapper(vector, start, len);
		}

    /// <summary>
	/// Returns a clone of the source vector.
	/// </summary>
	/// <param name="sourceVector">The source vector.</param>
    /// <returns>A freshly allocated clone of the sourceVector, with the same element values as the source vector.</returns>
	public static <#= scalT #>[] Clone(<#= scalT #>[] sourceVector)
	{
		if (sourceVector is null)
			throw new ArgumentNullException(nameof(sourceVector));

        var destVector = new <#= scalT #>[sourceVector.Length];
        Array.Copy(sourceVector, destVector, sourceVector.Length);
        return destVector;
	}



<# 
// ----------- End of code before previous line --------------------------------------------------------------------
    }
#>
<#@ include file="VectorMath_Footer.ttinclude" #>
