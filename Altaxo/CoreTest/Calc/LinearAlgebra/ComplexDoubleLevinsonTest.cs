#region Copyright
/////////////////////////////////////////////////////////////////////////////
//    Altaxo:  a data processing and data plotting program
//    Copyright (C) 2002-2007 Dr. Dirk Lellinger
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
/////////////////////////////////////////////////////////////////////////////
#endregion

#region Using Directive

using System;
using NUnit.Framework;
using Altaxo.Calc;
using Altaxo.Calc.LinearAlgebra;

#endregion Using Directive

namespace AltaxoTest.Calc.LinearAlgebra
{

  // suite of tests for complex double Levinson algorithm
  [TestFixture]
  public class ComplexDoubleLevinsonTest
  {

    #region Fields

    // unit testing - order 1
    
    ComplexDoubleVector TR1;    // Toeplitz matrix
    ComplexDoubleVector LC1;    // Toeplitz matrix
    ComplexDoubleMatrix L1;     // Lower triangle matrix
    ComplexDoubleVector D1;     // diagonal vector
    ComplexDoubleMatrix U1;     // upper triangle matrix
    ComplexDoubleMatrix I1;     // inverse matrix
    Complex Det1;       // exact determinant
    ComplexDoubleVector X1;     // RHS vector
    ComplexDoubleVector Y1;     // LHS vector

    // unit testing - order 2
    
    ComplexDoubleVector TR2;    // Toeplitz matrix
    ComplexDoubleVector LC2;    // Toeplitz matrix
    ComplexDoubleMatrix L2;     // Lower triangle matrix
    ComplexDoubleVector D2;     // diagonal vector
    ComplexDoubleMatrix U2;     // upper triangle matrix
    ComplexDoubleMatrix I2;     // inverse matrix
    Complex Det2;       // exact determinant
    ComplexDoubleVector X2;     // RHS vector
    ComplexDoubleVector Y2;     // LHS vector

    // unit testing - order 3
    
    ComplexDoubleVector TR3;    // Toeplitz matrix
    ComplexDoubleVector LC3;    // Toeplitz matrix
    ComplexDoubleMatrix L3;     // Lower triangle matrix
    ComplexDoubleVector D3;     // diagonal vector
    ComplexDoubleMatrix U3;     // upper triangle matrix
    ComplexDoubleMatrix I3;     // inverse matrix
    Complex Det3;       // exact determinant
    ComplexDoubleVector X3;     // RHS vector
    ComplexDoubleVector Y3;     // LHS vector

    // unit testing - order 4
    
    ComplexDoubleVector TR4;    // Toeplitz matrix
    ComplexDoubleVector LC4;    // Toeplitz matrix
    ComplexDoubleMatrix L4;     // Lower triangle matrix
    ComplexDoubleVector D4;     // diagonal vector
    ComplexDoubleMatrix U4;     // upper triangle matrix
    ComplexDoubleMatrix I4;     // inverse matrix
    Complex Det4;       // exact determinant
    ComplexDoubleVector X4;     // RHS vector
    ComplexDoubleVector Y4;     // LHS vector

    // unit testing - order 5
    
    ComplexDoubleVector TR5;    // Toeplitz matrix
    ComplexDoubleVector LC5;    // Toeplitz matrix
    ComplexDoubleMatrix L5;     // Lower triangle matrix
    ComplexDoubleVector D5;     // diagonal vector
    ComplexDoubleMatrix U5;     // upper triangle matrix
    ComplexDoubleMatrix I5;     // inverse matrix
    Complex Det5;       // exact determinant
    ComplexDoubleVector X5;     // RHS vector
    ComplexDoubleVector Y5;     // LHS vector

    // unit testing - order 10
    
    ComplexDoubleVector TR10;   // Toeplitz matrix
    ComplexDoubleVector LC10;   // Toeplitz matrix
    ComplexDoubleMatrix L10;    // Lower triangle matrix
    ComplexDoubleVector D10;    // diagonal vector
    ComplexDoubleMatrix U10;    // upper triangle matrix
    ComplexDoubleMatrix I10;    // inverse matrix
    Complex Det10;      // exact determinant
    ComplexDoubleVector X10;    // RHS vector
    ComplexDoubleVector Y10;    // LHS vector

    // tolerance for error
    double Tolerance1;
    double Tolerance2;
    double Tolerance3;
    double Tolerance4;
    double Tolerance5;
    double Tolerance10;

    #endregion Fields

    #region Test Fixture Setup

    [TestFixtureSetUp]
    public void SetupTestCases()
    {
      // unit testing values - order 1

      LC1 = new ComplexDoubleVector(1);
      LC1[0] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      TR1 = new ComplexDoubleVector(1);
      TR1[0] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      L1 = new ComplexDoubleMatrix(1);
      L1[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D1 = new ComplexDoubleVector(1);
      D1[0] = new Complex(+5.0000000000000000E-001, -5.0000000000000000E-001);

      U1 = new ComplexDoubleMatrix(1);
      U1[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det1 = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      I1 = new ComplexDoubleMatrix(1);
      I1[0, 0] = new Complex(+5.0000000000000000E-001, -5.0000000000000000E-001);

      X1 = new ComplexDoubleVector(1);
      X1[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Y1 = new ComplexDoubleVector(1);
      Y1[0] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      // unit testing values - order 2

      LC2 = new ComplexDoubleVector(2);
      LC2[0] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);
      LC2[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);

      TR2 = new ComplexDoubleVector(2);
      TR2[0] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);
      TR2[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);

      L2 = new ComplexDoubleMatrix(2);
      L2[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L2[1, 0] = new Complex(-3.3333333333333331E-001, +3.3333333333333331E-001);
      L2[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D2 = new ComplexDoubleVector(2);
      D2[0] = new Complex(+1.6666666666666666E-001, -1.6666666666666666E-001);
      D2[1] = new Complex(+1.2352941176470589E-001, -1.9411764705882353E-001);

      U2 = new ComplexDoubleMatrix(2);
      U2[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U2[0, 1] = new Complex(-3.3333333333333331E-001, +3.3333333333333331E-001);
      U2[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det2 = new Complex(-4.0000000000000000E+000, +1.8000000000000000E+001);

      I2 = new ComplexDoubleMatrix(2);
      I2[0, 0] = new Complex(+1.2352941176470589E-001, -1.9411764705882353E-001);
      I2[0, 1] = new Complex(+2.3529411764705882E-002, +1.0588235294117647E-001);
      I2[1, 0] = new Complex(+2.3529411764705882E-002, +1.0588235294117647E-001);
      I2[1, 1] = new Complex(+1.2352941176470589E-001, -1.9411764705882353E-001);

      X2 = new ComplexDoubleVector(2);
      X2[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      X2[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);

      Y2 = new ComplexDoubleVector(2);
      Y2[0] = new Complex(+7.0000000000000000E+000, +3.0000000000000000E+000);
      Y2[1] = new Complex(+8.0000000000000000E+000, +6.0000000000000000E+000);

      // unit testing values - order 3

      LC3 = new ComplexDoubleVector(3);
      LC3[0] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);
      LC3[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);
      LC3[2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      TR3 = new ComplexDoubleVector(3);
      TR3[0] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);
      TR3[1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      TR3[2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      L3 = new ComplexDoubleMatrix(3);
      L3[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L3[1, 0] = new Complex(-3.3333333333333331E-001, +3.3333333333333331E-001);
      L3[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L3[2, 0] = new Complex(-1.7073170731707318E-001, -3.6585365853658534E-002);
      L3[2, 1] = new Complex(-2.9878048780487804E-001, +3.1097560975609756E-001);
      L3[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D3 = new ComplexDoubleVector(3);
      D3[0] = new Complex(+1.6666666666666666E-001, -1.6666666666666666E-001);
      D3[1] = new Complex(+1.4634146341463414E-001, -1.8292682926829268E-001);
      D3[2] = new Complex(+1.4776571123375468E-001, -1.9120526971693075E-001);

      U3 = new ComplexDoubleMatrix(3);
      U3[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U3[0, 1] = new Complex(-1.6666666666666666E-001, +1.6666666666666666E-001);
      U3[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U3[0, 2] = new Complex(-1.5243902439024390E-001, +1.2804878048780488E-001);
      U3[1, 2] = new Complex(-1.5853658536585366E-001, +7.3170731707317069E-002);
      U3[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det3 = new Complex(-6.4000000000000000E+001, +3.9000000000000000E+001);

      I3 = new ComplexDoubleMatrix(3);
      I3[0, 0] = new Complex(+1.4776571123375468E-001, -1.9120526971693075E-001);
      I3[0, 1] = new Complex(-9.4356418016734913E-003, +4.1125155777105217E-002);
      I3[0, 2] = new Complex(+1.9583407512907248E-003, +4.8068363895317788E-002);
      I3[1, 0] = new Complex(+1.5310664055545665E-002, +1.0307993590884813E-001);
      I3[1, 1] = new Complex(+1.3637172868079045E-001, -1.9814847783514331E-001);
      I3[1, 2] = new Complex(-9.4356418016734913E-003, +4.1125155777105217E-002);
      I3[2, 0] = new Complex(-3.2223606907601926E-002, +2.7238739540680078E-002);
      I3[2, 1] = new Complex(+1.5310664055545665E-002, +1.0307993590884813E-001);
      I3[2, 2] = new Complex(+1.4776571123375468E-001, -1.9120526971693075E-001);

      X3 = new ComplexDoubleVector(3);
      X3[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      X3[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);
      X3[2] = new Complex(+3.0000000000000000E+000, +0.0000000000000000E+000);

      Y3 = new ComplexDoubleVector(3);
      Y3[0] = new Complex(+8.0000000000000000E+000, +3.0000000000000000E+000);
      Y3[1] = new Complex(+1.1000000000000000E+001, +6.0000000000000000E+000);
      Y3[2] = new Complex(+1.4000000000000000E+001, +9.0000000000000000E+000);

      // unit testing values - order 4

      LC4 = new ComplexDoubleVector(4);
      LC4[0] = new Complex(+4.0000000000000000E+000, +4.0000000000000000E+000);
      LC4[1] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);
      LC4[2] = new Complex(+2.0000000000000000E+000, +2.0000000000000000E+000);
      LC4[3] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      TR4 = new ComplexDoubleVector(4);
      TR4[0] = new Complex(+4.0000000000000000E+000, +4.0000000000000000E+000);
      TR4[1] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);
      TR4[2] = new Complex(+2.0000000000000000E+000, +2.0000000000000000E+000);
      TR4[3] = new Complex(+3.0000000000000000E+000, +3.0000000000000000E+000);

      L4 = new ComplexDoubleMatrix(4);
      L4[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L4[1, 0] = new Complex(-7.5000000000000000E-001, +0.0000000000000000E+000);
      L4[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L4[2, 0] = new Complex(+7.6923076923076927E-002, +0.0000000000000000E+000);
      L4[2, 1] = new Complex(-7.6923076923076927E-001, +0.0000000000000000E+000);
      L4[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L4[3, 0] = new Complex(+9.0909090909090912E-002, +0.0000000000000000E+000);
      L4[3, 1] = new Complex(+9.0909090909090912E-002, +0.0000000000000000E+000);
      L4[3, 2] = new Complex(-8.1818181818181823E-001, +0.0000000000000000E+000);
      L4[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D4 = new ComplexDoubleVector(4);
      D4[0] = new Complex(+1.2500000000000000E-001, -1.2500000000000000E-001);
      D4[1] = new Complex(+1.5384615384615385E-001, -1.5384615384615385E-001);
      D4[2] = new Complex(+1.4772727272727273E-001, -1.4772727272727273E-001);
      D4[3] = new Complex(+1.3750000000000001E-001, -1.3750000000000001E-001);

      U4 = new ComplexDoubleMatrix(4);
      U4[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U4[0, 1] = new Complex(-2.5000000000000000E-001, +0.0000000000000000E+000);
      U4[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U4[0, 2] = new Complex(-5.3846153846153844E-001, +0.0000000000000000E+000);
      U4[1, 2] = new Complex(+1.5384615384615385E-001, +0.0000000000000000E+000);
      U4[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U4[0, 3] = new Complex(-8.1818181818181823E-001, +0.0000000000000000E+000);
      U4[1, 3] = new Complex(+9.0909090909090912E-002, +0.0000000000000000E+000);
      U4[2, 3] = new Complex(+9.0909090909090912E-002, +0.0000000000000000E+000);
      U4[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det4 = new Complex(-6.4000000000000000E+002, +0.0000000000000000E+000);

      I4 = new ComplexDoubleMatrix(4);
      I4[0, 0] = new Complex(+1.3750000000000001E-001, -1.3750000000000001E-001);
      I4[0, 1] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[0, 2] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[0, 3] = new Complex(-1.1250000000000000E-001, +1.1250000000000000E-001);
      I4[1, 0] = new Complex(-1.1250000000000000E-001, +1.1250000000000000E-001);
      I4[1, 1] = new Complex(+1.3750000000000001E-001, -1.3750000000000001E-001);
      I4[1, 2] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[1, 3] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[2, 0] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[2, 1] = new Complex(-1.1250000000000000E-001, +1.1250000000000000E-001);
      I4[2, 2] = new Complex(+1.3750000000000001E-001, -1.3750000000000001E-001);
      I4[2, 3] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[3, 0] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[3, 1] = new Complex(+1.2500000000000001E-002, -1.2500000000000001E-002);
      I4[3, 2] = new Complex(-1.1250000000000000E-001, +1.1250000000000000E-001);
      I4[3, 3] = new Complex(+1.3750000000000001E-001, -1.3750000000000001E-001);

      X4 = new ComplexDoubleVector(4);
      X4[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      X4[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);
      X4[2] = new Complex(+3.0000000000000000E+000, +0.0000000000000000E+000);
      X4[3] = new Complex(+4.0000000000000000E+000, +0.0000000000000000E+000);

      Y4 = new ComplexDoubleVector(4);
      Y4[0] = new Complex(+2.4000000000000000E+001, +2.4000000000000000E+001);
      Y4[1] = new Complex(+2.2000000000000000E+001, +2.2000000000000000E+001);
      Y4[2] = new Complex(+2.4000000000000000E+001, +2.4000000000000000E+001);
      Y4[3] = new Complex(+3.0000000000000000E+001, +3.0000000000000000E+001);

      // unit testing values - order 5

      LC5 = new ComplexDoubleVector(5);
      LC5[0] = new Complex(+5.0000000000000000E+000, +1.0000000000000000E+000);
      LC5[1] = new Complex(+4.0000000000000000E+000, +1.0000000000000000E+000);
      LC5[2] = new Complex(+3.0000000000000000E+000, +1.0000000000000000E+000);
      LC5[3] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);
      LC5[4] = new Complex(+0.0000000000000000E+000, +0.0000000000000000E+000);

      TR5 = new ComplexDoubleVector(5);
      TR5[0] = new Complex(+5.0000000000000000E+000, +1.0000000000000000E+000);
      TR5[1] = new Complex(+1.0000000000000000E+000, +4.0000000000000000E+000);
      TR5[2] = new Complex(+1.0000000000000000E+000, +3.0000000000000000E+000);
      TR5[3] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);
      TR5[4] = new Complex(+0.0000000000000000E+000, +0.0000000000000000E+000);

      L5 = new ComplexDoubleMatrix(5);
      L5[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L5[1, 0] = new Complex(-8.0769230769230771E-001, -3.8461538461538464E-002);
      L5[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L5[2, 0] = new Complex(+3.8399999999999997E-002, +1.1200000000000000E-002);
      L5[2, 1] = new Complex(-8.1279999999999997E-001, -7.0400000000000004E-002);
      L5[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L5[3, 0] = new Complex(+2.2603092783505155E-001, +9.7680412371134021E-002);
      L5[3, 1] = new Complex(+8.8659793814432994E-002, -4.9484536082474224E-002);
      L5[3, 2] = new Complex(-8.9149484536082479E-001, -2.3788659793814432E-001);
      L5[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L5[4, 0] = new Complex(-1.1100960704877354E-001, +5.9189711713962381E-002);
      L5[4, 1] = new Complex(+2.3807881396853334E-001, +1.3619525072849881E-001);
      L5[4, 2] = new Complex(+1.0797069971307495E-001, +5.4774906455720513E-003);
      L5[4, 3] = new Complex(-8.0625940336740765E-001, -2.8594253668595038E-001);
      L5[4, 4] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D5 = new ComplexDoubleVector(5);
      D5[0] = new Complex(+1.9230769230769232E-001, -3.8461538461538464E-002);
      D5[1] = new Complex(+1.8079999999999999E-001, +9.4399999999999998E-002);
      D5[2] = new Complex(+1.8015463917525773E-001, +8.8402061855670108E-002);
      D5[3] = new Complex(+1.5698659711359733E-001, +6.5498707066112077E-002);
      D5[4] = new Complex(+1.6335863411253979E-001, +5.3379923241956333E-002);

      U5 = new ComplexDoubleMatrix(5);
      U5[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U5[0, 1] = new Complex(-3.4615384615384615E-001, -7.3076923076923073E-001);
      U5[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U5[0, 2] = new Complex(-5.6320000000000003E-001, -4.9759999999999999E-001);
      U5[1, 2] = new Complex(+8.9599999999999999E-002, -3.0719999999999997E-001);
      U5[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U5[0, 3] = new Complex(-7.7757731958762888E-001, +1.8298969072164949E-002);
      U5[1, 3] = new Complex(+7.0103092783505155E-002, -4.5773195876288658E-001);
      U5[2, 3] = new Complex(+5.9536082474226801E-002, -3.1520618556701030E-001);
      U5[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U5[0, 4] = new Complex(-3.8732272263724954E-001, +5.0102819472125015E-001);
      U5[1, 4] = new Complex(-3.1309321615207214E-001, -3.3622619910995438E-001);
      U5[2, 4] = new Complex(+6.0556287834862423E-002, -3.9414441707977782E-001);
      U5[3, 4] = new Complex(-7.6951472565005577E-002, -2.3979216111056217E-001);
      U5[4, 4] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det5 = new Complex(+5.0900000000000000E+002, -4.2310000000000000E+003);

      I5 = new ComplexDoubleMatrix(5);
      I5[0, 0] = new Complex(+1.6335863411253979E-001, +5.3379923241956333E-002);
      I5[0, 1] = new Complex(+2.2939970293674571E-004, -4.3279783608791020E-002);
      I5[0, 2] = new Complex(+3.0931791197593098E-002, -6.1154403620792927E-002);
      I5[0, 3] = new Complex(-3.3198751440080589E-002, -7.1638344485227837E-002);
      I5[0, 4] = new Complex(-9.0017357507047466E-002, +6.1172024337293116E-002);
      I5[1, 0] = new Complex(-1.1644584421458465E-001, -8.9749247292549378E-002);
      I5[1, 1] = new Complex(+1.4442611033365818E-001, +1.0032784444343371E-001);
      I5[1, 2] = new Complex(-1.2433728209919120E-002, -5.1220118981685579E-003);
      I5[1, 3] = new Complex(+4.7268453047563490E-002, -1.4096573200145679E-005);
      I5[1, 4] = new Complex(-3.3198751440080589E-002, -7.1638344485227837E-002);
      I5[2, 0] = new Complex(+1.7345557999083942E-002, +6.6582630532891216E-003);
      I5[2, 1] = new Complex(-1.2410964446790447E-001, -1.0040845922142204E-001);
      I5[2, 2] = new Complex(+1.4624792722555982E-001, +1.1547147365686364E-001);
      I5[2, 3] = new Complex(-1.2433728209919120E-002, -5.1220118981685579E-003);
      I5[2, 4] = new Complex(+3.0931791197593098E-002, -6.1154403620792927E-002);
      I5[3, 0] = new Complex(+3.1622137831226797E-002, +3.4957298946798762E-002);
      I5[3, 1] = new Complex(+2.3108688654163812E-002, -1.2234063466076431E-002);
      I5[3, 2] = new Complex(-1.2410964446790447E-001, -1.0040845922142204E-001);
      I5[3, 3] = new Complex(+1.4442611033365818E-001, +1.0032784444343371E-001);
      I5[3, 4] = new Complex(+2.2939970293674571E-004, -4.3279783608791020E-002);
      I5[4, 0] = new Complex(-2.1293920048862248E-002, +3.7434661557246237E-003);
      I5[4, 1] = new Complex(+3.1622137831226797E-002, +3.4957298946798762E-002);
      I5[4, 2] = new Complex(+1.7345557999083942E-002, +6.6582630532891216E-003);
      I5[4, 3] = new Complex(-1.1644584421458465E-001, -8.9749247292549378E-002);
      I5[4, 4] = new Complex(+1.6335863411253979E-001, +5.3379923241956333E-002);

      X5 = new ComplexDoubleVector(5);
      X5[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      X5[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);
      X5[2] = new Complex(+3.0000000000000000E+000, +0.0000000000000000E+000);
      X5[3] = new Complex(+4.0000000000000000E+000, +0.0000000000000000E+000);
      X5[4] = new Complex(+5.0000000000000000E+000, +0.0000000000000000E+000);

      Y5 = new ComplexDoubleVector(5);
      Y5[0] = new Complex(+1.4000000000000000E+001, +2.2000000000000000E+001);
      Y5[1] = new Complex(+2.6000000000000000E+001, +3.2000000000000000E+001);
      Y5[2] = new Complex(+3.5000000000000000E+001, +3.7000000000000000E+001);
      Y5[3] = new Complex(+4.4000000000000000E+001, +3.0000000000000000E+001);
      Y5[4] = new Complex(+5.2000000000000000E+001, +1.4000000000000000E+001);

      // unit testing values - order 10

      LC10 = new ComplexDoubleVector(10);
      LC10[0] = new Complex(+1.0000000000000000E+001, +1.0000000000000000E+000);
      LC10[1] = new Complex(+9.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[2] = new Complex(+8.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[3] = new Complex(+7.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[4] = new Complex(+6.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[5] = new Complex(+5.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[6] = new Complex(+4.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[7] = new Complex(+3.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[8] = new Complex(+2.0000000000000000E+000, +1.0000000000000000E+000);
      LC10[9] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      TR10 = new ComplexDoubleVector(10);
      TR10[0] = new Complex(+1.0000000000000000E+001, +1.0000000000000000E+000);
      TR10[1] = new Complex(+1.0000000000000000E+000, +9.0000000000000000E+000);
      TR10[2] = new Complex(+1.0000000000000000E+000, +8.0000000000000000E+000);
      TR10[3] = new Complex(+1.0000000000000000E+000, +2.0000000000000000E+000);
      TR10[4] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);
      TR10[5] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);
      TR10[6] = new Complex(+1.0000000000000000E+000, +4.0000000000000000E+000);
      TR10[7] = new Complex(+1.0000000000000000E+000, +3.0000000000000000E+000);
      TR10[8] = new Complex(+1.0000000000000000E+000, +2.0000000000000000E+000);
      TR10[9] = new Complex(+1.0000000000000000E+000, +1.0000000000000000E+000);

      L10 = new ComplexDoubleMatrix(10);
      L10[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[1, 0] = new Complex(-9.0099009900990101E-001, -9.9009900990099011E-003);
      L10[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[2, 0] = new Complex(+7.2554049102235250E-003, +4.5437889336753393E-003);
      L10[2, 1] = new Complex(-8.9835104433858559E-001, -1.7149138878710151E-002);
      L10[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[3, 0] = new Complex(+8.1190930904461098E-003, +4.8283629596983495E-003);
      L10[3, 1] = new Complex(+8.5500220361392678E-003, +3.8783605112384309E-003);
      L10[3, 2] = new Complex(-8.9685128054453744E-001, -2.5375838597522158E-002);
      L10[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[4, 0] = new Complex(+9.0797285269476318E-003, +5.0413564207934967E-003);
      L10[4, 1] = new Complex(+9.5223197374378014E-003, +3.9833208944115191E-003);
      L10[4, 2] = new Complex(+1.3594954485865313E-002, +1.3510003664947803E-003);
      L10[4, 3] = new Complex(-9.0106886611442649E-001, -3.2599941689345886E-002);
      L10[4, 4] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[5, 0] = new Complex(+1.0110173871110103E-002, +5.1587582280672572E-003);
      L10[5, 1] = new Complex(+1.0553084239177118E-002, +3.9861933126031325E-003);
      L10[5, 2] = new Complex(+1.4900585320861685E-002, +9.5517948721771031E-004);
      L10[5, 3] = new Complex(+1.4574245254262111E-002, -1.1129242309033962E-003);
      L10[5, 4] = new Complex(-9.0776628414977190E-001, -3.8281015485192957E-002);
      L10[5, 5] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[6, 0] = new Complex(+1.1163788513469159E-002, +5.1884794569663139E-003);
      L10[6, 1] = new Complex(+1.1597112008581692E-002, +3.8999114560127929E-003);
      L10[6, 2] = new Complex(+1.6188451615765528E-002, +4.4138653856583314E-004);
      L10[6, 3] = new Complex(+1.5752308897591619E-002, -1.7871731989626950E-003);
      L10[6, 4] = new Complex(+1.4568519265646968E-002, -5.3100094266263099E-003);
      L10[6, 5] = new Complex(-9.1612445951063282E-001, -3.9858108364046067E-002);
      L10[6, 6] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[7, 0] = new Complex(+1.2250406541367076E-002, +5.1493110897315028E-003);
      L10[7, 1] = new Complex(+1.2666179629979471E-002, +3.7419577975115617E-003);
      L10[7, 2] = new Complex(+1.7480232661909394E-002, -1.7281679037714086E-004);
      L10[7, 3] = new Complex(+1.6920428341073365E-002, -2.5592883785053862E-003);
      L10[7, 4] = new Complex(+1.5502251396922552E-002, -6.3119297919110896E-003);
      L10[7, 5] = new Complex(+1.0175586177484720E-002, -6.2706520421364174E-003);
      L10[7, 6] = new Complex(-9.2129653061721384E-001, -4.0086723317934600E-002);
      L10[7, 7] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[8, 0] = new Complex(+1.3361099043684790E-002, +5.0636594067139558E-003);
      L10[8, 1] = new Complex(+1.3753926307303580E-002, +3.5354453725691135E-003);
      L10[8, 2] = new Complex(+1.8776835430320202E-002, -8.5571401884725182E-004);
      L10[8, 3] = new Complex(+1.8083822415915437E-002, -3.3986502033277540E-003);
      L10[8, 4] = new Complex(+1.6416076442997744E-002, -7.3767088600605098E-003);
      L10[8, 5] = new Complex(+1.0693867506404612E-002, -7.1281839165905619E-003);
      L10[8, 6] = new Complex(+8.4803223393024058E-003, -7.7622936050457071E-003);
      L10[8, 7] = new Complex(-9.2544568379536929E-001, -3.8329752457750041E-002);
      L10[8, 8] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      L10[9, 0] = new Complex(+1.4514517013009855E-002, +4.9086454891862858E-003);
      L10[9, 1] = new Complex(+1.4876264481176522E-002, +3.2557272135000054E-003);
      L10[9, 2] = new Complex(+2.0088846894959180E-002, -1.6446645314464505E-003);
      L10[9, 3] = new Complex(+1.9247641587559167E-002, -4.3429207478010660E-003);
      L10[9, 4] = new Complex(+1.7306259036781756E-002, -8.5413383779891494E-003);
      L10[9, 5] = new Complex(+1.1183742006517505E-002, -8.0532598623591928E-003);
      L10[9, 6] = new Complex(+8.7870452084036037E-003, -8.6470170112325079E-003);
      L10[9, 7] = new Complex(+6.7700213372541822E-003, -5.2124679779639686E-003);
      L10[9, 8] = new Complex(-9.2836000352207293E-001, -3.8752385406109945E-002);
      L10[9, 9] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      D10 = new ComplexDoubleVector(10);
      D10[0] = new Complex(+9.9009900990099015E-002, -9.9009900990099011E-003);
      D10[1] = new Complex(+6.8010260168559919E-002, +5.2693294246976913E-002);
      D10[2] = new Complex(+6.8503011605700020E-002, +5.2264825424807794E-002);
      D10[3] = new Complex(+6.8598237026649411E-002, +5.1618595452384938E-002);
      D10[4] = new Complex(+6.8466983429169667E-002, +5.0945485194816433E-002);
      D10[5] = new Complex(+6.8034269950036835E-002, +5.0441605123624854E-002);
      D10[6] = new Complex(+6.7730051709581338E-002, +5.0175369035871609E-002);
      D10[7] = new Complex(+6.7391348668953091E-002, +5.0080103689387472E-002);
      D10[8] = new Complex(+6.7234262487976523E-002, +4.9912171449770226E-002);
      D10[9] = new Complex(+6.7024327312857235E-002, +4.9751098148033725E-002);

      U10 = new ComplexDoubleMatrix(10);
      U10[0, 0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 1] = new Complex(-1.8811881188118812E-001, -8.8118811881188119E-001);
      U10[1, 1] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 2] = new Complex(-3.0868449981678270E-001, -8.2968120190545991E-001);
      U10[1, 2] = new Complex(+8.1788200806156106E-002, -1.3059728838402346E-001);
      U10[2, 2] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 3] = new Complex(-6.9271338328191567E-001, -4.1101317271436266E-001);
      U10[1, 3] = new Complex(+3.0656676950198325E-001, -4.4856765094755396E-001);
      U10[2, 3] = new Complex(+7.8629841829489247E-002, -1.3672689878066696E-001);
      U10[3, 3] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 4] = new Complex(-7.5308973321849149E-001, -1.7764936202190140E-001);
      U10[1, 4] = new Complex(-2.1811893217588054E-002, -2.3257783137749680E-001);
      U10[2, 4] = new Complex(+3.0081682395828735E-001, -4.5300731039028103E-001);
      U10[3, 4] = new Complex(+7.3373191779429692E-002, -1.4180544106158241E-001);
      U10[4, 4] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 5] = new Complex(-6.6968845860566240E-001, +1.6997562511152736E-001);
      U10[1, 5] = new Complex(-1.4411311770552337E-001, -3.0897730110766369E-001);
      U10[2, 5] = new Complex(-3.1145914463862182E-002, -2.3117176984341267E-001);
      U10[3, 5] = new Complex(+2.9376276887192493E-001, -4.5405633217030839E-001);
      U10[4, 5] = new Complex(+6.6435694668625880E-002, -1.4363824674009448E-001);
      U10[5, 5] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 6] = new Complex(-3.6546782638307224E-001, +1.3495818051940223E-001);
      U10[1, 6] = new Complex(-3.3276275167529012E-001, +6.1455618586925671E-002);
      U10[2, 6] = new Complex(-1.4928933721051368E-001, -3.0660364948610758E-001);
      U10[3, 6] = new Complex(-3.6720508278577375E-002, -2.2950990133083421E-001);
      U10[4, 6] = new Complex(+2.8936798671672792E-001, -4.5408893252802085E-001);
      U10[5, 6] = new Complex(+6.2044534775396884E-002, -1.4415915622616218E-001);
      U10[6, 6] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 7] = new Complex(-2.2796156188858349E-001, +2.1789304591577985E-001);
      U10[1, 7] = new Complex(-1.4794185907281082E-001, -5.5572851764724748E-002);
      U10[2, 7] = new Complex(-3.3492679995368185E-001, +6.5840475666737050E-002);
      U10[3, 7] = new Complex(-1.5249084553825906E-001, -3.0276392412640418E-001);
      U10[4, 7] = new Complex(-4.0507028050779381E-002, -2.2608316946434290E-001);
      U10[5, 7] = new Complex(+2.8587452736390229E-001, -4.5245103237538437E-001);
      U10[6, 7] = new Complex(+5.8369086516722783E-002, -1.4290941822383968E-001);
      U10[7, 7] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 8] = new Complex(-1.8901586128071016E-001, +3.4805078670375987E-002);
      U10[1, 8] = new Complex(-5.2426683100322356E-002, +1.9340427422276418E-001);
      U10[2, 8] = new Complex(-1.4964695572054307E-001, -5.4033436990764148E-002);
      U10[3, 8] = new Complex(-3.3763728414029187E-001, +6.7573087592136330E-002);
      U10[4, 8] = new Complex(-1.5559999864103152E-001, -3.0169126118972772E-001);
      U10[5, 8] = new Complex(-4.3805054380772743E-002, -2.2544210347689175E-001);
      U10[6, 8] = new Complex(+2.8335017937648194E-001, -4.5271747437288251E-001);
      U10[7, 8] = new Complex(+5.5874343195691095E-002, -1.4345634333105120E-001);
      U10[8, 8] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      U10[0, 9] = new Complex(-1.9701951593666925E-001, +6.3155748693143207E-002);
      U10[1, 9] = new Complex(-4.2642564199745804E-003, -1.6090427089360152E-002);
      U10[2, 9] = new Complex(-5.3607238638395983E-002, +1.9546917865788643E-001);
      U10[3, 9] = new Complex(-1.5130367052807109E-001, -5.1953666437217660E-002);
      U10[4, 9] = new Complex(-3.4040569000372223E-001, +7.0063212799312588E-002);
      U10[5, 9] = new Complex(-1.5894822028156261E-001, -2.9987956342791905E-001);
      U10[6, 9] = new Complex(-4.7450414148549412E-002, -2.2408764601542844E-001);
      U10[7, 9] = new Complex(+2.8041710377372003E-001, -4.5254538659539856E-001);
      U10[8, 9] = new Complex(+5.2922146728764330E-002, -1.4361015284276302E-001);
      U10[9, 9] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);

      Det10 = new Complex(+3.6568547936000000E+010, +2.4768517120000000E+010);

      I10 = new ComplexDoubleMatrix(10);
      I10[0, 0] = new Complex(+6.7024327312857235E-002, +4.9751098148033725E-002);
      I10[0, 1] = new Complex(+1.0691834093582184E-002, -6.9924389734754054E-003);
      I10[0, 2] = new Complex(+4.1309397692400801E-002, -1.6380491262859800E-002);
      I10[0, 3] = new Complex(+7.9682743816524119E-003, -1.7380033944775095E-002);
      I10[0, 4] = new Complex(+4.2659400507443230E-003, -2.8007074521312885E-002);
      I10[0, 5] = new Complex(-2.6301184162513661E-002, -1.2239617186272832E-002);
      I10[0, 6] = new Complex(-7.5562747790419247E-003, -1.1009683306990904E-002);
      I10[0, 7] = new Complex(-1.3317795401162347E-002, +1.0434171218997642E-002);
      I10[0, 8] = new Complex(+5.1470749932820844E-004, -1.2906014915194778E-003);
      I10[0, 9] = new Complex(-1.6347168375005130E-002, -5.5689657023455415E-003);
      I10[1, 0] = new Complex(-6.0294731010418899E-002, -4.8784282215548688E-002);
      I10[1, 1] = new Complex(+5.7037417661172325E-002, +5.5989338044321053E-002);
      I10[1, 2] = new Complex(-2.8067887837112771E-002, +6.7497835803530838E-003);
      I10[1, 3] = new Complex(+3.3576007528605019E-002, -4.6936403719233092E-004);
      I10[1, 4] = new Complex(+3.2614353297169907E-003, +8.4914935026566395E-003);
      I10[1, 5] = new Complex(+2.8539067860959378E-002, -1.5668318575454147E-002);
      I10[1, 6] = new Complex(-1.9485221531131563E-002, -1.7952099994254273E-003);
      I10[1, 7] = new Complex(+5.4035810796630428E-003, -2.0272673686097496E-002);
      I10[1, 8] = new Complex(-1.3705944409360255E-002, +1.1564860805771092E-002);
      I10[1, 9] = new Complex(+5.1470749932820844E-004, -1.2906014915194778E-003);
      I10[2, 0] = new Complex(+7.1308213198831999E-004, -1.2546163848828748E-005);
      I10[2, 1] = new Complex(-6.0272600765653481E-002, -4.8871146078776219E-002);
      I10[2, 2] = new Complex(+5.7219841607519847E-002, +5.5680641438211255E-002);
      I10[2, 3] = new Complex(-2.8112752593573313E-002, +6.6173592215845161E-003);
      I10[2, 4] = new Complex(+3.3454600129198375E-002, -6.5413223638708837E-004);
      I10[2, 5] = new Complex(+3.0216929418343942E-003, +8.5724568880183281E-003);
      I10[2, 6] = new Complex(+2.8435161291098542E-002, -1.5684888698680857E-002);
      I10[2, 7] = new Complex(-1.9514358411820809E-002, -1.6393605974161004E-003);
      I10[2, 8] = new Complex(+5.4035810796630428E-003, -2.0272673686097496E-002);
      I10[2, 9] = new Complex(-1.3317795401162347E-002, +1.0434171218997642E-002);
      I10[3, 0] = new Complex(+1.0191443861744627E-003, -1.4239534984619490E-004);
      I10[3, 1] = new Complex(+9.9108703818921598E-004, -2.5251613186721891E-004);
      I10[3, 2] = new Complex(-5.9819165745318828E-002, -4.9484147642393089E-002);
      I10[3, 3] = new Complex(+5.7389952187041543E-002, +5.5227506716259027E-002);
      I10[3, 4] = new Complex(-2.8106423861366810E-002, +6.0757008175737568E-003);
      I10[3, 5] = new Complex(+3.3259013686843183E-002, -8.2858378598786825E-004);
      I10[3, 6] = new Complex(+2.9250083904872478E-003, +8.3171087935011243E-003);
      I10[3, 7] = new Complex(+2.8435161291098542E-002, -1.5684888698680857E-002);
      I10[3, 8] = new Complex(-1.9485221531131563E-002, -1.7952099994254273E-003);
      I10[3, 9] = new Complex(-7.5562747790419247E-003, -1.1009683306990904E-002);
      I10[4, 0] = new Complex(+1.1502413066512328E-003, +1.6639121278281933E-005);
      I10[4, 1] = new Complex(+1.1380402186616390E-003, -1.0980979190634462E-004);
      I10[4, 2] = new Complex(+1.3977289481636264E-003, -5.8000250430590057E-004);
      I10[4, 3] = new Complex(-5.9700112467401305E-002, -4.9533947737148823E-002);
      I10[4, 4] = new Complex(+5.7405367761624505E-002, +5.5059022232440968E-002);
      I10[4, 5] = new Complex(-2.8274330058084413E-002, +6.2766220989112871E-003);
      I10[4, 6] = new Complex(+3.3259013686843183E-002, -8.2858378598786825E-004);
      I10[4, 7] = new Complex(+3.0216929418343942E-003, +8.5724568880183281E-003);
      I10[4, 8] = new Complex(+2.8539067860959378E-002, -1.5668318575454147E-002);
      I10[4, 9] = new Complex(-2.6301184162513661E-002, -1.2239617186272832E-002);
      I10[5, 0] = new Complex(+1.5848813342012589E-003, +2.8852793277801093E-004);
      I10[5, 1] = new Complex(+1.5972212129915131E-003, +1.1105890911228723E-004);
      I10[5, 2] = new Complex(+2.0644545541194949E-003, -4.7842309729633663E-004);
      I10[5, 3] = new Complex(+1.9356717438070007E-003, -7.4622243062377497E-004);
      I10[5, 4] = new Complex(-5.9306111450799975E-002, -4.9933722454771547E-002);
      I10[5, 5] = new Complex(+5.7405367761624505E-002, +5.5059022232440968E-002);
      I10[5, 6] = new Complex(-2.8106423861366810E-002, +6.0757008175737568E-003);
      I10[5, 7] = new Complex(+3.3454600129198375E-002, -6.5413223638708837E-004);
      I10[5, 8] = new Complex(+3.2614353297169907E-003, +8.4914935026566395E-003);
      I10[5, 9] = new Complex(+4.2659400507443230E-003, -2.8007074521312885E-002);
      I10[6, 0] = new Complex(+1.5061253061381115E-003, +6.6650996404641455E-004);
      I10[6, 1] = new Complex(+1.5609114569951799E-003, +4.9307535771361680E-004);
      I10[6, 2] = new Complex(+2.1665458714628626E-003, +1.9121554747827345E-005);
      I10[6, 3] = new Complex(+2.1027093590249234E-003, -2.7790747325212703E-004);
      I10[6, 4] = new Complex(+1.9356717438070007E-003, -7.4622243062377497E-004);
      I10[6, 5] = new Complex(-5.9700112467401305E-002, -4.9533947737148823E-002);
      I10[6, 6] = new Complex(+5.7389952187041543E-002, +5.5227506716259027E-002);
      I10[6, 7] = new Complex(-2.8112752593573313E-002, +6.6173592215845161E-003);
      I10[6, 8] = new Complex(+3.3576007528605019E-002, -4.6936403719233092E-004);
      I10[6, 9] = new Complex(+7.9682743816524119E-003, -1.7380033944775095E-002);
      I10[7, 0] = new Complex(+1.4282653161502019E-003, +8.8920965967642283E-004);
      I10[7, 1] = new Complex(+1.5084436286006604E-003, +7.2160481205412721E-004);
      I10[7, 2] = new Complex(+2.1887064029275029E-003, +3.2867752937502156E-004);
      I10[7, 3] = new Complex(+2.1665458714628626E-003, +1.9121554747827345E-005);
      I10[7, 4] = new Complex(+2.0644545541194949E-003, -4.7842309729633663E-004);
      I10[7, 5] = new Complex(+1.3977289481636264E-003, -5.8000250430590057E-004);
      I10[7, 6] = new Complex(-5.9819165745318828E-002, -4.9484147642393089E-002);
      I10[7, 7] = new Complex(+5.7219841607519847E-002, +5.5680641438211255E-002);
      I10[7, 8] = new Complex(-2.8067887837112771E-002, +6.7497835803530838E-003);
      I10[7, 9] = new Complex(+4.1309397692400801E-002, -1.6380491262859800E-002);
      I10[8, 0] = new Complex(+8.3509561563694431E-004, +9.5832342067812219E-004);
      I10[8, 1] = new Complex(+9.3009336161823893E-004, +8.5497971383165119E-004);
      I10[8, 2] = new Complex(+1.5084436286006604E-003, +7.2160481205412721E-004);
      I10[8, 3] = new Complex(+1.5609114569951799E-003, +4.9307535771361680E-004);
      I10[8, 4] = new Complex(+1.5972212129915131E-003, +1.1105890911228723E-004);
      I10[8, 5] = new Complex(+1.1380402186616390E-003, -1.0980979190634462E-004);
      I10[8, 6] = new Complex(+9.9108703818921598E-004, -2.5251613186721891E-004);
      I10[8, 7] = new Complex(-6.0272600765653481E-002, -4.8871146078776219E-002);
      I10[8, 8] = new Complex(+5.7037417661172325E-002, +5.5989338044321053E-002);
      I10[8, 9] = new Complex(+1.0691834093582184E-002, -6.9924389734754054E-003);
      I10[9, 0] = new Complex(+7.2861523556159741E-004, +1.0511118224155603E-003);
      I10[9, 1] = new Complex(+8.3509561563694431E-004, +9.5832342067812219E-004);
      I10[9, 2] = new Complex(+1.4282653161502019E-003, +8.8920965967642283E-004);
      I10[9, 3] = new Complex(+1.5061253061381115E-003, +6.6650996404641455E-004);
      I10[9, 4] = new Complex(+1.5848813342012589E-003, +2.8852793277801093E-004);
      I10[9, 5] = new Complex(+1.1502413066512328E-003, +1.6639121278281933E-005);
      I10[9, 6] = new Complex(+1.0191443861744627E-003, -1.4239534984619490E-004);
      I10[9, 7] = new Complex(+7.1308213198831999E-004, -1.2546163848828748E-005);
      I10[9, 8] = new Complex(-6.0294731010418899E-002, -4.8784282215548688E-002);
      I10[9, 9] = new Complex(+6.7024327312857235E-002, +4.9751098148033725E-002);

      X10 = new ComplexDoubleVector(10);
      X10[0] = new Complex(+1.0000000000000000E+000, +0.0000000000000000E+000);
      X10[1] = new Complex(+2.0000000000000000E+000, +0.0000000000000000E+000);
      X10[2] = new Complex(+3.0000000000000000E+000, +0.0000000000000000E+000);
      X10[3] = new Complex(+4.0000000000000000E+000, +0.0000000000000000E+000);
      X10[4] = new Complex(+5.0000000000000000E+000, +0.0000000000000000E+000);
      X10[5] = new Complex(+6.0000000000000000E+000, +0.0000000000000000E+000);
      X10[6] = new Complex(+7.0000000000000000E+000, +0.0000000000000000E+000);
      X10[7] = new Complex(+8.0000000000000000E+000, +0.0000000000000000E+000);
      X10[8] = new Complex(+9.0000000000000000E+000, +0.0000000000000000E+000);
      X10[9] = new Complex(+1.0000000000000000E+001, +0.0000000000000000E+000);

      Y10 = new ComplexDoubleVector(10);
      Y10[0] = new Complex(+6.4000000000000000E+001, +1.4200000000000000E+002);
      Y10[1] = new Complex(+8.1000000000000000E+001, +1.6400000000000000E+002);
      Y10[2] = new Complex(+1.0500000000000000E+002, +1.7500000000000000E+002);
      Y10[3] = new Complex(+1.3500000000000000E+002, +1.7400000000000000E+002);
      Y10[4] = new Complex(+1.7000000000000000E+002, +1.6000000000000000E+002);
      Y10[5] = new Complex(+2.0900000000000000E+002, +1.7600000000000000E+002);
      Y10[6] = new Complex(+2.5100000000000000E+002, +1.9200000000000000E+002);
      Y10[7] = new Complex(+2.9500000000000000E+002, +1.9700000000000000E+002);
      Y10[8] = new Complex(+3.4000000000000000E+002, +1.3500000000000000E+002);
      Y10[9] = new Complex(+3.8500000000000000E+002, +5.5000000000000000E+001);

      // Tolerances
      Tolerance1 = 1.000E-015;
      Tolerance2 = 2.000E-015;
      Tolerance3 = 3.200E-015;
      Tolerance4 = 8.000E-015;
      Tolerance5 = 2.000E-014;
      Tolerance10 = 2.000E-013;
    }

    #endregion Test Fixture Setup

    #region Null Parameter Tests for Constructor 
    
    // Test constructor with a null parameter
    [Test]
    [ExpectedException(typeof(System.ArgumentNullException))]
    public void NullParameterTestforConstructor1()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(null as ComplexDoubleVector, TR5);
    }

    // Test constructor with a null parameter
    [Test]
    [ExpectedException(typeof(System.ArgumentNullException))]
    public void NullParameterTestforConstructor2()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, null as ComplexDoubleVector);
    }
    
    #endregion  Null Parameter Tests for Constructor 

    #region Zero Length Vector Tests for Constructor
    
    // Test constructor with a zero length vector parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void ZeroLengthVectorTestsforConstructor1()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(1);
      cdv.RemoveAt(0);
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(cdv, cdv);
    }

    #endregion Zero Length Vector Tests for Constructor

    #region Mismatching Vector Length Tests for Constructor

    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchVectorLengthTestsforConstructor1()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR3);
    }

    #endregion Mismatching Vector Length Tests for Constructor

    #region First Element Test for Constructor

    [Test]
    [ExpectedException(typeof(System.ArithmeticException))]
    public void FirstElementTestforConstructor1()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, Complex.One);
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, cdv);
    }

    #endregion First Element Test for Constructor

    #region Get Vector Member Tests

    // check get vector
    [Test]
    public void GetLeftColumnTest()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      ComplexDoubleVector LC = cdl.GetLeftColumn();
      Assert.IsTrue(LC5.Equals(LC));
    }
    
    // check get vector
    [Test]
    public void GetTopRowTest()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      ComplexDoubleVector TR = cdl.GetTopRow();
      Assert.IsTrue(TR5.Equals(TR));
    }
    
    #endregion Get Vector Member Tests

    #region GetMatrix Member Test
    
    // check get matrix
    [Test]
    public void GetMatrixMemberTest()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      ComplexDoubleMatrix cdldm = cdl.GetMatrix();
      for (int row = 0; row < TR5.Length; row++)
      {
        for (int column = 0; column < TR5.Length; column++)
        {
          if (column < row)
          {
            Assert.IsTrue(cdldm[row, column] == LC5[row - column]);
          }
          else
          {
            Assert.IsTrue(cdldm[row, column] == TR5[column - row]);
          }
        }
      }
    }
    
    #endregion GetMatrix Member Test

    #region Order Property Test

    // test order property
    [Test]
    public void OrderPropertyTest()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      Assert.IsTrue(cdl.Order == 5);
    }

    #endregion Order Property Test

    #region Decomposition Test 1

    // test the UDL factorisation for case 1

    [Test]
    public void DecompositionTest1()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC1, TR1);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U1[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U1[i, j] - U[i, j]) / U1[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L1[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L1[i, j] - L[i, j]) / L1[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D1[i] - D[i, i]) / D1[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 1

    #region Decomposition Test 2

    // test the UDL factorisation for case 2

    [Test]
    public void DecompositionTest2()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR2);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U2[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U2[i, j] - U[i, j]) / U2[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L2[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L2[i, j] - L[i, j]) / L2[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D2[i] - D[i, i]) / D2[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 2

    #region Decomposition Test 3

    // test the UDL factorisation for case 3

    [Test]
    public void DecompositionTest3()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, TR3);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U3[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U3[i, j] - U[i, j]) / U3[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L3[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L3[i, j] - L[i, j]) / L3[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D3[i] - D[i, i]) / D3[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 3

    #region Decomposition Test 4

    // test the UDL factorisation for case 4

    [Test]
    public void DecompositionTest4()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4, TR4);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U4[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U4[i, j] - U[i, j]) / U4[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L4[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L4[i, j] - L[i, j]) / L4[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D4[i] - D[i, i]) / D4[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 4

    #region Decomposition Test 5

    // test the UDL factorisation for case 5

    [Test]
    public void DecompositionTest5()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U5[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U5[i, j] - U[i, j]) / U5[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L5[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L5[i, j] - L[i, j]) / L5[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D5[i] - D[i, i]) / D5[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 5

    #region Decomposition Test 10

    // test the UDL factorisation for case 10

    [Test]
    public void DecompositionTest10()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleMatrix U = cdl.U;
      ComplexDoubleMatrix D = cdl.D;
      ComplexDoubleMatrix L = cdl.L;
      
      // check the upper triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (U10[i, j] != U[i, j])
          {
            e = ComplexMath.Absolute((U10[i, j] - U[i, j]) / U10[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());

      // check the lower triangle
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          if (L10[i, j] != L[i, j])
          {
            e = ComplexMath.Absolute((L10[i, j] - L[i, j]) / L10[i, j]);
            if (e > me)
            {
              me = e;
            }
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());

      // check the diagonal
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((D10[i] - D[i, i]) / D10[i]);
        if (e > me)
        {
          me = e;
        }
      }

      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion Decomposition Test 10

    #region Singularity Property Test 1

    // check that non-singular matrix is detected
    [Test]
    public void SingularityPropertyTest1()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4,TR4);
      Assert.IsFalse(cdl.IsSingular);
    }

    #endregion Singularity Property Test 1

    #region Singularity Property Test 2

    // check that singular matrix is detected
    [Test]
    public void SingularityPropertyTest2()
    {
      ComplexDoubleVector LC = new ComplexDoubleVector(4);
      LC[0] = new Complex(4.0);
      LC[1] = new Complex(2.0);
      LC[2] = new Complex(1.0);
      LC[3] = new Complex(0.0);

      ComplexDoubleVector TR = new ComplexDoubleVector(4);
      TR[0] = new Complex(4.0);
      TR[1] = new Complex(8.0);
      TR[2] = new Complex(2.0);
      TR[3] = new Complex(1.0);

      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC,TR);
      Assert.IsTrue(cdl.IsSingular);
    }

    #endregion Singularity Property Test 2

    #region GetDeterminant Method Test 1
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest1()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC1, TR1);

      // check results match
      double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det1)/Det1);
      Assert.IsTrue(e < Tolerance1);
    }
    
    #endregion GetDeterminant Method Test 1

    #region GetDeterminant Method Test 2
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest2()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR2);

      // check results match
      Double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det2)/Det2);
      Assert.IsTrue(e < Tolerance2);
    }
    
    #endregion GetDeterminant Method Test 2

    #region GetDeterminant Method Test 3
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest3()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, TR3);

      // check results match
      Double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det3)/Det3);
      Assert.IsTrue(e < Tolerance3);
    }
    
    #endregion GetDeterminant Method Test 3

    #region GetDeterminant Method Test 4
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest4()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4, TR4);

      // check results match
      Double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det4)/Det4);
      Assert.IsTrue(e < Tolerance4);
    }
    
    #endregion GetDeterminant Method Test 4

    #region GetDeterminant Method Test 5
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest5()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);

      // check results match
      Double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det5)/Det5);
      Assert.IsTrue(e < Tolerance5);
    }
    
    #endregion GetDeterminant Method Test 5

    #region GetDeterminant Method Test 10
    
    // Test the Determinant
    [Test]
    public void GetDeterminantMethodTest10()
    {
      // calculate determinant from diagonal
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);

      // check results match
      Double e = ComplexMath.Absolute((cdl.GetDeterminant() - Det10)/Det10);
      Assert.IsTrue(e < Tolerance10);
    }
    
    #endregion GetDeterminant Method Test 10

    #region Null Parameter Test for SolveVector

    [Test]
    [ExpectedException(typeof(System.ArgumentNullException))]
    public void NullParameterTestforSolveVector()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleVector X = cdl.Solve(null as ComplexDoubleVector);
    }

    #endregion Null Parameter Test for SolveVector

    #region Mismatch Rows Test for SolveVector

    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchRowsTestforSolveVector()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleVector X = cdl.Solve(X5);
    }

    #endregion Mismatch Rows Test for SolveVector

    #region SolveVector 1

    // Test solving a linear system
    [Test]
    public void SolveVector1()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC1, TR1);
      ComplexDoubleVector X = cdl.Solve(Y1);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X1[i] - X[i]) / X1[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 1

    #region SolveVector 2

    // Test solving a linear system
    [Test]
    public void SolveVector2()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR2);
      ComplexDoubleVector X = cdl.Solve(Y2);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X2[i] - X[i]) / X2[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 2

    #region SolveVector 3

    // Test solving a linear system
    [Test]
    public void SolveVector3()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, TR3);
      ComplexDoubleVector X = cdl.Solve(Y3);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X3[i] - X[i]) / X3[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 3

    #region SolveVector 4

    // Test solving a linear system
    [Test]
    public void SolveVector4()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4, TR4);
      ComplexDoubleVector X = cdl.Solve(Y4);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X4[i] - X[i]) / X4[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 4

    #region SolveVector 5

    // Test solving a linear system
    [Test]
    public void SolveVector5()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);
      ComplexDoubleVector X = cdl.Solve(Y5);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X5[i] - X[i]) / X5[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 5

    #region SolveVector 10

    // Test solving a linear system
    [Test]
    public void SolveVector10()
    {
      int i;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleVector X = cdl.Solve(Y10);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        e = ComplexMath.Absolute((X10[i] - X[i]) / X10[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion SolveVector 10

    #region Null Parameter Test for SolveMatrix

    [Test]
    [ExpectedException(typeof(System.ArgumentNullException))]
    public void NullParameterTestforSolveMatrix()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleMatrix X = cdl.Solve(null as ComplexDoubleMatrix);
    }

    #endregion Null Parameter Test for SolveMatrix

    #region Mismatch Rows Test for SolveMatrix

    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchRowsTestforSolveMatrix()
    {
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);
      ComplexDoubleMatrix X = cdl.Solve(I5);
    }

    #endregion Mismatch Rows Test for SolveMatrix

    #region Solve Matrix 1

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix1()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC1, TR1);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(1));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I1[i, j] - I[i, j]) / I1[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion Solve Matrix 1

    #region Solve Matrix 2

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix2()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR2);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(2));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I2[i, j] - I[i, j]) / I2[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }

    #endregion Solve Matrix 2
    
    #region Solve Matrix 3

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix3()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, TR3);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(3));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I3[i, j] - I[i, j]) / I3[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion Solve Matrix 3

    #region Solve Matrix 4

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix4()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4, TR4);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(4));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I4[i, j] - I[i, j]) / I4[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion Solve Matrix 4

    #region Solve Matrix 5

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix5()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(5));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I5[i, j] - I[i, j]) / I5[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion Solve Matrix 5

    #region Solve Matrix 10

    // calculate inverse by solving linear equations with identity RHS
    [Test]
    public void SolveMatrix10()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);

      // check inverse
      ComplexDoubleMatrix I = cdl.Solve(ComplexDoubleMatrix.CreateIdentity(10));
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I10[i, j] - I[i, j]) / I10[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion Solve Matrix 10

    #region Get Inverse 1

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse1()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC1, TR1);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I1[i, j] - I[i, j]) / I1[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 1

    #region Get Inverse 2

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse2()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC2, TR2);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I2[i, j] - I[i, j]) / I2[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 2

    #region Get Inverse 3

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse3()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC3, TR3);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I3[i, j] - I[i, j]) / I3[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 3

    #region Get Inverse 4

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse4()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC4, TR4);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I4[i, j] - I[i, j]) / I4[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 4

    #region Get Inverse 5

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse5()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC5, TR5);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I5[i, j] - I[i, j]) / I5[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 5

    #region Get Inverse 10

    // calculate inverse using GetInverse member
    [Test]
    public void GetInverse10()
    {
      int i, j;
      double e, me;
      ComplexDoubleLevinson cdl = new ComplexDoubleLevinson(LC10, TR10);

      // check inverse
      ComplexDoubleMatrix I = cdl.GetInverse();
      me = 0.0;
      for (i = 0; i < cdl.Order; i++)
      {
        for (j = 0; j < cdl.Order; j++)
        {
          e = ComplexMath.Absolute((I10[i, j] - I[i, j]) / I10[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion Get Inverse 10

    #region Null Parameter Test 1 for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveVector1()
    {
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(null, TR10, Y10);
    }

    #endregion Null Parameter Test 1 for Static SolveVector

    #region Null Parameter Test 2 for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveVector2()
    {
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC10, null, Y10);
    }

    #endregion Null Parameter Test 2 for Static SolveVector

    #region Null Parameter Test 3 for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveVector3()
    {
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC10, TR10, null as ComplexDoubleVector);
    }

    #endregion Null Parameter Test 3 for Static SolveVector

    #region Zero Vector Length Test for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void ZeroVectorLengthTestforStaticSolveVector()
    {
      ComplexDoubleVector LC = new ComplexDoubleVector(1);
      LC.RemoveAt(0);
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC, TR10, Y10);
    }

    #endregion Zero Vector Length Test for Static SolveVector

    #region Mismatch Dimension Test 1 for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchDimensionTestforStaticSolveVector1()
    {
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC10, TR5, Y5);
    }

    #endregion Mismatch Dimension Test 1 for Static SolveVector

    #region Mismatch Dimension Test 2 for Static SolveVector
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchDimensionTestforStaticSolveVector2()
    {
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC10, TR10, Y5);
    }

    #endregion Mismatch Dimension Test 2 for Static SolveVector

    #region First Element Test for Static SolveVector

    [Test]
    [ExpectedException(typeof(System.ArithmeticException))]
    public void FirstElementTestforStaticSolveVector()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(cdv, TR3, Y3);
    }

    #endregion First Element Test for Static SolveVector

    #region Singular Test for Static SolveVector
    
    // test with Toeplitz matrix which has a singular principal sub-matrix
    [Test]
    [ExpectedException(typeof(SingularMatrixException))]
    public void SingularTestforStaticSolveVector()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(cdv, cdv, Y3);
    }
    
    #endregion Singular Test for Static SolveVector

    #region Static Solve Vector 1
    
    [Test]
    public void StaticSolveVector1()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC1, TR1, Y1);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X1[i] - X[i]) / X1[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 1

    #region Static Solve Vector 2
    
    [Test]
    public void StaticSolveVector2()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC2, TR2, Y2);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X2[i] - X[i]) / X2[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 2

    #region Static Solve Vector 3
    
    [Test]
    public void StaticSolveVector3()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC3, TR3, Y3);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X3[i] - X[i]) / X3[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 3

    #region Static Solve Vector 4
    
    [Test]
    public void StaticSolveVector4()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC4, TR4, Y4);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X4[i] - X[i]) / X4[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 4

    #region Static Solve Vector 5
    
    [Test]
    public void StaticSolveVector5()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC5, TR5, Y5);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X5[i] - X[i]) / X5[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 5

    #region Static Solve Vector 10
    
    [Test]
    public void StaticSolveVector10()
    {
      int i;
      double e, me;
      ComplexDoubleVector X = ComplexDoubleLevinson.Solve(LC10, TR10, Y10);
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < X.Length; i++)
      {
        e = ComplexMath.Absolute((X10[i] - X[i]) / X10[i]);
        if (e > me)
        {
          me = e;
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Vector 10

    #region Null Parameter Test 1 for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveMatrix1()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(null, TR10, ComplexDoubleMatrix.CreateIdentity(10));
    }

    #endregion Null Parameter Test 1 for Static SolveMatrix

    #region Null Parameter Test 2 for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveMatrix2()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(LC10, null, ComplexDoubleMatrix.CreateIdentity(10));
    }

    #endregion Null Parameter Test 2 for Static SolveMatrix

    #region Null Parameter Test 3 for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticSolveMatrix3()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(LC10, TR10, null as ComplexDoubleMatrix);
    }

    #endregion Null Parameter Test 3 for Static SolveMatrix

    #region Zero Vector Length Test for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void ZeroVectorLengthTestforStaticSolveMatrix()
    {
      ComplexDoubleVector LC = new ComplexDoubleVector(1);
      LC.RemoveAt(0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(LC, TR10, ComplexDoubleMatrix.CreateIdentity(10));
    }

    #endregion Zero Vector Length Test for Static SolveMatrix

    #region Mismatch Dimension Test 1 for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchDimensionTestforStaticSolveMatrix1()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(LC10, TR5, ComplexDoubleMatrix.CreateIdentity(5));
    }

    #endregion Mismatch Dimension Test 1 for Static SolveMatrix

    #region Mismatch Dimension Test 2 for Static SolveMatrix
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchDimensionTestforStaticSolveMatrix2()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(LC10, TR10, ComplexDoubleMatrix.CreateIdentity(5));
    }

    #endregion Mismatch Dimension Test 2 for Static SolveMatrix

    #region First Element Test for Static SolveMatrix

    [Test]
    [ExpectedException(typeof(System.ArithmeticException))]
    public void FirstElementTestforStaticSolveMatrix()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(cdv, TR3, ComplexDoubleMatrix.CreateIdentity(3));
    }

    #endregion First Element Test for Static SolveMatrix

    #region Singular Test for Static SolveMatrix
    
    // test with Toeplitz matrix which has a singular principal sub-matrix
    [Test]
    [ExpectedException(typeof(SingularMatrixException))]
    public void SingularTestforStaticSolveMatrix()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Solve(cdv, cdv, ComplexDoubleMatrix.CreateIdentity(3));
    }
    
    #endregion Singular Test for Static SolveMatrix

    #region Static Solve Matrix 1
    
    [Test]
    public void StaticSolveMatrix1()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC1, TR1, ComplexDoubleMatrix.CreateIdentity(1));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I1[i, j] - I[i, j]) / I1[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 1

    #region Static Solve Matrix 2
    
    [Test]
    public void StaticSolveMatrix2()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC2, TR2, ComplexDoubleMatrix.CreateIdentity(2));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I2[i, j] - I[i, j]) / I2[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 2

    #region Static Solve Matrix 3
    
    [Test]
    public void StaticSolveMatrix3()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC3, TR3, ComplexDoubleMatrix.CreateIdentity(3));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I3[i, j] - I[i, j]) / I3[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 3

    #region Static Solve Matrix 4
    
    [Test]
    public void StaticSolveMatrix4()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC4, TR4, ComplexDoubleMatrix.CreateIdentity(4));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I4[i, j] - I[i, j]) / I4[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 4

    #region Static Solve Matrix 5
    
    [Test]
    public void StaticSolveMatrix5()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC5, TR5, ComplexDoubleMatrix.CreateIdentity(5));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I5[i, j] - I[i, j]) / I5[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 5

    #region Static Solve Matrix 10
    
    [Test]
    public void StaticSolveMatrix10()
    {
      int i, j;
      double e, me;
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Solve(LC10, TR10, ComplexDoubleMatrix.CreateIdentity(10));
      
      // determine the maximum error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I10[i, j] - I[i, j]) / I10[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }
    
    #endregion Static Solve Matrix 10

    #region Null Parameter Test 1 for Static Inverse
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticInverse1()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(null, TR10);
    }

    #endregion Null Parameter Test 1 for Static Inverse

    #region Null Parameter Test 2 for Static Inverse
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(ArgumentNullException))]
    public void NullParameterTestforStaticInverse2()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(LC10, null);
    }

    #endregion Null Parameter Test 2 for Static Inverse

    #region Zero Vector Length Test for Static Inverse
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void ZeroVectorLengthTestforStaticInverse()
    {
      ComplexDoubleVector LC = new ComplexDoubleVector(1);
      LC.RemoveAt(0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(LC, LC);
    }

    #endregion Zero Vector Length Test for Static Inverse

    #region Mismatch Dimension Test for Static Inverse
    
    // test null parameter
    [Test]
    [ExpectedException(typeof(System.RankException))]
    public void MismatchDimensionTestforStaticInverse()
    {
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(LC10, TR5);
    }

    #endregion Mismatch Dimension Test for Static Inverse

    #region First Element Test for Static Inverse

    [Test]
    [ExpectedException(typeof(System.ArithmeticException))]
    public void FirstElementTestforStaticInverse()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(cdv, TR3);
    }

    #endregion First Element Test for Static  Inverse

    #region Singular Test for Static Inverse
    
    // test with Toeplitz matrix which has a singular principal sub-matrix
    [Test]
    [ExpectedException(typeof(SingularMatrixException))]
    public void SingularTestforStaticInverse()
    {
      ComplexDoubleVector cdv = new ComplexDoubleVector(3, 1.0);
      ComplexDoubleMatrix X = ComplexDoubleLevinson.Inverse(cdv, cdv);
    }
    
    #endregion Singular Test for Static Inverse

    #region Static Inverse 1

    [Test]
    public void StaticInverse1()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC1, TR1);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I1[i, j] - I[i, j]) / I1[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance1, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 1

    #region Static Inverse 2

    [Test]
    public void StaticInverse2()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC2, TR2);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I2[i, j] - I[i, j]) / I2[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance2, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 2

    #region Static Inverse 3

    [Test]
    public void StaticInverse3()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC3, TR3);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I3[i, j] - I[i, j]) / I3[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance3, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 3

    #region Static Inverse 4

    [Test]
    public void StaticInverse4()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC4, TR4);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I4[i, j] - I[i, j]) / I4[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance4, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 4

    #region Static Inverse 5

    [Test]
    public void StaticInverse5()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC5, TR5);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I5[i, j] - I[i, j]) / I5[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance5, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 5

    #region Static Inverse 10

    [Test]
    public void StaticInverse10()
    {
      int i, j;
      double e, me;

      // calculate the inverse
      ComplexDoubleMatrix I = ComplexDoubleLevinson.Inverse(LC10, TR10);

      // determine the maximum relative error
      me = 0.0;
      for (i = 0; i < I.ColumnLength; i++)
      {
        for (j = 0; j < I.RowLength; j++)
        {
          e = ComplexMath.Absolute((I10[i, j] - I[i, j]) / I10[i, j]);
          if (e > me)
          {
            me = e;
          }
        }
      }
      Assert.IsTrue(me < Tolerance10, "Maximum Error = " + me.ToString());
    }

    #endregion Static Inverse 10

  }

}
