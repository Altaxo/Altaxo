using System.Drawing;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using ICSharpCode.SharpRefactory.Parser;
using ICSharpCode.SharpRefactory.Parser.AST;

COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS */

string assemblyName = null;

public CompilationUnit compilationUnit;

public string ContainingAssembly {
	set {
		assemblyName = value;
	}
}

Token t {
	get {
		return lexer.Token;
	}
}
Token la {
	get {
		return lexer.LookAhead;
	}
}

Hashtable typeStrings     = null;
ArrayList usingNamespaces = null;

public void Error(string s)
{
	if (errDist >= minErrDist) {
		errors.Error(la.line, la.col, s);
	}
	errDist = 0;
}

public Expression ParseExpression(Lexer lexer)
{
	this.errors = lexer.Errors;
	this.lexer = lexer;
	errors.SynErr = new ErrorCodeProc(SynErr);
	lexer.NextToken();
	Expression expr;
	Expr(out expr);
	return expr;
}

bool IsTypeCast()
{
	if (IsSimpleTypeCast()) {
		return true;
	}
	
	if (assemblyName != null) {
		return CheckTypeCast();
	}
	
	return GuessTypeCast();
}

bool IsSimpleTypeCast()
{
	// check: "(" pointer or array of keyword type ")"
	
	if (la.kind != Tokens.OpenParenthesis) {
		return false;
	}

	StartPeek();
	Token pt1 = Peek();
	Token pt  = Peek();
	
	return ParserUtil.IsTypeKW(pt1) && IsPointerOrDims(ref pt) &&
	       pt.kind == Tokens.CloseParenthesis;
}

bool CheckTypeCast()
{
	// check: leading "(" pointer or array of some type ")"

	if (la.kind != Tokens.OpenParenthesis) {
		return false;
	}
	
	string qualident;
	
	StartPeek();
	Token pt = Peek();
	
	return IsQualident(ref pt, out qualident) && IsPointerOrDims(ref pt) && 
	       pt.kind == Tokens.CloseParenthesis && IsType(qualident);		
}

bool IsType(string qualident)
{
	if (typeStrings == null) {
		CreateTypeStrings();
	}
	
	if (typeStrings.ContainsValue(qualident)) {
		return true;
	}
	
	foreach (string ns in usingNamespaces) {
		if (typeStrings.ContainsValue(ns + "." + qualident)) {
			return true;
		}
	}
	return false;
}

bool GuessTypeCast()
{
	// check: "(" pointer or array of some type ")" possible type cast successor
	
	if (la.kind != Tokens.OpenParenthesis) return false;
	
	string qualident;
	
	StartPeek();
	Token pt = Peek();
	
	if (IsQualident(ref pt, out qualident) && IsPointerOrDims(ref pt) && 
	    pt.kind == Tokens.CloseParenthesis) {
		// check successor
		pt = Peek();
		return pt.kind == Tokens.Identifier || pt.kind == Tokens.Literal   ||
		       pt.kind == Tokens.OpenParenthesis   || ParserUtil.IsUnaryOperator(pt)         ||
		       pt.kind == Tokens.New        || pt.kind == Tokens.This      ||
		       pt.kind == Tokens.Base       || pt.kind == Tokens.Null      ||
		       pt.kind == Tokens.Checked    || pt.kind == Tokens.Unchecked ||
		       pt.kind == Tokens.Typeof     || pt.kind == Tokens.Sizeof    ||
		       (ParserUtil.IsTypeKW(pt) && Peek().kind == Tokens.Dot);
	} else return false;
}

void CreateTypeStrings()
{
	Assembly a;
	Type[] types;
	AssemblyName [] aNames;
	
	if (assemblyName != null && assemblyName.Length > 0) {    /* AW 2002-12-30 add check for length > 0 */
		typeStrings = new Hashtable();
		a = Assembly.LoadFrom(assemblyName);
		types = a.GetTypes();
		foreach (Type t in types) 
			typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
		aNames = a.GetReferencedAssemblies();
		
		for (int i = 0; i < aNames.Length; i++) {
			a = Assembly.LoadFrom(aNames[i].Name);
			types = a.GetExportedTypes();
			
			foreach(Type t in types)
				if (usingNamespaces.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
					typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
		}
	}
}

/* Checks whether the next sequences of tokens is a qualident *
 * and returns the qualident string                           */
/* !!! Proceeds from current peek position !!! */
bool IsQualident (ref Token pt, out string qualident)
{
	qualident = "";
	if (pt.kind == Tokens.Identifier) {
		qualident = pt.val;
		pt = Peek();
		while (pt.kind == Tokens.Dot) {
			pt = Peek();
			if (pt.kind != Tokens.Identifier) return false;
			qualident += "." + pt.val;
			pt = Peek();
		}
		return true;
	} else return false;
}

/* skip: { "*" | "[" { "," } "]" } */
/* !!! Proceeds from current peek position !!! */
bool IsPointerOrDims (ref Token pt)
{
	for (;;) {
		if (pt.kind == Tokens.OpenSquareBracket) {
			do pt = Peek();
			while (pt.kind == Tokens.Comma);
			if (pt.kind != Tokens.CloseSquareBracket) return false;
		} else if (pt.kind != Tokens.Times) break;
		pt = Peek();
	}
	return true;
}

/* Return the n-th token after the current lookahead token */
void StartPeek()
{
	lexer.StartPeek();
}

Token Peek()
{
	return lexer.Peek();
}

Token Peek (int n)
{
	lexer.StartPeek();
	Token x = la;
	while (n > 0) {
		x = lexer.Peek();
		n--;
	}
	return x;
}

/*-----------------------------------------------------------------*
 * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
 * These resolution routine return a boolean value that indicates  *
 * whether the alternative at hand shall be choosen or not.        *
 * They are used in IF ( ... ) expressions.                        *       
 *-----------------------------------------------------------------*/

/* True, if ident is followed by "=" */
bool IdentAndAsgn ()
{
	return la.kind == Tokens.Identifier && Peek(1).kind == Tokens.Assign;
}

bool IsAssignment () { return IdentAndAsgn(); }

/* True, if ident is followed by ",", "=", or ";" */
bool IdentAndCommaOrAsgnOrSColon () {
	int peek = Peek(1).kind;
	return la.kind == Tokens.Identifier && 
	       (peek == Tokens.Comma || peek == Tokens.Assign || peek == Tokens.Semicolon);
}
bool IsVarDecl () { return IdentAndCommaOrAsgnOrSColon(); }

/* True, if the comma is not a trailing one, *
 * like the last one in: a, b, c,            */
bool NotFinalComma () {
	int peek = Peek(1).kind;
	return la.kind == Tokens.Comma &&
	       peek != Tokens.CloseCurlyBrace && peek != Tokens.CloseSquareBracket;
}

/* True, if "void" is followed by "*" */
bool NotVoidPointer () {
	return la.kind == Tokens.Void && Peek(1).kind != Tokens.Times;
}

/* True, if "checked" or "unchecked" are followed by "{" */
bool UnCheckedAndLBrace () {
	return la.kind == Tokens.Checked || la.kind == Tokens.Unchecked &&
	       Peek(1).kind == Tokens.OpenCurlyBrace;
}

/* True, if "." is followed by an ident */
bool DotAndIdent () {
	return la.kind == Tokens.Dot && Peek(1).kind == Tokens.Identifier;
}

/* True, if ident is followed by ":" */
bool IdentAndColon () {
	return la.kind == Tokens.Identifier && Peek(1).kind == Tokens.Colon;
}

bool IsLabel () { return IdentAndColon(); }

/* True, if ident is followed by "(" */
bool IdentAndLPar () {
	return la.kind == Tokens.Identifier && Peek(1).kind == Tokens.OpenParenthesis;
}

/* True, if "catch" is followed by "(" */
bool CatchAndLPar () {
	return la.kind == Tokens.Catch && Peek(1).kind == Tokens.OpenParenthesis;
}
bool IsTypedCatch () { return CatchAndLPar(); }

/* True, if "[" is followed by the ident "assembly" */
bool IsGlobalAttrTarget () {
	Token pt = Peek(1);
	return la.kind == Tokens.OpenSquareBracket && 
	       pt.kind == Tokens.Identifier && pt.val == "assembly";
}

/* True, if "[" is followed by "," or "]" */
bool LBrackAndCommaOrRBrack () {
	int peek = Peek(1).kind;
	return la.kind == Tokens.OpenSquareBracket &&
	       (peek == Tokens.Comma || peek == Tokens.CloseSquareBracket);
}

bool IsDims () { return LBrackAndCommaOrRBrack(); }

/* True, if "[" is followed by "," or "]" *
 * or if the current token is "*"         */
bool TimesOrLBrackAndCommaOrRBrack () {
	return la.kind == Tokens.Times || LBrackAndCommaOrRBrack();
}
bool IsPointerOrDims () { return TimesOrLBrackAndCommaOrRBrack(); }
bool IsPointer () { return la.kind == Tokens.Times; }

/* True, if lookahead is a primitive type keyword, or *
 * if it is a type declaration followed by an ident   */
bool IsLocalVarDecl () {
	if (ParserUtil.IsTypeKW(la) || la.kind == Tokens.Void) return true;
	
	StartPeek();
	Token pt = la ;  // peek token
	string ignore;
	
	return IsQualident(ref pt, out ignore) && IsPointerOrDims(ref pt) && 
	       pt.kind == Tokens.Identifier;
}

/* True, if lookahead ident is "get" */
bool IdentIsGet () {
	return la.kind == Tokens.Identifier && la.val == "get";
}

/* True, if lookahead ident is "set" */
bool IdentIsSet () {
	return la.kind == Tokens.Identifier && la.val == "set";
}

/* True, if lookahead ident is "add" */
bool IdentIsAdd () {
	return la.kind == Tokens.Identifier && la.val == "add";
}

/* True, if lookahead ident is "remove" */
bool IdentIsRemove () {
	return la.kind == Tokens.Identifier && la.val == "remove";
}

/* True, if lookahead is a local attribute target specifier, *
 * i.e. one of "event", "return", "field", "method",         *
 *             "module", "param", "property", or "type"      */
bool IsLocalAttrTarget () {
	int cur = la.kind;
	string val = la.val;

	return (cur == Tokens.Event || cur == Tokens.Return ||
	        (cur == Tokens.Identifier &&
	         (val == "field" || val == "method"   || val == "module" ||
	          val == "param" || val == "property" || val == "type"))) &&
	       Peek(1).kind == Tokens.Colon;
}


/*------------------------------------------------------------------------*
 *----- LEXER TOKEN LIST  ------------------------------------------------*
 *------------------------------------------------------------------------*/
TOKENS
	/*----- terminal classes -----*/
	/* EOF is 0 */
	ident
	literal
	
	/*----- special character -----*/
	"=" /* 3 */
	
	"+"
	"-"
	"*"
	"/"
	"%"
	
	":"
	";"
	"?"
	","
	"."
	
	"{"
	"}"
	
	"["
	"]"
	
	"("
	")"
	
	">"
	"<"
	
	"!"
	"&&"
	"||"
	
	"~"
	"&"
	"|"
	"^"

	/*----- special character sequences -----*/
	"++" /* 29 */
	"--"
	"=="
	"!="
	">="
	"<="
	
	"<<"
	">>"
	
	"+="
	"-="
	"*="
	"/="
	"%="
	"&="
	"|="
	"^="
	"<<="
	">>="
	
	"->"
	
	/*----- C# keywords -----*/
	"abstract" /* 48 */
	"as"
	"base"
	"bool"
	"break"
	"byte"
	"case"
	"catch"
	"char"
	"checked"
	"class"
	"const"
	"continue"
	"decimal"
	"default"
	"delegate"
	"do"
	"double"
	"else"
	"enum"
	"event"
	"explicit"
	"extern"
	"false"
	"finally"
	"fixed"
	"float"
	"for"
	"foreach"
	"goto"
	"if"
	"implicit"
	"in"
	"int"
	"interface"
	"internal"
	"is"
	"lock"
	"long"
	"namespace"
	"new"
	"null"
	"object"
	"operator"
	"out"
	"override"
	"params"
	"private"
	"protected"
	"public"
	"readonly"
	"ref"
	"return"
	"sbyte"
	"sealed"
	"short"
	"sizeof"
	"stackalloc"
	"static"
	"string"
	"struct"
	"switch"
	"this"
	"throw"
	"true"
	"try"
	"typeof"
	"uint"
	"ulong"
	"unchecked"
	"unsafe"
	"ushort"
	"using"
	"virtual"
	"void"
	"volatile"
	"while"

/*------------------------------------------------------------------------*
 *----- PARSER -----------------------------------------------------------*
 *------------------------------------------------------------------------*/

PRODUCTIONS

/*--- compilation unit: */
CS
(. compilationUnit = new CompilationUnit(); .)
=
	{ UsingDirective }
	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
	{ NamespaceMemberDecl }
	EOF
.

UsingDirective
(.
	usingNamespaces = new ArrayList();
	string qualident = null, aliasident = null;
.)
=
	"using"                     (. Point startPos = t.Location;
	                               INode node     = null; 
	                            .)
	[ IF (IsAssignment()) ident (. aliasident = t.val; .) "="  ]  /*--- using alias directive */
	Qualident<out qualident>    (. if (qualident != null && qualident.Length > 0) {
	                                 if (aliasident != null) {
	                                   node = new UsingAliasDeclaration(aliasident, qualident);
	                                 } else {
	                                     usingNamespaces.Add(qualident);
	                                     node = new UsingDeclaration(qualident);
	                                 }
	                               }
	                            .)
	";"                         (. node.StartLocation = startPos;
	                               node.EndLocation   = t.EndLocation;
	                               compilationUnit.AddChild(node);
	                            .)
.

GlobalAttributeSection
=
	(. Point startPos = t.Location; .)
	"[" ident                   (. if (t.val != "assembly") Error("global attribute target specifier (\"assembly\") expected");
	                               string attributeTarget = t.val;
	                               ArrayList attributes = new ArrayList();
	                               ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
	                            .)
	":" Attribute<out attribute> (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. AttributeSection section = new AttributeSection(attributeTarget, attributes);
	                               section.StartLocation = startPos;
	                               section.EndLocation = t.EndLocation;
	                               compilationUnit.AddChild(section);
	                            .)
.

Attribute<out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute>
(. string qualident; .)
=
	Qualident<out qualident>           (. ArrayList positional = new ArrayList();
	                                      ArrayList named      = new ArrayList();
	                                      string name = qualident;
	                                   .)
	[ AttributeArguments<ref positional, ref named> ] (. attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);.)
.

AttributeArguments<ref ArrayList positional, ref ArrayList named>
(.
	bool nameFound = false;
	string name = "";
	Expression expr;
.)
=
	"("
	[
		[
			IF (IsAssignment())          (. nameFound = true; .)
			ident                        (. name = t.val; .)
			"="
		] Expr<out expr>                 (. if(name == "") positional.Add(expr);
		                                    else { named.Add(new NamedArgument(name, expr)); name = ""; }
		                                 .)
		
		{
			","
				(
					IF (IsAssignment())    (. nameFound = true; .)
					ident                      (. name = t.val; .)
					"="
					| /*Empty*/                (. if (nameFound) Error("no positional argument after named argument"); .)
				) Expr<out expr>           (. if(name == "") positional.Add(expr);
				                              else { named.Add(new NamedArgument(name, expr)); name = ""; }
				                           .)
		}
	]
	")"
.

AttributeSection<out AttributeSection section>
(.
	string attributeTarget = "";
	ArrayList attributes = new ArrayList();
	ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
	
.)
=
	"[" (. Point startPos = t.Location; .) /*--- attribute target specifier: */
	[ IF (IsLocalAttrTarget())
		( "event"                       (. attributeTarget = "event";.)
		| "return"                      (. attributeTarget = "return";.)
		| ident                         (. if (t.val != "field"    || t.val != "method" ||
		                                      t.val != "module"   || t.val != "param"  ||
		                                      t.val != "property" || t.val != "type")
		                                    Error("attribute target specifier (event, return, field," +
		                                          "method, module, param, property, or type) expected");
		                                   attributeTarget = t.val;
		                                .)
		) ":" 
	]
	/*--- attribute list: */
	Attribute<out attribute>            (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. section = new AttributeSection(attributeTarget, attributes);
	                               section.StartLocation = startPos;
	                               section.EndLocation = t.EndLocation;
	                            .)
.

NamespaceMemberDecl
(.
	AttributeSection section;
	ArrayList attributes = new ArrayList();
	Modifiers m = new Modifiers(this);
	string qualident;
.)
= /*--- namespace declaration: */
	"namespace"                  (. Point startPos = t.Location; .)
	Qualident<out qualident>     (. INode node =  new NamespaceDeclaration(qualident);
	                                node.StartLocation = startPos;
	                                compilationUnit.AddChild(node);
	                                compilationUnit.BlockStart(node);
	                              .)
	"{"
	{ UsingDirective }
	{ NamespaceMemberDecl }
	"}"
	[ ";" ]                       (. node.EndLocation   = t.EndLocation;
	                                 compilationUnit.BlockEnd();
	                              .)
	/*--- type declaration: */
	| { AttributeSection<out section> (. attributes.Add(section); .) }
	{ TypeModifier<m> }
	TypeDecl<m, attributes>
.

TypeDecl<Modifiers m, ArrayList attributes>
(.
	TypeReference type;
	StringCollection names;
	ArrayList p; string name;
.)
= /*--- class declaration: */      (. m.Check(Modifier.Classes); .)
	"class"                        (. TypeDeclaration newType = new TypeDeclaration();
	                                  compilationUnit.AddChild(newType);
	                                  compilationUnit.BlockStart(newType);
	                                  
	                                  newType.Type = Types.Class;
	                                  newType.Modifier = m.Modifier;
	                                  newType.Attributes = attributes;
	                                .)
	ident                           (. newType.Name = t.val; .)
	[ ClassBase<out names>          (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
	ClassBody
	[ ";" ]                         (. newType.EndLocation = t.EndLocation; 
	                                   compilationUnit.BlockEnd();
	                                .)
	| /*--- struct declaration: */  (. m.Check(Modifier.StructsInterfacesEnumsDelegates); .)
	( "struct"                      (. TypeDeclaration newType = new TypeDeclaration();
	                                   compilationUnit.AddChild(newType);
	                                   compilationUnit.BlockStart(newType);
	                                   newType.Type = Types.Struct; 
	                                   newType.Modifier = m.Modifier;
	                                   newType.Attributes = attributes;
	                                 .)
	ident                            (. newType.Name = t.val; .)
	[ StructInterfaces<out names>    (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
	StructBody
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    compilationUnit.BlockEnd();
	                                 .)
	| /*--- interface declaration: */ 
	"interface"                      (. TypeDeclaration newType = new TypeDeclaration();
	                                    compilationUnit.AddChild(newType);
	                                    compilationUnit.BlockStart(newType);
	                                    newType.Type = Types.Interface;
	                                    newType.Attributes = attributes;
	                                    newType.Modifier = m.Modifier;.)
	ident                            (. newType.Name = t.val; .)
	[ InterfaceBase<out names>       (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
	InterfaceBody
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    compilationUnit.BlockEnd();
	                                 .)
	| /*--- enumeration declaration: */
	"enum"                           (. TypeDeclaration newType = new TypeDeclaration();
	                                    compilationUnit.AddChild(newType);
	                                    compilationUnit.BlockStart(newType);
	                                    newType.Type = Types.Enum;
	                                    newType.Attributes = attributes;
	                                    newType.Modifier = m.Modifier;.)
	ident                            (. newType.Name = t.val; .)
	[ ":" IntegralType<out name>     (. newType.BaseTypes = new StringCollection(); 
	                                    newType.BaseTypes.Add(name);
	                                 .)
	]                                (. newType.StartLocation = t.EndLocation; .)
	EnumBody 
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    compilationUnit.BlockEnd();
	                                 .)
	| /*--- delegate declaration: */
	"delegate"                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration();
	                                    delegateDeclr.StartLocation = t.Location;
	                                    delegateDeclr.Modifier = m.Modifier;
	                                    delegateDeclr.Attributes = attributes;
	                                 .)
	( IF (NotVoidPointer()) "void"   (. delegateDeclr.ReturnType = new TypeReference("void", 0, null); .)
		| Type<out type>             (. delegateDeclr.ReturnType = type; .)
	)
	ident                            (. delegateDeclr.Name = t.val; .)
	"(" [ FormalParameterList<out p> (. delegateDeclr.Parameters = p; .)
	] ")"
	";"                              (. delegateDeclr.EndLocation = t.EndLocation;
	                                    compilationUnit.AddChild(delegateDeclr);
	                                 .)
	)
.

Qualident<out string qualident>
=
	ident                              (. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
	{ IF (DotAndIdent()) "." ident     (. qualidentBuilder.Append('.');
	                                      qualidentBuilder.Append(t.val); 
	                                    .)
	} (. qualident = qualidentBuilder.ToString(); .)
.

ClassBase<out StringCollection names>
(.
	string qualident;
	names = new StringCollection(); 
.)
=
	":" ClassType<out qualident>       (. names.Add(qualident); .)
	{ "," Qualident<out qualident>     (. names.Add(qualident); .) }
.

ClassBody
(. AttributeSection section; .)
=
	"{"
	{                                  (.ArrayList attributes = new ArrayList();
		                                 Modifiers m = new Modifiers(this);
		                               .)
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		{ MemberModifier<m> } 
		ClassMemberDecl<m, attributes> 
	}
	"}"
.

StructInterfaces<out StringCollection names>
(.
	string qualident; 
	names = new StringCollection();
.)
=
	":" Qualident<out qualident>        (. names.Add(qualident); .)
	{ "," Qualident<out qualident>      (. names.Add(qualident); .) }
.

StructBody
(. AttributeSection section; .)
=
	"{" 
	{                                    (.ArrayList attributes = new ArrayList();
		                                   Modifiers m = new Modifiers(this);
		                                 .)
		{ AttributeSection<out section>  (. attributes.Add(section); .) }
		{ MemberModifier<m> } 
		StructMemberDecl<m, attributes> 
	}
	"}" 
.

InterfaceBase<out StringCollection names>
(.
	string qualident;
	names = new StringCollection();
.)
=
	":" Qualident<out qualident>    (. names.Add(qualident); .)
	{ "," Qualident<out qualident>  (. names.Add(qualident); .) }
.

InterfaceBody
= "{" { InterfaceMemberDecl } "}" .

EnumBody                                 (. FieldDeclaration f; .)
=
	"{" [ EnumMemberDecl<out f>          (. compilationUnit.AddChild(f); .)
	{ IF (NotFinalComma()) "," EnumMemberDecl<out f> (. compilationUnit.AddChild(f); .)
	}
	[","] ] "}"
.

Type<out TypeReference type>
(.
	string name = "";
	int pointer = 0;
.)
=
	( ClassType<out name>
	| SimpleType<out name>
	| "void" "*"                         (. pointer = 1; name = "void"; .)
	)                                    (. ArrayList r = new ArrayList(); .)
	{ IF (IsPointerOrDims())             (. int i = 1; .)
		( "*"                            (. ++pointer; .)
		| "[" { "," (. ++i; .) } "]"     (. r.Add(i); .)
		) 
	}                                    (. int[] rank = new int[r.Count]; r.CopyTo(rank); 
	                                        type = new TypeReference(name, pointer, rank);
	                                     .)
.

NonArrayType<out TypeReference type>
(.
	string name = "";
	int pointer = 0;
.)
=
	( ClassType<out name>
	| SimpleType<out name>
	| "void" "*"                         (. pointer = 1; name = "void"; .)
	)                                    
	{ IF (IsPointer())                   
		( "*"                            (. ++pointer; .)
		) 
	}                                    (. 
	                                        type = new TypeReference(name, pointer, null);
	                                     .)
.

SimpleType<out string name>
(. name = String.Empty; .)
=
	IntegralType<out name> 
	| "float"   (. name = t.val; .)
	| "double"  (. name = t.val; .)
	| "decimal" (. name = t.val; .)
	| "bool"    (. name = t.val; .)
.


FormalParameterList<out ArrayList parameter>
(.
	parameter = new ArrayList();
	ParameterDeclarationExpression p;
	AttributeSection section;
	ArrayList attributes = new ArrayList();
.)
=
	{ AttributeSection<out section> (.attributes.Add(section); .) }
	(
		FixedParameter<out p> (. bool paramsFound = false;
		                         p.Attributes = attributes;
		                         parameter.Add(p);
		                      .)
		{
			","                              (. attributes = new ArrayList(); if (paramsFound) Error("params array must be at end of parameter list"); .)
			{ AttributeSection<out section> (.attributes.Add(section); .) }
			(
				FixedParameter<out p>        (. p.Attributes = attributes; parameter.Add(p); .)
				| ParameterArray<out p>      (. paramsFound = true; p.Attributes = attributes; parameter.Add(p); .)
			)
		}
		| ParameterArray<out p>              (. p.Attributes = attributes; parameter.Add(p); .)
	)
.

FixedParameter<out ParameterDeclarationExpression p>
(.
	TypeReference type;
	ParamModifiers mod = ParamModifiers.In;
.)
=
	[
		"ref"    (. mod = ParamModifiers.Ref; .)
		| "out"  (. mod = ParamModifiers.Out; .)
	]
	Type<out type> ident (. p = new ParameterDeclarationExpression(type, t.val, mod); .)
.

ParameterArray<out ParameterDeclarationExpression p>
(. TypeReference type; .)
=
	"params" Type<out type> ident (. p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); .)
. 

TypeModifier<Modifiers m>
=
	"new"                              (. m.Add(Modifier.New); .)
	| "public"                         (. m.Add(Modifier.Public); .)
	| "protected"                      (. m.Add(Modifier.Protected); .)
	| "internal"                       (. m.Add(Modifier.Internal); .)
	| "private"                        (. m.Add(Modifier.Private); .)
	| "unsafe"                         (. m.Add(Modifier.Unsafe); .)
	| "abstract"                       (. m.Add(Modifier.Abstract); .)
	| "sealed"                         (. m.Add(Modifier.Sealed); .)
.

ClassType<out string name>             (. string qualident; name = "";.)
=
	Qualident<out qualident>           (. name = qualident; .)
	| "object"                         (. name = "object"; .)
	| "string"                         (. name = "string"; .)
.

IntegralType<out string name>          (. name = ""; .)
=
	"sbyte"                            (. name = "sbyte"; .)
	| "byte"                           (. name = "byte"; .)
	| "short"                          (. name = "short"; .)
	| "ushort"                         (. name = "ushort"; .)
	| "int"                            (. name = "int"; .)
	| "uint"                           (. name = "uint"; .)
	| "long"                           (. name = "long"; .)
	| "ulong"                          (. name = "ulong"; .)
	| "char"                           (. name = "char"; .)
.

MemberModifier<Modifiers m>
=
	"abstract"                         (. m.Add(Modifier.Abstract); .)
	| "extern"                         (. m.Add(Modifier.Extern); .)
	| "internal"                       (. m.Add(Modifier.Internal); .)
	| "new"                            (. m.Add(Modifier.New); .)
	| "override"                       (. m.Add(Modifier.Override); .)
	| "private"                        (. m.Add(Modifier.Private); .)
	| "protected"                      (. m.Add(Modifier.Protected); .)
	| "public"                         (. m.Add(Modifier.Public); .)
	| "readonly"                       (. m.Add(Modifier.Readonly); .)
	| "sealed"                         (. m.Add(Modifier.Sealed); .)
	| "static"                         (. m.Add(Modifier.Static); .)
	| "unsafe"                         (. m.Add(Modifier.Unsafe); .)
	| "virtual"                        (. m.Add(Modifier.Virtual); .)
	| "volatile"                       (. m.Add(Modifier.Volatile); .)
.

StructMemberDecl<Modifiers m, ArrayList attributes>
(.
	string qualident;
	TypeReference type;
	Expression expr;
	ArrayList p = new ArrayList();
	Statement stmt = null;
	ArrayList variableDeclarators = new ArrayList();
.)
=
	/*--- constant declaration: */         (. m.Check(Modifier.Constants); .)
	"const"                                (.Point startPos = t.Location; .)
	Type<out type> ident                   (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
	                                          VariableDeclaration f = new VariableDeclaration(t.val);
	                                          fd.Fields.Add(f);
	                                       .)
	"=" Expr<out expr>                     (. f.Initializer = expr; .)
	{ "," ident                            (. f = new VariableDeclaration(t.val);
	                                          fd.Fields.Add(f);
	                                       .)
		"=" Expr<out expr>                 (. f.Initializer = expr; .)
	} ";"                                  (. fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); .)
	
	/*--- void method (procedure) declaration: */
	| IF (NotVoidPointer())                (. m.Check(Modifier.PropertysEventsMethods); .)
	"void"                                 (. Point startPos = t.Location; .)
	Qualident<out qualident> "(" 
	[ FormalParameterList<out p> ] ")"     (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
	                                                                                                      m.Modifier, 
	                                                                                                      new TypeReference("void"), 
	                                                                                                      p, 
	                                                                                                      attributes);
	                                          methodDeclaration.StartLocation = startPos;
	                                          methodDeclaration.EndLocation   = t.EndLocation;
	                                          compilationUnit.AddChild(methodDeclaration);
	                                          compilationUnit.BlockStart(methodDeclaration);
	                                       .)
	( Block<out stmt> | ";" )              (. compilationUnit.BlockEnd();
	                                          methodDeclaration.Body  = (BlockStatement)stmt;
	                                       .)
	
	| /*--- event declaration: */          (. m.Check(Modifier.PropertysEventsMethods); .)
	"event"                                (. EventDeclaration eventDecl = new EventDeclaration(attributes);
	                                          eventDecl.StartLocation = t.Location;
	                                          compilationUnit.AddChild(eventDecl);
	                                          compilationUnit.BlockStart(eventDecl);
	                                          EventAddRegion addBlock = null;
	                                          EventRemoveRegion removeBlock = null;
	                                       .)
	Type<out type>                         (. eventDecl.TypeReference = type; .)
	(
		IF (IsVarDecl()) VariableDeclarator<variableDeclarators>
		{ "," VariableDeclarator<variableDeclarators> } ";"      (. eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  .)
		| Qualident<out qualident>         (. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  .)
		"{" (. eventDecl.BodyStart = t.Location; .)
		EventAccessorDecls<out addBlock, out removeBlock> 
		"}" (. eventDecl.BodyEnd   = t.EndLocation; .)
	)                                       (. compilationUnit.BlockEnd();
	                                           
	                                           eventDecl.AddRegion = addBlock;
	                                           eventDecl.RemoveRegion = removeBlock;
	                                       .)
	
	/*--- constructor or static contructor declaration: */
	| IF (IdentAndLPar())                  (. m.Check(Modifier.Constructors | Modifier.StaticConstructors); .)
	ident (. string name = t.val; Point startPos = t.Location; .) "(" [  (. m.Check(Modifier.Constructors); .)
	FormalParameterList<out p>
	]
	")" (.ConstructorInitializer init = null;  .)
	[                                      (. m.Check(Modifier.Constructors); .)
		ConstructorInitializer<out init>
	] (. 
	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
	     cd.StartLocation = startPos;
	     cd.EndLocation   = t.EndLocation;
	  .)
	
	( Block<out stmt> | ";" ) (. cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); .)
	
	/*--- conversion operator declaration: */
	|                                      (. m.Check(Modifier.Operators);
	                                          if (m.isNone) Error("at least one modifier must be set"); 
	                                       .)
	( "implicit" | "explicit" ) "operator" Type<out type> "(" Type<out type> ident ")" ( Block<out stmt> | ";" )
	
	/*--- inner type declaration: */
	| TypeDecl<m, attributes>
	| Type<out type>                       (. Point startPos = t.Location; .)
	(
		/*--- operator declaration: */     (. Token op;
		                                      m.Check(Modifier.Operators);
		                                      if (m.isNone) Error("at least one modifier must be set");
		                                   .)
		"operator" OverloadableOperator<out op> 
		"(" Type<out type> ident 
		( "," Type<out type> ident         (. if (ParserUtil.IsUnaryOperator(op))
		                                      Error("too many operands for unary operator"); 
		                                   .)
		| /* empty */                      (. if (ParserUtil.IsBinaryOperator(op))
		                                      Error("too few operands for binary operator");
		                                   .)
		)
		")" ( Block<out stmt> | ";" )
		
		/*--- field declaration: */
		| IF (IsVarDecl())                 (. m.Check(Modifier.Fields); 
		                                      FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
		                                      fd.StartLocation = startPos; 
		                                   .)
		VariableDeclarator<variableDeclarators>
		{ "," VariableDeclarator<variableDeclarators> }
		";"                                (. fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); .)
		
		/*--- unqualified indexer declaration (without interface name): */
		|                                  (. m.Check(Modifier.Indexers); .)
		"this" "[" FormalParameterList<out p> "]" (. Point endLocation = t.EndLocation; .) "{" (.
			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
			         indexer.StartLocation = startPos;
			         indexer.EndLocation   = endLocation;
			         indexer.BodyStart     = t.Location;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
		AccessorDecls<out getRegion, out setRegion> "}" (. 
			          indexer.BodyEnd    = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          compilationUnit.AddChild(indexer);
			       .)
		| Qualident<out qualident> (. Point qualIdentEndLocation = t.EndLocation; .)
		(
			/*--- "not void" method (function) declaration: */
			(                              (. m.Check(Modifier.PropertysEventsMethods); .)
			    "(" [ FormalParameterList<out p> ] ")" (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
	                                                                                                      m.Modifier, 
	                                                                                                      type, 
	                                                                                                      p, 
	                                                                                                      attributes);
	                                                      methodDeclaration.StartLocation = startPos;
	                                                      methodDeclaration.EndLocation   = t.EndLocation;
	                                                      compilationUnit.AddChild(methodDeclaration);
	                                                   .)
			     ( Block<out stmt> | ";" ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
			
			/*--- property declaration: */  
			| "{" (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
			         pDecl.StartLocation = startPos;
			         pDecl.EndLocation   = qualIdentEndLocation;
			         pDecl.BodyStart   = t.Location;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			      .)
			   AccessorDecls<out getRegion, out setRegion> 
			   "}" (. 
			          pDecl.GetRegion = getRegion;
			          pDecl.SetRegion = setRegion;
			          pDecl.BodyEnd = t.EndLocation;
			          compilationUnit.AddChild(pDecl);
			       .)
			)
			
			/*--- qualified indexer declaration (with interface name): */
			|                              (. m.Check(Modifier.Indexers); .)
			"." "this" "[" FormalParameterList<out p> "]" (.
			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
			         indexer.StartLocation = startPos;
			         indexer.EndLocation   = t.EndLocation;
			         indexer.NamespaceName = qualident;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
			  "{" (. Point bodyStart = t.Location; .)
			  AccessorDecls<out getRegion, out setRegion> 
			  "}"  (. indexer.BodyStart = bodyStart;
			          indexer.BodyEnd   = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          compilationUnit.AddChild(indexer);
			       .)
		)
	)
.

ClassMemberDecl<Modifiers m, ArrayList attributes>
(. Statement stmt = null; .)
=
	StructMemberDecl<m, attributes>
	| /*--- destructor declaration: */ (. m.Check(Modifier.Destructors); Point startPos = t.Location; .)
	"~" ident                          (. DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
	                                      d.Modifier = m.Modifier;
	                                      d.StartLocation = startPos;
	                                   .)
	"(" ")" ( Block<out stmt> | ";" )  (. d.EndLocation = t.EndLocation; 
	                                      d.Body = (BlockStatement)stmt;
	                                      compilationUnit.AddChild(d);
	                                   .)
.

InterfaceMemberDecl
(.
	TypeReference type;
	ArrayList p;
	AttributeSection section;
	Modifier mod = Modifier.None;
	ArrayList attributes = new ArrayList();
	ArrayList parameters = new ArrayList();
	string name;
	PropertyGetRegion getBlock;
	PropertySetRegion setBlock;
.)
=
	{ AttributeSection<out section>     (. attributes.Add(section); .)}
	[ "new" (. mod = Modifier.New; .) ]
	(
		/*--- interface void method (procedure) declaration: */
		IF (NotVoidPointer()) "void" ident (. name = t.val; .)
		"(" [ FormalParameterList<out p> ] ")" ";" (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference("void"), parameters, attributes);
		                                              md.EndLocation = t.EndLocation;
		                                              compilationUnit.AddChild(md);
		                                           .)
		| (
			Type<out type>
			(
				ident                  (. name = t.val; .)
				(
					/*--- interface "not void" method (function) declaration: */
					"(" [ FormalParameterList<out parameters> ] ")" ";" (. MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
					                                              md.EndLocation = t.EndLocation;
					                                              compilationUnit.AddChild(md);
					                                           .)
					/*--- interface property declaration: */
					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
					"{" InterfaceAccessors<out getBlock, out setBlock> "}" (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.EndLocation = t.EndLocation; .)
				)
				/*--- interface indexer declaration: */
				| "this" "[" FormalParameterList<out p> "]" (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
				"{" InterfaceAccessors<out getBlock, out setBlock> "}" (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.EndLocation = t.EndLocation; .)
			)
			/*--- interface event declaration: */
			| "event" Type<out type> ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
			                                  compilationUnit.AddChild(ed);
			                               .)
			";"                            (. ed.EndLocation = t.EndLocation; .)
		)
	)
.

EnumMemberDecl<out FieldDeclaration f>
(.
	Expression expr = null;
	ArrayList attributes = new ArrayList();
	AttributeSection section = null;
	VariableDeclaration varDecl = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	ident                           (. f = new FieldDeclaration(attributes);
	                                   varDecl         = new VariableDeclaration(t.val);
	                                   f.Fields.Add(varDecl);
	                                   f.StartLocation = t.Location;
	                                .)
	[ "=" Expr<out expr> (. varDecl.Initializer = expr; .) ]
.


AccessorDecls<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	ArrayList attributes = new ArrayList(); 
	AttributeSection section;
	getBlock = null;
	setBlock = null; 
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		IF (IdentIsGet())
			GetAccessorDecl<out getBlock, attributes>
			[                       (. attributes = new ArrayList(); .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				SetAccessorDecl<out setBlock, attributes>
			]
		| IF (IdentIsSet())
			SetAccessorDecl<out setBlock, attributes>
			[                        (. attributes = new ArrayList(); .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				GetAccessorDecl<out getBlock, attributes>
			]
		| ident (. Error("get or set accessor declaration expected"); .)
	)
.

GetAccessorDecl<out PropertyGetRegion getBlock, ArrayList attributes>
(. Statement stmt = null; .)
=
	ident /* "get" is not a keyword!? */
	(. if (t.val != "get") Error("get expected"); .)
	( Block<out stmt> | ";" ) (. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
.

SetAccessorDecl<out PropertySetRegion setBlock, ArrayList attributes>
(. Statement stmt = null; .)
=
	ident /* "set" is not a keyword!? */
	(. if (t.val != "set") Error("set expected"); .)
	( Block<out stmt> | ";" ) (. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); .)
.

EventAccessorDecls<out EventAddRegion addBlock, out EventRemoveRegion removeBlock>
(. AttributeSection section;
   ArrayList attributes = new ArrayList();
   Statement stmt;
   addBlock = null;
   removeBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		IF (IdentIsAdd())            (. addBlock = new EventAddRegion(attributes); .)
			AddAccessorDecl<out stmt>       (. attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; .)
			{ AttributeSection<out section> (. attributes.Add(section); .)}
			RemoveAccessorDecl<out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; .)
		| IF (IdentIsRemove())
			RemoveAccessorDecl <out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); .)
			{ AttributeSection<out section>  (. attributes.Add(section); .) }
			AddAccessorDecl<out stmt>        (. addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; .)
		| ident (. Error("add or remove accessor declaration expected"); .)
	)
.

InterfaceAccessors<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	AttributeSection section;
	ArrayList attributes = new ArrayList();
	getBlock = null; setBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		IF (IdentIsGet()) ident   (. getBlock = new PropertyGetRegion(null, attributes); .)
		| IF (IdentIsSet()) ident (. setBlock = new PropertySetRegion(null, attributes); .)
		| ident                   (. Error("set or get expected"); .)
	)
	";"                           (. attributes = new ArrayList(); .)
	[
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		(
			IF (IdentIsGet()) ident   (. if (getBlock != null) Error("get already declared");
			                             else getBlock = new PropertyGetRegion(null, attributes);
			                          .)
			| IF (IdentIsSet()) ident (. if (setBlock != null) Error("set already declared");
			                             else setBlock = new PropertySetRegion(null, attributes);
			                          .)
			| ident                   (. Error("set or get expected"); .)
		)
		";"
	]
.

VariableDeclarator<ArrayList fieldDeclaration>
(. Expression expr = null; .)
=
	ident                                 (. VariableDeclaration f = new VariableDeclaration(t.val); .)
	[ "=" VariableInitializer<out expr>   (. f.Initializer = expr; .) ] (. fieldDeclaration.Add(f); .)
.

Block<out Statement stmt> /* not BlockStatement because of EmbeddedStatement */
=
	"{" (. BlockStatement blockStmt = new BlockStatement();
	       blockStmt.StartLocation = t.Location;
	       compilationUnit.BlockStart(blockStmt);
	    .)
	{ Statement }
	"}" (. stmt = blockStmt;
	       blockStmt.EndLocation = t.EndLocation;
	       compilationUnit.BlockEnd();
	    .)
.

AddAccessorDecl<out Statement stmt>
(.stmt = null;.) 
=
	/* "add" is not a keyword!? */
	ident (. if (t.val != "add") Error("add expected"); .)
	Block<out stmt>
.

RemoveAccessorDecl<out Statement stmt>
(.stmt = null;.) 
=
	/* "remove" is not a keyword!? */
	ident (. if (t.val != "remove") Error("remove expected"); .)
	Block<out stmt>
.

ConstructorInitializer<out ConstructorInitializer ci>
(. Expression expr; ci = new ConstructorInitializer(); .)
=
	":"
	(
		"base" (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
		| "this"  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
	) 
	"("
	[ Argument<out expr> (. ci.Arguments.Add(expr); .) { "," Argument<out expr> (. ci.Arguments.Add(expr); .) } ]
	")"
.

VariableInitializer<out Expression initializerExpression>
(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
=
	Expr<out initializerExpression>
	| ArrayInitializer<out initializerExpression>
	| "stackalloc" Type<out type> "[" Expr<out expr> "]" (. initializerExpression = new StackAllocExpression(type, expr); .)
.

OverloadableOperator<out Token op>
=
	(
		"+"  | "-"  | "!"    | "~"
		| "++" | "--" | "true" | "false"
		| "*"  | "/"  | "%"    | "&"
		| "|"  | "^"  | "<<"   | ">>"
		| "==" | "!=" | ">"    | "<"
		| ">=" | "<="
	) (. op = t; .)
.

Argument<out Expression argumentexpr>
(.
	Expression expr;
	FieldDirection fd = FieldDirection.None;
.)
=
	[
		"ref" (. fd = FieldDirection.Ref; .)
		| "out" (. fd = FieldDirection.Out; .)
	]
	Expr<out expr> (. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
.

AssignmentOperator<out AssignmentOperatorType op>
(. op = AssignmentOperatorType.None; .)
=
	"="     (. op = AssignmentOperatorType.Assign; .)
	| "+="  (. op = AssignmentOperatorType.Add; .)
	| "-="  (. op = AssignmentOperatorType.Subtract; .)
	| "*="  (. op = AssignmentOperatorType.Multiply; .)
	| "/="  (. op = AssignmentOperatorType.Divide; .)
	| "%="  (. op = AssignmentOperatorType.Modulus; .)
	| "&="  (. op = AssignmentOperatorType.BitwiseAnd; .)
	| "|="  (. op = AssignmentOperatorType.BitwiseOr; .)
	| "^="  (. op = AssignmentOperatorType.ExclusiveOr; .)
	| "<<=" (. op = AssignmentOperatorType.ShiftLeft; .)
	| ">>=" (. op = AssignmentOperatorType.ShiftRight; .)
.

ArrayInitializer<out Expression outExpr>
(.
	Expression expr = null;
	ArrayInitializerExpression initializer = new ArrayInitializerExpression();
.)
=
	"{"
	[ VariableInitializer<out expr> (. initializer.CreateExpressions.Add(expr); .) { IF (NotFinalComma()) "," VariableInitializer<out expr> (. initializer.CreateExpressions.Add(expr); .) } [ "," ] ]
	"}" (. outExpr = initializer; .)
.

LocalVariableDecl<out Statement stmt>
(.
	TypeReference type;
	VariableDeclaration      var = null;
	LocalVariableDeclaration localVariableDeclaration; 
.)
=
	Type<out type> (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; .)
	LocalVariableDeclarator<out var> (. localVariableDeclaration.Variables.Add(var); .)
	{ "," LocalVariableDeclarator<out var> (. localVariableDeclaration.Variables.Add(var); .) }
	(. stmt = localVariableDeclaration; .)
.

LocalVariableDeclarator<out VariableDeclaration var>
(. Expression expr = null; .)
=
	ident (. var = new VariableDeclaration(t.val); .) [ "=" LocalVariableInitializer<out expr> (. var.Initializer = expr; .) ]
.

LocalVariableInitializer<out Expression expr>
(. expr = null; .)
=
	Expr<out expr>
	| ArrayInitializer<out expr>
.

Statement
(.
	TypeReference type;
	Expression expr;
	Statement stmt;
.)
=
	/*--- labeled statement: */
	IF (IsLabel()) ident (. compilationUnit.AddChild(new LabelStatement(t.val)); .)
	":" Statement
	/*--- local constant declaration: */
	| "const" Type<out type> (. LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; .) 
	  ident (. ident = t.val; .)
	  "=" Expr<out expr> (. var.Variables.Add(new VariableDeclaration(ident, expr)); .)
	  { "," ident (. ident = t.val; .) "=" Expr<out expr> (. var.Variables.Add(new VariableDeclaration(ident, expr)); .) }
	  ";" (. compilationUnit.AddChild(var); .)
	/*--- local variable declaration: */
	| IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> ";" (. compilationUnit.AddChild(stmt); .)
	| EmbeddedStatement<out stmt> (. compilationUnit.AddChild(stmt); .)
	/* LL(1) confict: LocalVariableDecl *
	 *            <-> StatementExpr     *
	 * ident {"." ident} { "[" Expr ... */
.

EmbeddedStatement<out Statement statement>
(.
	TypeReference type = null;
	Expression expr = null;
	Statement embeddedStatement = null;
	statement = null;
.)
=
	Block<out statement>
	/*--- empty statement: */
	| ";"                       (. statement = new EmptyStatement(); .)
	/*--- checked / unchecked statement: */
	| IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
	("checked" | "unchecked"    (. isChecked = false;.) )
	Block<out block>            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
	/*--- expression statement: */
	| StatementExpr<out statement> ";"
	/*--- selection statements (if, switch): */
	| "if"                      (. Statement elseStatement = null; .)
	"(" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement>
	[ "else" EmbeddedStatement<out elseStatement> ]
	                            (. statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); .)
	| "switch" (. ArrayList switchSections = new ArrayList(); .)
	  "(" Expr<out expr> ")"
	  "{" { SwitchSection<out statement> (. switchSections.Add(statement); .) } 
	  "}"  (. statement = new SwitchStatement(expr, switchSections); .)
	/*--- iteration statements (while, do, for, foreach): */
	| "while" "(" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement> (. statement = new WhileStatement(expr, embeddedStatement); .)
	| "do" EmbeddedStatement<out embeddedStatement> "while"
	"(" Expr<out expr> ")" ";"  (. statement = new DoWhileStatement(expr, embeddedStatement); .)
	| "for" (. ArrayList initializer = null, iterator = null; .)
	  "(" [ ForInitializer<out initializer> ] ";"
	  [ Expr<out expr> ] ";"
	  [ ForIterator<out iterator> ] ")"
	  EmbeddedStatement<out embeddedStatement> (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
	| "foreach" "(" Type<out type> ident     (. string varName = t.val; .)
	"in" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement> (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); .)
	/*--- jump statements (break, contine, goto, return, throw): */
	| "break" ";"               (. statement = new BreakStatement(); .)
	| "continue" ";"            (. statement = new ContinueStatement(); .)
	| GotoStatement<out statement>
	| "return" [ Expr<out expr> ] ";"    (. statement = new ReturnStatement(expr); .)
	| "throw" [ Expr<out expr> ] ";"     (. statement = new ThrowStatement(expr); .)
	/*--- try statement: */
	| TryStatement<out statement>
	/*--- lock satement: */
	| "lock" "(" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement> (. statement = new LockStatement(expr, embeddedStatement); .)
	/*--- using statement: */
	| (.Statement resourceAcquisitionStmt = null; .)
	"using" "("
	ResourceAcquisition<out resourceAcquisitionStmt> ")"
	EmbeddedStatement<out embeddedStatement> (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
	/*--- unsafe statement: */
	| "unsafe" Block<out embeddedStatement>  (. statement = new UnsafeStatement(embeddedStatement); .)
	/*--- fixed statement: */
	| "fixed"
	"(" Type<out type>     (. if (type.PointerNestingLevel == 0) Error("can only fix pointer types");
	                          FixedStatement fxStmt = new FixedStatement(type);
	                          string identifier = null;
	                       .)
	ident                  (. identifier = t.val; .)
	"=" Expr<out expr>     (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
	{
		"," ident          (. identifier = t.val; .)
		"=" Expr<out expr> (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
	}
	")" EmbeddedStatement<out embeddedStatement>  (. fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;.)
.

ForInitializer<out ArrayList initializer>
(.
	Statement stmt; 
	initializer = new ArrayList();
.)
=
	IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> (. initializer.Add(stmt);.)
	| StatementExpr<out stmt> (.initializer.Add(stmt);.) { "," StatementExpr<out stmt> (. initializer.Add(stmt);.) } (. initializer.Add(stmt);.)
.

ForIterator<out ArrayList iterator>
(.
	Statement stmt; 
	iterator = new ArrayList();
.)
=
	StatementExpr<out stmt> (. iterator.Add(stmt);.) { "," StatementExpr<out stmt> (. iterator.Add(stmt); .) }
.

SwitchSection<out Statement stmt>
(.
	SwitchSection switchSection = new SwitchSection();
	Expression expr;
.)
=
	SwitchLabel<out expr> (. switchSection.SwitchLabels.Add(expr); .) { SwitchLabel<out expr> (. switchSection.SwitchLabels.Add(expr); .) } 
	(. compilationUnit.BlockStart(switchSection); .)
	Statement { Statement }
	(.
		compilationUnit.BlockEnd();
		stmt = switchSection;
	.)
.

SwitchLabel<out Expression expr>
 (. expr = null; .)
=
	"case" Expr<out expr> ":" 
	| "default" ":"
.

TryStatement<out Statement tryStatement>
(.
	Statement blockStmt = null, finallyStmt = null;
	ArrayList catchClauses = null;
.)
=
	"try"  Block<out blockStmt>
	(
		CatchClauses<out catchClauses> [ "finally" Block<out finallyStmt> ]
		| "finally" Block<out finallyStmt>
	)
	(.
		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
	
	.)
.

CatchClauses<out ArrayList catchClauses>
(.
	catchClauses = new ArrayList();
.)
=
	"catch" (. string name;
	           string identifier;
	           Statement stmt; 
	        .)
	/*--- general catch clause (as only catch clause) */
	(
		Block<out stmt> (. catchClauses.Add(new CatchClause(stmt)); .)
		/*--- specific catch clause */
		| "(" ClassType<out name> (. identifier = null; .) [ ident (. identifier = t.val; .) ] ")" Block<out stmt>  (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .)
		{ IF (IsTypedCatch()) "catch" "(" ClassType<out name> (. identifier = null; .) [ ident (. identifier = t.val; .) ] ")" Block<out stmt> (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .) }
		/*--- general catch clause (after specific catch clauses, optional) */
		[ "catch" Block<out stmt> (. catchClauses.Add(new CatchClause(stmt)); .) ]
	)
.

GotoStatement<out Statement stmt>
(. Expression expr; stmt = null; .)
=
	"goto"
	(
		ident (. stmt = new GotoStatement(t.val); .) ";"
		| "case" Expr<out expr>  ";" (. stmt = new GotoCaseStatement(expr); .)
		| "default" ";" (. stmt = new GotoCaseStatement(null); .)
	)
.

ResourceAcquisition<out Statement stmt>
(.
	stmt = null;
	Expression expr;
.)
=
	(
		IF (IsLocalVarDecl()) LocalVariableDecl<out stmt>
		| Expr<out expr> /* LL(1) conflict resoltion:                             *
		                  * check if next is Qualident followed by ident          *
		                  * ==> LocalVariableDecl                                 *
		                  * new problem: first set of ResourceAcquisition changes */
		(. stmt = new StatementExpression(expr); .)
	)
.

StatementExpr<out Statement stmt>
=
	/* We don't know why, but it's in the grammar. */
	/* (see internal document: assignment.txt) */
	(.
		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
		                        la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
		                        la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
		Expression expr = null;
	.)
	
	UnaryExpr<out expr>
	/*--- assignment */
	(
		(. AssignmentOperatorType op; Expression val; .) AssignmentOperator<out op> Expr<out val> (. expr = new AssignmentExpression(expr, op, val); .)
		| (. if (mustBeAssignment) Error("error in assignment."); .)
	) (. stmt = new StatementExpression(expr); .)
.

Expr<out Expression expr>
(. expr = new Expression(); .)
=
	UnaryExpr<out expr>
	/*--- conditional expression: */
	(
		ConditionalOrExpr<ref expr> [ "?" Expr<out expr> ":" Expr<out expr> ]
		/*--- assignment: */
		| (. AssignmentOperatorType op; Expression val; .) AssignmentOperator<out op> Expr<out val> (. expr = new AssignmentExpression(expr, op, val); .)
	)
.


UnaryExpr<out Expression uExpr>
(.
	TypeReference type = null;
	Expression expr;
	UnaryOperatorType uop = UnaryOperatorType.None;
	bool isUOp = false;
	bool isCast = false;
.)
=
	{
		  "+"  (. uop = UnaryOperatorType.Plus; isUOp = true; .)
		| "-"  (. uop = UnaryOperatorType.Minus; isUOp = true; .)
		| "!"  (. uop = UnaryOperatorType.Not;  isUOp = true;.)
		| "~"  (. uop = UnaryOperatorType.BitNot; isUOp = true; .)
		| "*"  (. uop = UnaryOperatorType.Star;  isUOp = true; .)
		| "++" (. uop = UnaryOperatorType.Increment; isUOp = true; .)
		| "--" (. uop = UnaryOperatorType.Decrement; isUOp = true; .)
		| "&"  (. uop = UnaryOperatorType.BitWiseAnd; isUOp = true; .)
		
		/*--- cast expression: */
		/* Problem:  "(" Type ")" from here and                     *
		 *           "(" Expr ")" from PrimaryExpr                  *
		 *           are not distinguishable                        *
		 * Solution: (in IsTypeCast())                              *
		 * use external information from compiled assembly or guess */
		| IF (IsTypeCast()) "(" Type<out type> ")"  (. isCast = true; .)
	}
	PrimaryExpr<out expr> (. if (isUOp) { 
	                             uExpr = new UnaryOperatorExpression(expr, uop);
	                         } else if (isCast) {
	                             uExpr = new CastExpression(type, expr);
	                         } else {
	                             uExpr = expr;
	                         }
	                      .)
.


PrimaryExpr<out Expression pexpr>
(.
	TypeReference type = null;
	bool isArrayCreation = false;
	Expression expr;
	pexpr = null;
.)
=
	(
		"true"                              (.pexpr = new PrimitiveExpression(true, "true");  .)
		| "false"                           (.pexpr = new PrimitiveExpression(false, "false"); .)
		| "null"                            (.pexpr = new PrimitiveExpression(null, "null");  .)          /* from literal token */
		| literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
		/*--- simple name: */
		| ident (. pexpr = new IdentifierExpression(t.val); .)
		/*--- parenthesized expression: */
		| "(" Expr<out expr> ")" (. pexpr = new ParenthesizedExpression(expr); .)
		| /*--- predefined type member access: */
		(
			"bool"   | "byte"   | "char" | "decimal" | "double"
			| "float"  | "int"    | "long" | "object"  | "sbyte"
			| "short"  | "string" | "uint" | "ulong"   | "ushort"
		) (. string val = t.val; .) "." ident (. pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); .)
		/*--- this access: */
		| "this"                              (. pexpr = new ThisReferenceExpression(); .)
		/*--- base access: */
		| "base"                              (. Expression retExpr = new BaseReferenceExpression(); .)
		(
			"." ident                         (. retExpr = new FieldReferenceExpression(retExpr, t.val); .)
			| "[" Expr<out expr>              (.ArrayList indices = new ArrayList(); indices.Add(expr); .)
			{ "," Expr<out expr>              (. indices.Add(expr); .) }
			"]"                               (. retExpr = new IndexerExpression(retExpr, indices); .)
		)                                     (. pexpr = retExpr; .)
		| "new" NonArrayType<out type>                (. ArrayList parameters = new ArrayList(); .)
		/*--- delegate / object creation expression: */
		/* Note: a delegate creation expression allow only a single Expr  *
		 *       not an argument list, but this is not distinguished here */
		(
			"(" (. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .) [ Argument<out expr>          (. parameters.Add(expr); .)
			{ "," Argument<out expr>          (. parameters.Add(expr); .) } ] ")" (. pexpr = oce; .)
			/*--- array creation expression: */
			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type, parameters); pexpr = ace; .)
			"[" (. int dims = 0; ArrayList rank = new ArrayList(); .)
			(
				Expr<out expr> (. parameters.Add(expr); .) { "," Expr<out expr> (. parameters.Add(expr); .) } "]"
				{ IF (IsDims()) "[" (.dims =0;.) { "," (.dims++;.) } (.rank.Add(dims); .) "]" } 
				(. if (rank.Count > 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } .)
				[ ArrayInitializer<out expr> (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .) ]
				
				| { "," } "]" { IF (IsDims()) "[" (.dims =0;.) { "," (.dims++;.) } (.parameters.Add(dims); .) "]" } ArrayInitializer<out expr> (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .)
			)
/*			| ArrayInitializer<out expr> (. if (!type.IsArrayType) { Error("() or [] expected"); }  pexpr =  new ArrayCreateExpression(type, (ArrayInitializerExpression)expr); .)*/
		)
		| "typeof" "("
		(
			IF (NotVoidPointer()) "void" (. type = new TypeReference("void"); .)
			| Type<out type>
		) ")"                            (. pexpr = new TypeOfExpression(type); .)
		| "sizeof" "(" Type<out type> ")" (. pexpr = new SizeOfExpression(type); .)
		| "checked" "(" Expr<out expr> ")" (. pexpr = new CheckedExpression(expr); .)
		| "unchecked" "(" Expr<out expr> ")" (. pexpr = new CheckedExpression(expr); .)
	)
	{
		(
			"++"   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
			| "--" (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
		)
		/*--- member access */
		| "->" ident (. pexpr = new PointerReferenceExpression(pexpr, t.val); .)
		| "." ident (. pexpr = new FieldReferenceExpression(pexpr, t.val);.)
		/*--- invocation expression: */
		| "("                        (. ArrayList parameters = new ArrayList(); .)
			[ Argument<out expr>     (. parameters.Add(expr); .)
			{ "," Argument<out expr> (. parameters.Add(expr); .)
			} ] ")"                  (. pexpr = new InvocationExpression(pexpr, parameters); .)
		/*--- element access */
		|  (. if (isArrayCreation) Error("element access not allow on array creation");
		      ArrayList indices = new ArrayList();
		   .)
		"[" Expr<out expr> (.indices.Add(expr); .)
		{ "," Expr<out expr> (. indices.Add(expr); .)
		} "]" (. pexpr = new IndexerExpression(pexpr, indices); .)
	}
.

ConditionalOrExpr<ref Expression outExpr>
(. Expression expr; .)
=
	ConditionalAndExpr<ref outExpr>  { "||" UnaryExpr<out expr> ConditionalAndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
.

ConditionalAndExpr<ref Expression outExpr>
(. Expression expr; .)
=
	InclusiveOrExpr<ref outExpr>  { "&&" UnaryExpr<out expr> InclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  .) }
.

InclusiveOrExpr<ref Expression outExpr>
(. Expression expr; .)
=
	ExclusiveOrExpr<ref outExpr>  { "|" UnaryExpr<out expr> ExclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
.

ExclusiveOrExpr<ref Expression outExpr>
(. Expression expr; .)
=
	AndExpr<ref outExpr>  { "^" UnaryExpr<out expr> AndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
.

AndExpr<ref Expression outExpr>
(. Expression expr; .)
=
	EqualityExpr<ref outExpr> { "&" UnaryExpr<out expr> EqualityExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
.

EqualityExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	RelationalExpr<ref outExpr>
	{
		(
			"!="   (. op = BinaryOperatorType.InEquality; .)
			| "==" (. op = BinaryOperatorType.Equality; .)
		)
		UnaryExpr<out expr> RelationalExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
	}
.

RelationalExpr<ref Expression outExpr>
(.
	TypeReference type;
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	ShiftExpr<ref outExpr>
	{
		(
			"<"    (. op = BinaryOperatorType.LessThan; .)
			| ">"  (. op = BinaryOperatorType.GreaterThan; .)
			| "<=" (. op = BinaryOperatorType.LessThanOrEqual; .)
			| ">=" (. op = BinaryOperatorType.GreaterThanOrEqual; .)
		)
		UnaryExpr<out expr> ShiftExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
		|
		(
			"is" (. op = BinaryOperatorType.IS; .)
			| "as" (. op = BinaryOperatorType.AS; .)
		)
		Type<out type> (.  outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); .)
	}
.

ShiftExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	AdditiveExpr<ref outExpr> 
	{
		(
			"<<"   (. op = BinaryOperatorType.ShiftLeft; .)
			| ">>" (. op = BinaryOperatorType.ShiftRight; .)
		)
		UnaryExpr<out expr> AdditiveExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
	}
.

AdditiveExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	MultiplicativeExpr<ref outExpr>
	{
		(
			"+"   (. op = BinaryOperatorType.Add; .)
			| "-" (. op = BinaryOperatorType.Subtract; .)
		)
		UnaryExpr<out expr> MultiplicativeExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
	}
.

MultiplicativeExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	{
		(
			"*"   (. op = BinaryOperatorType.Multiply; .)
			| "/" (. op = BinaryOperatorType.Divide; .)
			| "%" (. op = BinaryOperatorType.Modulus; .)
		) 
		UnaryExpr<out expr> (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
	}
.
	
END CS.
